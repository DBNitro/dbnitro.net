#
Author="Andre Augusto Ribas"
SoftwareVersion="1.0.5"
DateCreation="18/08/2021"
DateModification="01/09/2023"
EMAIL_1="dba.ribas@gmail.com"
EMAIL_2="andre.ribas@icloud.com"
WEBSITE="http://dbnitro.net"
#
SepLine() {
  printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -  
}
#
SetClear() {
  printf "\033c"
}
#
DBA_HELP() {
SetClear
SepLine
echo -e "\
|#|[ DBA_001 ] DBA: VERIFY DATABASE VERSION                            |#|[ DBA_002 ] DBA: VERIFY INSTALLED PATCHES - DETAILS             |#|
|#|[ DBA_003 ] DBA: INSTANCE INFORMATION + PGA & SGA                   |#|[ DBA_004 ] DBA: GENERAL TUNING VIEW                            |#|
|#|[ DBA_005 ] DBA: DATABASE GROWN ON LASTS MONTHS                     |#|[ DBA_006 ] DBA: CONNECTIONS AVERAGE PER HOUR                   |#|
|#|[ DBA_007 ] DBA: TOP 20 DB-CPU ACTIVITY                             |#|[ DBA_008 ] DBA: VERIFY SESSIONS PER MEMORY                     |#|
|#|[ DBA_009 ] DBA: DATABASE SIZE                                      |#|[ DBA_010 ] DBA: VERIFY SESSIONS PER I/O                        |#|
|#|[ DBA_011 ] DBA: HIT RATIO THE LASTS 30 DAYS                        |#|[ DBA_012 ] DBA: VERIFY LONG OPERATIONS                         |#|
|#|[ DBA_013 ] DBA: INVALIDS OBJECTS [ @ ]                             |#|[ DBA_014 ] DBA: JOBS CONTROL OF THE CLIENT [ @ ]               |#|
|#|[ DBA_015 ] DBA: MATERIALIZEDS VIEWS DISABLED                       |#|[ DBA_016 ] DBA: VERIFY RUNNING JOBS                            |#| 
|#|[ DBA_017 ] DBA: KILL A RUNNING SESSION [ @ ]                       |#|[ DBA_018 ] DBA: VERIFY PROFILE INFORMATION                     |#| 
|#|[ DBA_019 ] DBA: BACKUP STATISTICS                                  |#|[ DBA_020 ] DBA: QTD OF ARCHIVES PER HOUR                       |#| 
|#|[ DBA_021 ] DBA: LAST FILE OF LAST BACKUP ARCH - RMAN               |#|[ DBA_022 ] DBA: LAST FILE OF LAST BACKUP FULL - RMAN           |#| 
|#|[ DBA_023 ] DBA: ARCHIVES GENERATED PER DAY                         |#|[ DBA_024 ] DBA: BACKUP LOG OF LAST BACKUP FULL - RMAN          |#| 
|#|[ DBA_025 ] DBA: BACKUP LOG OF LASTS ARCHIVES - RMAN                |#|[ DBA_026 ] DBA: ERRORS ON ALERT LOG FILE                       |#| 
|#|[ DBA_027 ] DBA: ORACLE ENTERPRISE MANAGER ALERT                    |#|[ DBA_028 ] DBA: CAPTURE STATISTICS OF DATA DICTIONARY          |#| 
|#|[ DBA_029 ] DBA: CAPTURE STATISTICS OF ALL DATABASE                 |#|[ DBA_030 ] DBA: BLOCKING LOCKS                                 |#| 
|#|[ DBA_031 ] DBA: LOCKED OBJECTS                                     |#|[ DBA_032 ] DBA: BLOCKING LOCKS [ SUMARY ]                      |#| 
|#|[ DBA_033 ] DBA: BLOCKING LOCKS [ USER DETAILS ]                    |#|[ DBA_034 ] DBA: BLOCKING LOCKS [ WAITING SQL ]                 |#| 
|#|[ DBA_035 ] DBA: LOCKED OBJECTS [ DETAILS ]                         |#|[ DBA_036 ] DBA: DML AND DDL LOCKS                              |#| 
|#|[ DBA_037 ] DBA: DML TABLE LOCKS TIME                               |#|[ DBA_038 ] DBA: VERIFY SESSIONS [ @ ]                          |#| 
|#|[ DBA_039 ] DBA: TOP 20 DATABASE SESSIONS                           |#|[ DBA_040 ] DBA: VERIFY TABLESPACES                             |#| 
|#|[ DBA_041 ] DBA: VERIFY STATISTICS - TABLES [ @ ]                   |#|[ DBA_042 ] DBA: VERIFY STATISTICS - INDEXES [ @ ]              |#| 
|#|[ DBA_043 ] DBA: CAPTURE STATISTICS - OWNER [ @ ]                   |#|[ DBA_044 ] DBA: VALIDATE OBJECTS FROM ONE OWNER [ @ ]          |#| 
|#|[ DBA_045 ] DBA: VERIFY TABLES SIZE, VALIDATE OBJ - OWNERS [ @ ]    |#|[ DBA_046 ] DBA: OWNER X OBJECTS X TYPE X QTD                   |#| 
|#|[ DBA_047 ] DBA: VERIFY INSTANCE CHARACTERSET                       |#|[ DBA_048 ] DBA: CACHE HIT RATIO [ GOOD: > 90% ]                |#| 
|#|[ DBA_049 ] DBA: VERIFY INSTANCE INSTALLED PRODUCTS                 |#|[ DBA_050 ] DBA: INSTANCE PROPERTIES                            |#| 
|#|[ DBA_051 ] DBA: INSTANCE OPTIONS                                   |#|[ DBA_052 ] DBA: INSTANCE DIFFERENTS PARAMETERS                 |#| 
|#|[ DBA_053 ] DBA: INSTANCE MODIFICABLES PARAMETERS                   |#|[ DBA_054 ] DBA: VERIFY DEAD LOCKS                              |#| 
|#|[ DBA_055 ] DBA: VERIFY SESSIONS PER I/O CONSUME                    |#|[ DBA_056 ] DBA: VERIFY FREE SEGMENTS ON DATAFILES              |#| 
|#|[ DBA_057 ] DBA: VERIFY WHICH DATAFILE CAN BE RESIZED [ @ ]         |#|[ DBA_058 ] DBA: VERIFY RECYCLEBIN                              |#| 
|#|[ DBA_059 ] DBA: CLEAR REYICLEBIN                                   |#|[ DBA_060 ] DBA: VERIFY DATABASE SESSIONS                       |#| 
|#|[ DBA_061 ] DBA: VERIFY ACTIVES SESSIONS PER OWNER                  |#|[ DBA_062 ] DBA: UNLOCKING A USER [ @ ]                         |#| 
|#|[ DBA_063 ] DBA: LOCKING A USER [ @ ]                               |#|[ DBA_064 ] DBA: REDO GROUPS INFORMATIONS                       |#| 
|#|[ DBA_065 ] DBA: SHOW ALL CORRUPTED OBJECTS                         |#|[ DBA_066 ] DBA: VERIFY SPACE OF FLASH RECOVERY AREA            |#| 
|#|[ DBA_067 ] DBA: TOTAL USERS COUNT ON DATABASE                      |#|[ DBA_068 ] DBA: VERIFY CONTROLFILES                            |#| 
|#|[ DBA_069 ] DBA: VERIFY CONSUME PER CPU                             |#|[ DBA_070 ] DBA: QUICK TUNE                                     |#| 
|#|[ DBA_071 ] DBA: VERIFY RECOMENDATIONS TUNING TOP 20 [ @ ]          |#|[ DBA_072 ] DBA: VERIFY TOP 20 TUNING HISTORY [ @ ]             |#| 
|#|[ DBA_073 ] DBA: VERIFY BACKGROUND PROCESSESS                       |#|[ DBA_074 ] DBA: TOP 100 QUERY RECOMMENDATIONS                  |#| 
|#|[ DBA_075 ] DBA: VERIFY DYNAMICS PARAMETERS [ SPFILE ]              |#|[ DBA_076 ] DBA: VERIFY DBA FEATURES USAGE STATISTICS           |#| 
|#|[ DBA_077 ] DBA: VERIFY DBA HIGH WATER MARK STATISTICS              |#|[ DBA_078 ] DBA: GLOBAL INFORMATION ABOUT I/O                   |#| 
|#|[ DBA_079 ] DBA: WHICH SEG. HAVE TOP LOGICAL I/O - PHYSICAL I/O     |#|[ DBA_080 ] DBA: VERIFY DBLINKS & FOLDERS INFO                  |#| 
|#|[ DBA_081 ] DBA: IDENTIFYING WHEN A PASSWORD WAS LAST CHANGED       |#|[ DBA_082 ] DBA: VERIFY UNDO SEGMENTS                           |#| 
|#|[ DBA_083 ] DBA: VERIFY ALL SQL STATEMENTS                          |#|[ DBA_084 ] DBA: CLONE USER COMMANDS [ @ ]                      |#| 
|#|[ DBA_085 ] DBA: VERIFY ALL INFOS ABOUT SYSAUX                      |#|[ DBA_086 ] DBA: VERIFY ALL INFOS ABOUT I/O + LATENCY           |#| 
|#|[ DBA_087 ] DBA: VERIFY MAIN TOP WAIT EVENTS PER WEEK               |#|[ DBA_088 ] DBA: VERIFY OBJECTS SIZE                            |#| 
|#|[ DBA_089 ] DBA: GENERAL DATABASE OVERVIEW                          |#|[ DBA_090 ] DBA: SQL SESSION MONITOR                            |#| 
|#|[ DBA_091 ] DBA: VERIFY ALL SQL IDS STATEMENTS                      |#|[ DBA_092 ] DBA: VERIFY NLS CONFIGURATION                       |#| 
|#|[ DBA_093 ] DBA: VERIFY FAILED LOGIN                                |#|[ DBA_094 ] DBA: VERIFY ALL SQL IDS STATEMENTS                  |#|
|#|[ DBA_095 ] DBA: VERIFY ALL PATCHES APPLIED                         |#|[ DBA_096 ] DBA: VERIFY CPU USAGE BY MINUTE                     |#|
|#|[ DBA_097 ] DBA: VERIFY STANDBY CONFIGURATION                       |#|[ DBA_098 ] DBA: VERIFY GRANTS AND PERMISSIONS BY OWNER         |#|
|#|[ DBA_099 ] DBA: USER DETAILS SESSIONS                              |#|[ DBA_100 ] DBA: VERIFY BACKUP RUNNING ON REAL TIME             |#|
|#|[ DBA_101 ] DBA: VERIFY DATABASE COMPONENTS FROM REGISTRY           |#|[ DBA_102 ] DBA: VERIFY ORACLE NET SEND AND RECEIVE SIZE VOLUME |#|
|#|[ DBA_103 ] DBA: START AN ADVISOR TASK                              |#|[ DBA_104 ] DBA:                                                |#|"
SepLine
}
#
#########################################################################################################
#
# DATABASE Funtions
#
#########################################################################################################
# DATABASE: VERIFY DATABASE VERSION
#########################################################################################################
#
DBA_001() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY DATABASE VERSION                                    #
prompt ##############################################################
col INSTANCE for a10
col SERVER for a50
col VERSION for a20
col STATUS for a8
col active_state for a12
col "STARTUP TIME" for a20
select INSTANCE_NAME AS INSTANCE
  , HOST_NAME AS SERVER
  , VERSION
  , STATUS
  , active_state
  , to_char(startup_time,'dd/mm/yyyy hh24:mi') as "STARTUP TIME"
  , case when startup_time < sysdate then 'Status OK' when startup_time < sysdate - 7 then 'DB Restarted' else 'Verify Restarted DB' end as "Status DB"
from gv\$instance;
quit;
EOF
}
#
#########################################################################################################
# VERIFY INSTALLED PATCHES - DETAILS
#########################################################################################################
#
# ### begin dbms_qopatch.get_sqlpatch_status; end; /
#
DBA_002() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # Patches Status                                             #
prompt # Registry History                                           #
prompt ##############################################################
col time for a25
col Target for a35
col Action for a100
col action_time for a40
col product for a50
col version for a30
col status for a30
col comments for a30
select to_char(action_time,'dd/mm/yyyy HH24:MI:SS') time
  , namespace || ' ' || version as Target
  , action || ' ' || comments as Action
  , version
  , case when action_time < sysdate - 120 then 'Need Patch Apply' else 'Updated Recently' end as "Patch Info"
from dba_registry_history
order by action_time;
prompt ##############################################################
prompt # PSU History                                                #
prompt ##############################################################
col action for a20
col namespace for a20
col version for a30
col comments for a100
select to_char(action_time,'dd/mm/yyyy HH24:MI:SS') as TIME
  , ACTION
  , NAMESPACE
  , VERSION
--  , BUNDLE_SERIES
  , COMMENTS
from sys.registry\$history
-- where bundle_series = 'PSU'
order by action_time;
prompt ##############################################################
prompt # Product Components                                         #
prompt ##############################################################
select PRODUCT
  , VERSION
  , status
FROM SYS.PRODUCT_COMPONENT_VERSION;
quit;
EOF
echo "##############################################################"
echo "# OPatch Version with Details                                #"
echo "##############################################################"
${ORACLE_HOME}/OPatch/opatch version
echo "##############################################################"
echo "# OPatch List Patches                                        #"
echo "##############################################################"
${ORACLE_HOME}/OPatch/opatch lspatches | sort
echo "##############################################################"
echo "# OPatch LSINVENTORY with Details                            #"
echo "##############################################################"
${ORACLE_HOME}/OPatch/opatch lsinventory
}
#
#########################################################################################################
# INSTANCE INFORMATION + PGA & SGA
#########################################################################################################
#
DBA_003() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
Prompt # INSTANCE INFORMATION + PGA + SGA                           #
prompt ##############################################################
column "name"           format a60  heading "Name"
column "HOST NAME"      format a40  heading "Host|Name"
column "INSTANCE ID"    format a10  heading "Instance|Id"
column "INSTANCE NAME"  format a15  heading "Instance|Name"
column "INSTANCE ROLE"  format a20  heading "Instance|Role"
column "DATABASE ROLE"  format a20  heading "Database|Role"
column "STARTUP TIME"   format a20  heading "Startup|Time"
column "ACTIVE STATE"   format a10  heading "Active|State"
column "status"         format a15  heading "Status"
column "version"        format a15  heading "Version"
select to_char(inst_id)                           as "INSTANCE ID"
   , a.instance_name                              as "INSTANCE NAME"
   , a.host_name                                  as "HOST NAME"
   , a.version
   , a.status
   , a.instance_role                              as "INSTANCE ROLE"
   , b.DATABASE_ROLE                              as "DATABASE ROLE"
   , a.ACTIVE_STATE                               as "ACTIVE STATE"
   , to_char(a.startup_time,'dd/mm/yyyy hh24:mi') as "STARTUP TIME"
   , case when a.startup_time < sysdate then 'Status OK' when a.startup_time < sysdate - 7 then 'DB Restarted' else 'Verify Restarted DB' end as "Status DB"
from gv\$instance a, v\$database b
order by 1;
prompt
prompt ##############################################################
Prompt # PGA                                                        #
prompt ##############################################################
show parameter pga;
prompt
prompt ##############################################################
Prompt # SGA                                                        #
prompt ##############################################################
show parameter sga;
prompt
prompt ##############################################################
PROMPT # SHARED POOL                                                #
prompt ##############################################################
col name for a50
col SIZE_KB for a20
col SIZE_MB for a20
col SIZE_GB for a20
col SIZE_TB for a20
select name
  , to_char(bytes/1024, '999G999G999G999D999') as SIZE_KB
  , to_char(bytes/1024/1024, '999G999G999G999D999') as SIZE_MB
  , to_char(bytes/1024/1024/1024, '999G999G999G999D999') as SIZE_GB
  , to_char(bytes/1024/1024/1024/1024, '999G999G999G999D999') as SIZE_TB
  , RESIZEABLE
from v\$sgainfo
order by name;
prompt
prompt ##############################################################
Prompt # SUM SGA                                                    #
prompt ##############################################################
SET SERVEROUTPUT ON
SET PAGESIZE 1000
SET LINESIZE 500
SET FEEDBACK OFF
select round(tot.bytes/1024/1024 ,2) total_mb
  , round(used.bytes/1024/1024 ,2) used_mb
  , round(free.bytes/1024/1024 ,2) free_mb
  , round(tot.bytes/1024/1024/1024 ,2) total_GB
  , round(used.bytes/1024/1024/1024 ,2) used_GB
  , round(free.bytes/1024/1024/1024 ,2) free_GB
  , round(tot.bytes/1024/1024/1024/1024 ,2) total_TB
  , round(used.bytes/1024/1024/1024/1024 ,2) used_TB
  , round(free.bytes/1024/1024/1024/1024 ,2) free_TB
from (select sum(bytes) bytes from v\$sgastat where name != 'free memory') used
   , (select sum(bytes) bytes from v\$sgastat where name = 'free memory') free
   , (select sum(bytes) bytes from v\$sgastat) tot;
prompt
prompt ##############################################################
Prompt # CPU and Memory Info                                        #
prompt ##############################################################
col name for a21 
col stat_name for a25 
col value for a15
col comments for a70
select STAT_NAME
  , to_char(VALUE) as VALUE 
  , comments 
from v\$osstat 
where stat_name in ('NUM_CPUS','NUM_CPU_CORES','NUM_CPU_SOCKETS') 
union 
select STAT_NAME
  , round(VALUE/1024/1024/1024, 2) || ' GB' 
  , comments 
from v\$osstat 
where stat_name in ('PHYSICAL_MEMORY_BYTES');
prompt
prompt ##############################################################
prompt # TOTAL USED MEMORY                                          #
prompt ##############################################################
select decode(grouping(nm), 1, 'total', nm) nm
  , round(sum(val/1024/1024)) mb
from (select 'sga' nm, sum(value) val from v\$sga union all select 'pga', sum(a.value) from v\$sesstat a, v\$statname b where b.name = 'session pga memory' and a.statistic# = b.statistic#)
group by rollup(nm);
quit;
EOF
}
#
#########################################################################################################
# GENERAL TUNING VIEW
#########################################################################################################
#
DBA_004() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # GENERAL OVERVIEW                                           #
prompt ##############################################################
DECLARE
  v_value  NUMBER;
  format(p_value in NUMBER)
    RETURN VARCHAR2 IS
  BEGIN
    RETURN LPad(to_char(Round(p_value,2),'990.00') || '%',8,' ') || '  ';
  END;
BEGIN
  -- --------------------------
  -- Dictionary Cache Hit Ratio
  -- --------------------------
  select (1 - (Sum(getmisses)/(Sum(gets) + Sum(getmisses)))) * 100
  INTO v_value
  FROM v\$rowcache;
  DBMS_Output.Put('Dictionary Cache Hit Ratio       : ' || Format(v_value));
  IF v_value < 90 THEN
    DBMS_Output.Put_Line('Increase SHARED_POOL_SIZE parameter to bring value above 90%');
  ELSE
    DBMS_Output.Put_Line('Value Acceptable.');
  END IF;
  -- -----------------------
  -- Library Cache Hit Ratio
  -- -----------------------
  select (1 -(Sum(reloads)/(Sum(pins) + Sum(reloads)))) * 100
  INTO v_value
  FROM v\$librarycache;
  DBMS_Output.Put('Library Cache Hit Ratio          : ' || Format(v_value));
  IF v_value < 99 THEN
  DBMS_Output.Put_Line('Increase SHARED_POOL_SIZE parameter to bring value above 99%');
  ELSE
    DBMS_Output.Put_Line('Value Acceptable.');
  END IF;
  -- -------------------------------
  -- DB Block Buffer Cache Hit Ratio
  -- -------------------------------
  select (1 - (phys.value / (db.value + cons.value))) * 100
  INTO v_value
  FROM v\$sysstat phys,v\$sysstat db, v\$sysstat cons
  WHERE phys.name = 'physical reads' AND db.name = 'db block gets' AND cons.name = 'consistent gets';
  DBMS_Output.Put('DB Block Buffer Cache Hit Ratio  : ' || Format(v_value));
  IF v_value < 89 THEN
    DBMS_Output.Put_Line('Increase DBA_BLOCK_BUFFERS parameter to bring value above 89%');
  ELSE
    DBMS_Output.Put_Line('Value Acceptable.');
  END IF;
  -- ---------------
  -- Latch Hit Ratio
  -- ---------------
  select (1 - (Sum(misses) / Sum(gets))) * 100
  INTO v_value
  FROM v\$latch;
  DBMS_Output.Put('Latch Hit Ratio                  : ' || Format(v_value));
  IF v_value < 98 THEN
    DBMS_Output.Put_Line('Increase number of latches to bring the value above 98%');
  ELSE
    DBMS_Output.Put_Line('Value acceptable.');
  END IF;
  -- -----------------------
  -- Disk Sort Ratio
  -- -----------------------
  select (disk.value/mem.value) * 100
  INTO v_value
  FROM v\$sysstat disk, v\$sysstat mem
  WHERE disk.name = 'sorts (disk)'
  AND mem.name  = 'sorts (memory)';
  DBMS_Output.Put('Disk Sort Ratio                  : ' || Format(v_value));
  IF v_value > 5 THEN
    DBMS_Output.Put_Line('Increase SORT_AREA_SIZE parameter to bring value below 5%');
  ELSE
    DBMS_Output.Put_Line('Value Acceptable.');
  END IF;
  -- ----------------------
  -- Rollback Segment Waits
  -- ----------------------
  select (Sum(waits)/Sum(gets))*100
  INTO v_value
  FROM v\$rollstat;
  DBMS_Output.Put('Rollback Segment Waits           : ' || Format(v_value));
  IF v_value > 5 THEN
    DBMS_Output.Put_Line('Increase number of Rollback Segments to bring the value below 5%');
  ELSE
    DBMS_Output.Put_Line('Value acceptable.');
  END IF;
  -- -------------------
  -- Dispatcher Workload
  -- -------------------
  select NVL((Sum(busy)/(Sum(busy)+Sum(idle))) * 100,0)
  INTO v_value
  FROM v\$dispatcher;
  DBMS_Output.Put('Dispatcher Workload              : ' || Format(v_value));
  IF v_value > 50 THEN
    DBMS_Output.Put_Line('Increase MTS_DISPATCHERS to bring the value below 50%');
  ELSE
    DBMS_Output.Put_Line('Value acceptable.');
  END IF;
END;
/
SET FEEDBACK ON
prompt
prompt ##############################################################
prompt # Waits by Class                                             #
prompt ##############################################################
col waits for a50
select 'Waits by Class | ' || wait_class as Waits
  , time_waited
FROM v\$system_wait_class
WHERE wait_class != 'Idle'
ORDER BY time_waited DESC;
prompt ##############################################################
Prompt # Wait Class Breakdown                                       #
prompt ##############################################################
col waits for a50
select 'Wait Class Breakdown | ' || wait_class as Waits
  , ROUND(aas, 2)
FROM (select n.wait_class, m.time_waited/m.INTSIZE_CSEC AAS
FROM v\$waitclassmetric m, v\$system_wait_class n
WHERE m.wait_class_id = n.wait_class_id
AND n.wait_class != 'Idle'
UNION ALL
select 'CPU', value/100 AAS
FROM v\$sysmetric
WHERE metric_name = 'CPU Usage Per Sec'
AND group_id = 2);
prompt
prompt ##############################################################
prompt # High-Level View                                            #
prompt ##############################################################
select  wait_class
  , total_waits
  , round(100 * (total_waits / sum_waits),2) pct_waits
  , time_waited, round(100 * (time_waited / sum_time),2) pct_time
from (select wait_class, total_waits, time_waited from v\$system_wait_class where wait_class != 'idle'),
     (select sum(total_waits) sum_waits, sum(time_waited) sum_time from v\$system_wait_class where wait_class != 'idle')
order by 5 desc;
prompt
prompt ##############################################################
prompt # Top Wait Events                                            #
prompt ##############################################################
select h.event "wait event"
  , sum(h.wait_time + h.time_waited) "total wait time"
from v\$active_session_history h
  , v\$event_name e
where h.sample_time between sysdate - 1/24 and sysdate
and h.event_id = e.event_id
and e.wait_class = 'idle'
group by h.event
order by 2 desc;
prompt
prompt ##############################################################
prompt # Table Scans                                                #
prompt ##############################################################
select to_char(sn.begin_interval_time,'YYYYMMDD hh24:mi:ss') start_date
  , to_char(sn.end_interval_time,'YYYYMMDD hh24:mi:ss') end_date
  , newmem.value-oldmem.value fts
from dba_hist_sysstat oldmem
  , dba_hist_sysstat newmem
  , dba_hist_snapshot sn
where sn.snap_id = (select max(snap_id) from dba_hist_snapshot)
and newmem.snap_id = sn.snap_id
and oldmem.snap_id = sn.snap_id-1
and oldmem.stat_name = 'table scans (long tables)'
and newmem.stat_name = 'table scans (long tables)';
prompt
prompt ##############################################################
prompt # Top SQL                                                    #
prompt ##############################################################
select h.user_id
  , u.username
  , sql.sql_text
  , sum(h.wait_time + h.time_waited) "total wait time"
from v\$active_session_history h
  , v\$sqlarea sql
  , dba_users u
  , v\$event_name e
where h.sample_time between sysdate - 1/24 and sysdate
and h.sql_id = sql.sql_id
and h.user_id = u.user_id
and h.sql_id is not null
and e.event_id = h.event_id
and e.wait_class = 'idle'
group by h.user_id,sql.sql_text, u.username order by 4 desc;
quit;
EOF
}
#
#########################################################################################################
# DATABASE GROWN ON LASTS MONTHS
#########################################################################################################
#
DBA_005() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
exec dbms_application_info.set_action('DB growth');
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col month for a20
col GROWTH_MB format 999,999,999,999,999
col GROWTH_GB format 999,999,999,999,999
col GROWTH_TB format 999,999,999,999,999
col GROWTH_MB for a25
col GROWTH_GB for a25
col GROWTH_TB for a25
prompt ##############################################################
prompt # DATABASE GROWN ON LASTS MONTHS                             #
prompt ##############################################################
select trunc(creation_time, 'MM') month
  , to_char(round(sum(bytes/1024/1024)), '9G999G999') growth_mb
  , to_char(round(sum(bytes/1024/1024/1024)), '9G999G999') growth_gb
  , to_char(round(sum(bytes/1024/1024/1024/1024)), '9G999G999') growth_tb
FROM v\$datafile
GROUP BY trunc(creation_time, 'MM')
ORDER BY trunc(creation_time, 'MM');
prompt
prompt ##############################################################
prompt # VERIFY DATABASE ENCREASY PER DAY / WEEK / MONTH
prompt ##############################################################
COL "Database Size" FORMAT a13
COL "Used Space" FORMAT a11
COL "Used in %" FORMAT a11
COL "Free in %" FORMAT a11
COL "Database Name" FORMAT a13
COL "Free Space" FORMAT a12
COL "Growth DAY" FORMAT a11
COL "Growth WEEK" FORMAT a12
COL "Growth MONTH" FORMAT a12
COL "Growth DAY in %" FORMAT a16
COL "Growth WEEK in %" FORMAT a16
COL "Growth MONTH in %" FORMAT a16
SELECT (select min(to_char(creation_time, 'dd/mm/yyyy HH24:mm:ss')) from v\$datafile)                                                                                                        "Create Time"
  , (select name from v\$database)                                                                                                                                                           "Database Name"
  , ROUND((SUM(USED.BYTES)/1024/1024/1024),2)                                                                                                                                      || ' GB'  "Database Size"
  , ROUND((SUM(USED.BYTES)/1024/1024/1024) - ROUND(FREE.K/1024/1024/1024),2)                                                                                                       || ' GB'  "Used Space"
  , ROUND(((SUM(USED.BYTES)/1024/1024/1024) - (FREE.K/1024/1024/1024))/ROUND(SUM(USED.BYTES)/1024/1024/1024,2)*100,2)                                                              || '% GB' "Used in %"
  , ROUND((FREE.K/1024/1024/1024),2)                                                                                                                                               || ' GB'  "Free Space"
  , ROUND(((SUM(USED.BYTES)/1024/1024/1024) - ((SUM(USED.BYTES)/1024/1024/1024) - ROUND(FREE.K/1024/1024/1024)))/ROUND(SUM(USED.BYTES)/1024/1024/1024,2 )*100,2)                   || '% GB' "Free in %"
  , ROUND(((SUM(USED.BYTES)/1024/1024/1024) - (FREE.K/1024/1024/1024))/(select sysdate-min(creation_time) from v\$datafile),2)                                                     || ' GB'  "Growth DAY"
  , ROUND(((SUM(USED.BYTES)/1024/1024/1024) - (FREE.K/1024/1024/1024))/(select sysdate-min(creation_time) from v\$datafile)/ROUND((SUM(USED.BYTES)/1024/1024/1024),2)*100,3)       || '% GB' "Growth DAY in %"
  , ROUND(((SUM(USED.BYTES)/1024/1024/1024) - (FREE.K/1024/1024/1024))/(select sysdate-min(creation_time) from v\$datafile)*7,2)                                                   || ' GB'  "Growth WEEK"
  , ROUND((((SUM(USED.BYTES)/1024/1024/1024) - (FREE.K/1024/1024/1024))/(select sysdate-min(creation_time) from v\$datafile)/ROUND((SUM(USED.BYTES)/1024/1024/1024),2)*100)*7,3)   || '% GB' "Growth WEEK in %"
  , ROUND(((SUM(USED.BYTES)/1024/1024/1024) - (FREE.K/1024/1024/1024))/(select sysdate-min(creation_time) from v\$datafile)*30,2)                                                  || ' GB'  "Growth MONTH"
  , ROUND((((SUM(USED.BYTES)/1024/1024/1024) - (FREE.K/1024/1024/1024))/(select sysdate-min(creation_time) from v\$datafile)/ROUND((SUM(USED.BYTES)/1024/1024/1024),2)*100)*30,3)  || '% GB' "Growth MONTH in %"
FROM (SELECT BYTES FROM V\$DATAFILE
UNION ALL
SELECT BYTES FROM V\$TEMPFILE
UNION ALL
SELECT BYTES FROM V\$LOG) USED, (SELECT SUM(BYTES) AS K FROM dba_free_space) FREE
GROUP BY FREE.K;
quit;
EOF
}
#
#########################################################################################################
# CONNECTIONS AVERAGE PER HOUR
#########################################################################################################
#
DBA_006() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # CONNECTIONS AVERAGE PER HOUR                               #
prompt ##############################################################
prompt 
select to_char(TRUNC(s.begin_interval_time,'HH24'),'DD/MM/YYYY HH24:MI:SS') snap_begin
  , sum(r.current_utilization) sessions
FROM dba_hist_resource_limit r, dba_hist_snapshot s
WHERE (TRUNC(s.begin_interval_time,'HH24'), s.snap_id ) IN
(--select the Maximum of the Snapshot IDs within an hour if more than one snapshot IDs
--have the same number of sessions within that hour , so then picking one of the snapIds
select TRUNC(sn.begin_interval_time,'HH24'),MAX(rl.snap_id)
FROM dba_hist_resource_limit rl,dba_hist_snapshot sn
WHERE TRUNC(sn.begin_interval_time) >= TRUNC(sysdate-1)
AND rl.snap_id = sn.snap_id
AND rl.resource_name = 'sessions'
AND rl.instance_number = sn.instance_number
AND (TRUNC(sn.begin_interval_time,'HH24'),rl.CURRENT_UTILIZATION ) IN
(--select the Maximum no.of sessions for a given begin interval time
-- All the snapshots within a given hour will have the same begin interval time when TRUNC is used
-- for HH24 and we are selecting the Maximum sessions for a given one hour
select TRUNC(s.begin_interval_time,'HH24'),MAX(r.CURRENT_UTILIZATION) "no_of_sess"
FROM dba_hist_resource_limit r,dba_hist_snapshot s
WHERE r.snap_id = s.snap_id
AND TRUNC(s.begin_interval_time) >= TRUNC(sysdate-1)
AND r.instance_number=s.instance_number
AND r.resource_name = 'sessions'
GROUP BY TRUNC(s.begin_interval_time,'HH24'))
GROUP BY TRUNC(sn.begin_interval_time,'HH24'),CURRENT_UTILIZATION)
AND r.snap_id = s.snap_id
AND r.instance_number = s.instance_number
AND r.resource_name = 'sessions'
GROUP BY to_char(TRUNC(s.begin_interval_time,'HH24'),'DD/MM/YYYY HH24:MI:SS')
ORDER BY snap_begin;
quit;
EOF
}
#
#########################################################################################################
# TOP 20 DB-CPU ACTIVITY
#########################################################################################################
#
DBA_007() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col STAT_NAME for a50
col "% PERC" for a10
prompt ##############################################################
prompt # TOP 20 DB-CPU ACTIVITY                                     #
prompt ##############################################################
select STAT_NAME
  , TIME_WAITED
  , case when pct_waited >= 0.5 then 'Critical' when pct_waited >= 0.2 then 'Warning' end as "Status"
  , to_char(round(pct_waited*100,1), '999D00') || '%' as "% PERC"
from (select STAT_NAME, time_waited, TIME_WAITED/sum(time_waited) over () pct_waited
from (select STAT_NAME, round(sum(VALUE)/(1000*1000)) AS time_waited
from GV\$SYS_TIME_MODEL
group by STAT_NAME)
order by 2 desc)
where rownum <= 20;
quit;
EOF
}
#
#########################################################################################################
# VERIFY SESSIONS PER MEMORY
#########################################################################################################
#
DBA_008() {
sqlplus -S / as sysdba <<EOF
set pages 1000 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY SESSIONS PER MEMORY                                 #
prompt ##############################################################
col name for a25
col program for a60
COL username for A20
COL module for A20
col machine for a50
select se.sid
  , n.name
  , s.program
  , s.machine
  , s.username
  , round(max(se.value)/(1024*1024),2) "MEM (MB)"
from v\$sesstat se, v\$statname n, v\$session s
where n.statistic# = se.statistic#
and s.sid = se.sid
and s.username != 'SYSTEM'
and n.name in ('session pga memory','session uga memory')
group by s.username, s.machine, se.sid,n.name, s.program
order by 6;
quit;
EOF
}
#
#########################################################################################################
# DBA: DATABASE SIZE
#########################################################################################################
#
DBA_009() {
sqlplus -S / as sysdba <<EOF
set pages 1000 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # DBA: DATABASE SIZE                                              #
prompt ##############################################################
col "SIZE MB" for a20
col "SIZE GB" for a20
col "SIZE TB" for a20
select to_char(sum(bytes)/1024/1024, '9G999G999D99') "SIZE MB"
  , to_char(sum(bytes)/1024/1024/1024, '9G999G999D99') "SIZE GB"
  , to_char(sum(bytes)/1024/1024/1024/1024, '9G999G999D999') "SIZE TB"
from (select sum(bytes) bytes from dba_data_files
union all
select sum(bytes) bytes from dba_temp_files
union all
select sum(bytes * members) from v\$log
union all
select sum(block_size * file_size_blks) from v\$controlfile);
prompt
prompt ##############################################################
prompt # DBA: DATAFILES AND DATABASE SIZE
prompt ##############################################################
col files for a30
col db_size for a30
select 'Number of Files: ' || dbms_xplan.FORMAT_NUMBER(count(*)) as FILES
  , 'Database Size: ' || dbms_xplan.FORMAT_SIZE(sum(bytes)) as DB_SIZE
from dba_data_files;
quit;
EOF
}
#
#########################################################################################################
# VERIFY SESSIONS PER I/O
#########################################################################################################
#
DBA_010() {
sqlplus -S / as sysdba <<EOF
set pages 2000 lines 2000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY SESSIONS PER I/O
prompt ##############################################################
col username for a25
col osuser for a25
select NVL(s.username, '(oracle)') AS username
  , s.osuser
  , s.sid
  , s.serial#
  , si.block_gets
  , si.consistent_gets
  , si.physical_reads
  , si.block_changes
  , si.consistent_changes
FROM v\$session s, v\$sess_io si
WHERE s.sid = si.sid
and s.osuser not in ('GRID','grid','ORACLE','oracle')
ORDER BY s.username, s.osuser, si.physical_reads;
quit;
EOF
}
#
#########################################################################################################
# HIT RATIO THE LASTS 30 DAYS
#########################################################################################################
#
# NON PDB
DBA_011() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
exec dbms_application_info.set_action('latches');
set pages 2000 lines 2000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # HIT RATIO THE LASTS 30 DAYS
prompt ##############################################################
col name for a60
col instance_name for a30
select instance_name
   , name
   , case when hit_ratio < 95 then 'Warning' when hit_ratio < 99 then 'Critical' end as hit_ratio
   , sleep_miss
from (select i.instance_name, l.name, round((gets-misses)/decode(gets,0,1,gets),3)*100 hit_ratio, round(sleeps/decode(misses,0,1,misses),3) sleep_miss
from gv\$latch l, gv\$instance i
where l.gets != 0
and l.inst_id = i.inst_id)
where hit_ratio < 100
order by hit_ratio;
quit;
EOF
}
#
#########################################################################################################
# VERIFY LONG OPERATIONS
#########################################################################################################
#
DBA_012() {
sqlplus -S / as sysdba <<EOF
set pages 2000 lines 2000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # ACTIVE SESSIONS AND SQL STATEMENTS                         #
prompt ##############################################################
column USERNAME for a15
column "SID/SERIAL" for a15
column "WAITING SEG" format a12 heading "WAITING|SEG"
column SQL_TEXT for a100
column machine for a35
column osuser for a15
select S.USERNAME
  , '( ' || s.sid || ',' || s.serial# || ' )' as "SID/SERIAL"
  , s.machine
  , s.osuser
  , to_char(s.seconds_in_wait) as "WAITING SEG"
  , t.sql_id
  , sql_text
from v\$sqltext_with_newlines t, V\$SESSION s
where t.address = s.sql_address and t.hash_value = s.sql_hash_value and s.status = 'ACTIVE'
order by s.sid, t.piece;
prompt
prompt ##############################################################
prompt # LOCKED OBJECT ON LONG OPERATIONS                           #
prompt ##############################################################
col OBJECT_NAME for a30
select object_name
  , object_type
  , session_id
  , type
  , lmode
  , request
  , block
  , ctime
from v\$locked_object, all_objects, v\$lock
where v\$locked_object.object_id = all_objects.object_id 
and v\$lock.id1 = all_objects.object_id 
and v\$lock.sid = v\$locked_object.session_id
order by session_id, ctime desc, object_name;
prompt
prompt ##############################################################
prompt # OPERATION NAME, HOW LONG ARE RUNNING, MESSAGE              #
prompt ##############################################################
col OPNAME for a35
col TARGET for a40
col UNITS for a10
col sofar for a10
column "TOTAL WORK" for a10 heading "TOTAL|WORK"
column "ELAPSED SECONDS" for a10 heading "ELAPSED|SECONDS"
column MESSAGE for a90
column sql_id for a15
select distinct * from (select opname
              , target
						  , to_char(sofar) as sofar
						  , sql_id
						  , to_char(totalwork) as "TOTAL WORK"
						  , units
						  , to_char(elapsed_seconds) as "ELAPSED SECONDS"
						  , substr(message,1,90) as message
						from v\$session_longops 
						order by start_time desc) 
where rownum <= 20;
prompt
prompt ##############################################################
prompt # ??? #
prompt ##############################################################
col OPNAME for a35
col TARGET for a15
select opname
  , target
  , osuser
  , sl.sql_id
  , sl.sql_hash_value
  , elapsed_seconds
  , time_remaining
FROM v\$session_longops sl
inner join v\$session s ON sl.SID = s.SID AND sl.SERIAL# = s.SERIAL# WHERE time_remaining > 0;
prompt
prompt ##############################################################
prompt # ??? #
prompt ##############################################################
col username for a15
col sql_fulltext for a75
col TARGET for a20
select s.username
  , sl.sid
  , sq.executions
  , sl.last_update_time
  , sl.sql_id
  , sl.sql_hash_value
  , opname
  , target
  , elapsed_seconds
  , time_remaining
  , sq.sql_fulltext
FROM v\$session_longops sl
INNER JOIN v\$sql sq ON sq.sql_id = sl.sql_id
INNER JOIN v\$session s ON sl.SID = s.SID AND sl.serial# = s.serial#
WHERE time_remaining > 0;
prompt
prompt ##############################################################
prompt #  #
prompt ##############################################################
col sql_id for a15
col units for a15
col opname for a35
col started for a20
col now for a20
select sql_id
  , opname
  , to_char(start_time, 'DD/MM/YYYY HH24:MI:SS') as started
  , to_char(sysdate, 'DD/MM/YYYY HH24:MI:SS') as now
--  , trunc(((((86400*(sysdate-start_time))/60)/60)/24)/7) weeks
  , trunc((((86400*(sysdate-start_time))/60)/60)/24) days
  , trunc(((86400*(sysdate-start_time))/60)/60)-24*(trunc((((86400*(sysdate-start_time))/60)/60)/24)) hours
  , trunc((86400*(sysdate-start_time))/60)-60*(trunc(((86400*(sysdate-start_time))/60)/60)) minutes
  , trunc(86400*(sysdate-start_time))-60*(trunc((86400*(sysdate-start_time))/60)) seconds
  , sofar
  , totalwork
  , units
--  , round(elapsed_seconds/60/60,2) as seconds
  , round(time_remaining/60/60,2) as remaining
FROM v\$session_longops
WHERE sofar != totalwork;
quit;
EOF
}
#
#########################################################################################################
# INVALIDS OBJECTS [ @ ]
#########################################################################################################
#
DBA_013() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # INVALIDS OBJECTS [ @ ]
prompt ##############################################################
col owner for a25
col OBJECT_TYPE for a25
col "Total of invalids objects." for a30
select owner
   , decode(object_type,null,'========================>', object_type) as "OBJECT_TYPE"
   , count(object_type) as "TOTAL"
   , decode(grouping(owner),0,null,1,'Total of invalids objects.') as " "
from dba_objects where status <> 'VALID'
group by rollup (owner, object_type)
order by owner, object_type desc;
quit;
EOF
}
#
#########################################################################################################
# JOBS CONTROL OF THE CLIENT [ @ ]
#########################################################################################################
#
DBA_014() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # JOBS CONTROL OF THE CLIENT [ @ ]
prompt ##############################################################
col COMMENTS for a90
col JOB_NAME for a40
col RUN_COUNT for a10
col owner for a10
col state for a12
col SCHEDULE_TYPE for a16
col LAST_EXEC for a20
col enabled for a8
select JOB_NAME
 , STATE
 , ENABLED
 , PROGRAM_OWNER as OWNER
 , SCHEDULE_TYPE
 , to_char(RUN_COUNT) as RUN_COUNT
 , to_char(LAST_START_DATE, 'dd/mm/yyyy HH:MM:SS') as LAST_EXEC
 , substr(COMMENTS,1,90) as COMMENTS
FROM DBA_SCHEDULER_JOBS
ORDER BY 1,2,3,4,5,6,7;
prompt
prompt ##############################################################
prompt # Show All Submited RDBMS Jobs
prompt ##############################################################
col proc format a50    heading 'Proc'
col job  format 99999  heading 'job#'
col subu format a10    heading 'Submiter' trunc
col lsd  format a10    heading 'Last|OK|Date'
col lst  format a5     heading 'Last|OK|Time'
col nrd  format a10    heading 'Next|Run|Date'
col nrt  format a5     heading 'Next|Run|Time'
col fail format 999    heading 'Errors'
col ok   format a2     heading 'OK'
select job
  , log_user as subu
  , what as proc
  , to_char(last_date,'MM/DD/YYYY') as lsd
  , substr(last_sec,1,5) as lst
  , to_char(next_date,'MM/DD/YYYY') as nrd
  , substr(next_sec,1,5) as nrt
  , failures as fail
  , decode(broken,'Y','N','Y') ok
from sys.dba_jobs;
quit;
EOF
}
#
#########################################################################################################
# MATERIALIZEDS VIEWS DISABLED
#########################################################################################################
#
DBA_015() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # MATERIALIZEDS VIEWS DISABLED
prompt ##############################################################
col owner for a20
col type for a20
select owner
   , type
   , tablespace_name
   , round(sum(mb)) as mb
from (select owner,'mview' as type, tablespace_name, round(sum(bytes)/1024/1024) as mb from dba_segments where (owner,segment_name) in
     (select owner, mview_name from dba_mviews) group by owner, segment_type, tablespace_name
union
select owner
  , 'mview_log' as type
  , tablespace_name
  , round(sum(bytes)/1024/1024) as mb
from dba_segments
where (owner, segment_name) in
(select log_owner, log_table from dba_snapshot_logs)
group by owner, segment_type, tablespace_name
union
select owner
  , 'mview_index' as type
  , tablespace_name
  , round(sum(bytes)/1024/1024) as mb
from dba_segments
where (owner,segment_name) in
(select owner, index_name from dba_indexes where (owner,table_name) in
(select owner, mview_name from dba_mviews))
group by owner, segment_type, tablespace_name) t1
group by owner,type,tablespace_name;
quit;
EOF
}
#
#########################################################################################################
# VERIFY RUNNING JOBS
#########################################################################################################
#
DBA_016() {
sqlplus -S / as sysdba <<EOF
set pages 1000 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
set on verify off
prompt ##############################################################
prompt # VERIFY RUNNING JOBS
prompt ##############################################################
prompt
col "Last Date" for a30
col "This Date" for a30
select a.job "Job"
  , a.sid
  , a.failures "Failures"
  , Substr(To_Char(a.last_date,'DD/MM/YYYY HH24:MI:SS'),1,20) "Last Date"
  , Substr(To_Char(a.this_date,'DD/MM/YYYY HH24:MI:SS'),1,20) "This Date"
FROM dba_jobs_running a;
SET VERIFY ON
quit;
EOF
}
#
#########################################################################################################
# KILL A RUNNING SESSION [ @ ]
#########################################################################################################
#
DBA_017() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # KILL A RUNNING SESSION [ @ ]
prompt ##############################################################
col MACHINE for a30
col username for a25
col OSUSER for a30
col PROGRAM for a60
col "SID,SERIAL,@INST" for a20
select OSUSER
  , MACHINE
  , SID || ',' || SERIAL# || ',@' || INST_ID as "SID,SERIAL,@INST"
  , USERNAME
  , PROGRAM
from gv\$session
where osuser not in ('GRID','grid','ORACLE','oracle')
order by 1,2,3,5;
quit;
EOF
}
#
#########################################################################################################
# VERIFY PROFILE INFORMATION
#########################################################################################################
#
DBA_018() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY PROFILE INFORMATION
prompt ##############################################################
col profile for a40
col resource_type for a30
COL RESOURCE_NAME FOR A40
COL LIMIT FOR A40
select profile
  , resource_name
  , resource_type
  , limit
from dba_profiles
order by 1,2;
quit;
EOF
}
#
#########################################################################################################
# BACKUP STATISTICS
#########################################################################################################
#
DBA_019() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col STATUS format a30
col DURATION format a10
col INPUT_TYPE for a20
col OPTIMIZED for a10
col BACKUP_SIZE for a20
col BEGIN for a20
col END for a20
prompt ##############################################################
prompt # BACKUP STATISTICS
prompt ##############################################################
prompt
select * from (select INPUT_TYPE
    , STATUS
    , OPTIMIZED
    , to_char(START_TIME,'DD/MM/YYYY hh24:mi') as BEGIN
    , to_char(END_TIME,'DD/MM/YYYY hh24:mi') as END
    , TIME_TAKEN_DISPLAY as DURATION
    , d.OUTPUT_BYTES_DISPLAY as BACKUP_SIZE
from V\$RMAN_BACKUP_JOB_DETAILS d
where START_TIME > sysdate-30
-- and INPUT_TYPE = '${SRMAN_TYPE}'
-- and INPUT_TYPE in ('DB FULL', 'RECVR AREA', 'DB INCR', 'DATAFILE FULL', 'DATAFILE INCR', 'ARCHIVELOG', 'CONTROLFILE', 'SPFILE')
order by session_key, BEGIN desc);
quit;
EOF
}
#
#########################################################################################################
# QTD OF ARCHIVES PER HOUR
#########################################################################################################
#
DBA_020() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col 00 for a5
col 01 for a5
col 02 for a5
col 03 for a5
col 04 for a5
col 05 for a5
col 06 for a5
col 07 for a5
col 08 for a5
col 09 for a5
col 10 for a5
col 11 for a5
col 12 for a5
col 13 for a5
col 14 for a5
col 15 for a5
col 16 for a5
col 17 for a5
col 18 for a5
col 19 for a5
col 20 for a5
col 21 for a5
col 22 for a5
col 23 for a5
prompt ##############################################################
prompt # QTD OF ARCHIVES PER HOUR
prompt ##############################################################
select trunc(first_time) day
  , to_char(sum(decode(to_char(first_time,'HH24'),'00',1,0)), '9999') "00"
  , to_char(sum(decode(to_char(first_time,'HH24'),'01',1,0)), '9999') "01"
  , to_char(sum(decode(to_char(first_time,'HH24'),'02',1,0)), '9999') "02"
  , to_char(sum(decode(to_char(first_time,'HH24'),'03',1,0)), '9999') "03"
  , to_char(sum(decode(to_char(first_time,'HH24'),'04',1,0)), '9999') "04"
  , to_char(sum(decode(to_char(first_time,'HH24'),'05',1,0)), '9999') "05"
  , to_char(sum(decode(to_char(first_time,'HH24'),'06',1,0)), '9999') "06"
  , to_char(sum(decode(to_char(first_time,'HH24'),'07',1,0)), '9999') "07"
  , to_char(sum(decode(to_char(first_time,'HH24'),'08',1,0)), '9999') "08"
  , to_char(sum(decode(to_char(first_time,'HH24'),'09',1,0)), '9999') "09"
  , to_char(sum(decode(to_char(first_time,'HH24'),'10',1,0)), '9999') "10"
  , to_char(sum(decode(to_char(first_time,'HH24'),'11',1,0)), '9999') "11"
  , to_char(sum(decode(to_char(first_time,'HH24'),'12',1,0)), '9999') "12"
  , to_char(sum(decode(to_char(first_time,'HH24'),'13',1,0)), '9999') "13"
  , to_char(sum(decode(to_char(first_time,'HH24'),'14',1,0)), '9999') "14"
  , to_char(sum(decode(to_char(first_time,'HH24'),'15',1,0)), '9999') "15"
  , to_char(sum(decode(to_char(first_time,'HH24'),'16',1,0)), '9999') "16"
  , to_char(sum(decode(to_char(first_time,'HH24'),'17',1,0)), '9999') "17"
  , to_char(sum(decode(to_char(first_time,'HH24'),'18',1,0)), '9999') "18"
  , to_char(sum(decode(to_char(first_time,'HH24'),'19',1,0)), '9999') "19"
  , to_char(sum(decode(to_char(first_time,'HH24'),'20',1,0)), '9999') "20"
  , to_char(sum(decode(to_char(first_time,'HH24'),'21',1,0)), '9999') "21"
  , to_char(sum(decode(to_char(first_time,'HH24'),'22',1,0)), '9999') "22"
  , to_char(sum(decode(to_char(first_time,'HH24'),'23',1,0)), '9999') "23"
from gv\$log_history
where first_time > trunc(sysdate - 30)
and first_time < sysdate + 1
group by trunc(first_time)
order by 1;
quit;
EOF
}
#
#########################################################################################################
# LAST FILE OF LAST BACKUP ARCH - RMAN
#########################################################################################################
#
DBA_021() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy hh24:mi';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # LAST FILE OF LAST BACKUP ARCH - RMAN
prompt ##############################################################
col PATH format a100
col tag format a30
col DEVICE format a10
col SIZE_BYTES_DISPLAY for a15
col BEGIN for a20
col END for a20
col STATUS for a20
select /*+ rule */ tag
  , device_type as DEVICE
  , handle as PATH
  , START_TIME as BEGIN
  , COMPLETION_TIME as END
  , rtrim(SIZE_BYTES_DISPLAY) as SIZE_BYTES_DISPLAY 
-- , status
from v\$backup_piece_details
where session_recid > (select max(session_recid) -10000 from V\$RMAN_BACKUP_JOB_DETAILS where START_TIME > sysdate-30 and input_type in('ARCHIVELOG') and status in ('COMPLETED','COMPLETED WITH WARNINGS'))
and START_TIME > sysdate-30
order by START_TIME;
quit;
EOF
}
#
#########################################################################################################
# LAST FILE OF LAST BACKUP FULL - RMAN
#########################################################################################################
#
DBA_022() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy hh24:mi';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # LAST FILE OF LAST BACKUP FULL - RMAN
prompt ##############################################################
col PATH format a100
col tag format a30
col DEVICE format a10
col SIZE_BYTES_DISPLAY for a10
col BEGIN for a20
col END for a20
select /*+ rule */ tag
  , device_type as DEVICE
  , handle as PATH
  , START_TIME as BEGIN
  , COMPLETION_TIME as END
  , SIZE_BYTES_DISPLAY
from v\$backup_piece_details
where session_recid > (select max(session_recid) -10000 from V\$RMAN_BACKUP_JOB_DETAILS where START_TIME > sysdate-30 and input_type in('DB FULL', 'DB INCR') and status in ('COMPLETED','COMPLETED WITH WARNINGS'))
and START_TIME > sysdate-30
order by START_TIME;
quit;
EOF
}
#
#########################################################################################################
# ARCHIVES GENERATED PER DAY
#########################################################################################################
#
DBA_023() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # ARCHIVES GENERATED PER DAY
prompt ##############################################################
col day for a20
col SIZE_MB for a20
col SIZE_GB for a20
col SIZE_TB for a20
select trunc(first_time) as day
  , to_char(sum(blocks * block_size)/1024/1024,'9G999G999D999') SIZE_MB
  , to_char(sum(blocks * block_size)/1024/1024/1024,'9G999G999D999') SIZE_GB
  , to_char(sum(blocks * block_size)/1024/1024/1024/1024,'9G999G999D999') SIZE_TB
from gv\$archived_log
where trunc(first_time) > sysdate -30
and trunc(first_time) < sysdate +1
group by trunc(first_time)
order by 1;
quit;
EOF
}
#
#########################################################################################################
# BACKUP LOG OF LAST BACKUP FULL - RMAN
#########################################################################################################
#
DBA_024() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # BACKUP LOG OF LAST BACKUP FULL - RMAN
prompt ##############################################################
select decode(status, 'COMPLETED', 0,1) as STATUS
  , case when decode(status, 'COMPLETED', 0,1) = 0 then 'Backup Not Running' else 'Backup Running' end as "Running Y/N"
from v\$RMAN_BACKUP_JOB_DETAILS
where session_key = (select max(session_key) from v\$RMAN_BACKUP_JOB_DETAILS where START_TIME > sysdate - 30 and input_type in('DB FULL', 'DB INCR','CONTROLFILE'));
quit;
EOF
echo ">------------------------------------------------------------------------------------------------------------"
echo " -- RMAN PROCESSES --"
echo ">------------------------------------------------------------------------------------------------------------"
ps -ef | grep rman | grep -v grep
}
#
#########################################################################################################
# BACKUP LOG OF LASTS ARCHIVES - RMAN
#########################################################################################################
#
DBA_025() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # BACKUP LOG OF LASTS ARCHIVES - RMAN
prompt ##############################################################
select decode(status, 'COMPLETED', 0,1) as STATUS
  , case when decode(status, 'COMPLETED', 0,1) = 0 then 'Backup Not Running' else 'Backup Running' end as "Running Y/N"
from v\$RMAN_BACKUP_JOB_DETAILS
where session_key = (select max(session_key) from v\$RMAN_BACKUP_JOB_DETAILS where START_TIME > sysdate - 30 and input_type in('ARCHIVELOG','CONTROLEFILE'));
quit;
EOF
echo ">------------------------------------------------------------------------------------------------------------"
echo " -- RMAN PROCESSES --"
echo ">------------------------------------------------------------------------------------------------------------"
ps -ef | grep rman | grep -v grep
}
#
#########################################################################################################
# ERRORS ON ALERT LOG FILE
#########################################################################################################
#
DBA_026() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
var days_back number;
exec :days_back := 15;
set pages 3000 lines 3000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
set feedback off
prompt ##############################################################
prompt # ERRORS ON ALERT LOG FILE
prompt ##############################################################
col "DATE_TIME" for a20
col host_address for a16
col MESSAGE_TEXT for a140
select to_char(ORIGINATING_TIMESTAMP, 'DD/MM/YYYY HH24:MI:SS') as "DATE_TIME", host_address, MESSAGE_TEXT
from sys.X\$DBGALERTEXT
where (lower(MESSAGE_TEXT) like '%ora-%' or lower(MESSAGE_TEXT) like '%error%' or lower(MESSAGE_TEXT) like '%checkpoint not complete%' or lower(MESSAGE_TEXT) like '%fail%')
and ORIGINATING_TIMESTAMP > sysdate-:days_back
order by ORIGINATING_TIMESTAMP;
col total for a80
prompt
prompt ##############################################################
select '[ GENERAL ERRORS ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where (lower(MESSAGE_TEXT) like '%error%' or lower(MESSAGE_TEXT) like '%checkpoint not complete%' or lower(MESSAGE_TEXT) like '%fail%')
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
select '[ ORACLE ERRORS ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where (lower(MESSAGE_TEXT) like '%ora-%' or lower(MESSAGE_TEXT) like '%error%' or lower(MESSAGE_TEXT) like '%fail%')
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
select '[ ORA-00600 ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where MESSAGE_TEXT like '%ORA-00600%'
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
select '[ ORA-00700 ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where MESSAGE_TEXT like '%ORA-00700%'
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
select '[ ORA-07445 ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where MESSAGE_TEXT like '%ORA-07445%'
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
quit;
EOF
}
#
#########################################################################################################
# ORACLE ENTERPRISE MANAGER ALERT
#########################################################################################################
#
DBA_027() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # ORACLE ENTERPRISE MANAGER ALERT
prompt ##############################################################
col message_type for a30
col reason for a110
col date_alert for a20
col SUGGESTED_ACTION for a30
select to_char(TIME_SUGGESTED, 'dd/mm/yyyy hh24:mi') DATE_ALERT
  , message_type
  , reason
  , SUGGESTED_ACTION
FROM dba_outstanding_alerts
order by DATE_ALERT;
quit;
EOF
}
#
#########################################################################################################
# CAPTURE STATISTICS OF DATA DICTIONARY
#########################################################################################################
#
DBA_028() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # CAPTURE STATISTICS OF DATA DICTIONARY                      #
prompt # WAIT A MOMENT PLEASE, THE STATISTICS COLLECTION IS RUNNING #
prompt ##############################################################
-- begin
   exec DBMS_STATS.GATHER_DICTIONARY_STATS;
-- end;
-- /
quit;
EOF
}
#
# exec DBMS_STATS.SET_PARAM(AUTOSTATS_TARGET,'ORACLE');
# exec dbms_stats.gather_system_stats();
# exec dbms_stats.gather_system_stats('start');
# exec dbms_stats.gather_system_stats('stop');
# exec dbms_stats.gather_system_stats('interval',60);
# exec DBMS_STATS.GATHER_SCHEMA_STATS ('SYS');
#
#########################################################################################################
# CAPTURE STATISTICS OF ALL DATABASE
#########################################################################################################
#
DBA_029() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # CAPTURE STATISTICS OF ALL DATABASE                         #
Prompt # WAIT A MOMENT PLEASE, THE STATISTICS COLLECTION IS RUNNING #
prompt ##############################################################
-- begin
   exec DBMS_STATS.GATHER_DATABASE_STATS;
-- end;
-- /
quit;
EOF
}
#
#########################################################################################################
# BLOCKING LOCKS
#########################################################################################################
#
DBA_030() {
sqlplus -S / as sysdba <<EOF
SET TERMOUT OFF TERMOUT ON ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 180 PAGESIZE 50000 TRIMSPOOL ON VERIFY OFF serveroutput ON FORMAT WRAPPED feedback OFF timing on
prompt ##############################################################
prompt # BLOCKING LOCKS
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
DECLARE
  CURSOR cur_BlockingLocks IS
    select iw.instance_name AS waiting_instance
      , sw.status AS waiting_status
      , lw.sid AS waiting_sid
      , sw.serial# AS waiting_serial_num
      , sw.username AS waiting_oracle_username
      , sw.osuser AS waiting_os_username
      , sw.machine AS waiting_machine
      , pw.spid AS waiting_spid
      , SUBSTR(sw.terminal,0, 39) AS waiting_terminal
      , SUBSTR(sw.program,0, 39) AS waiting_program
      , ROUND(lw.ctime/60) AS waiting_lock_time_min
      , DECODE (lh.type, 'CF', 'Control File', 'DX', 'Distributed Transaction', 'FS', 'File Set', 'IR', 'Instance Recovery', 'IS', 'Instance State', 'IV', 'Libcache Invalidation', 'LS', 'Log Start or Log Switch', 'MR', 'Media Recovery', 'RT', 'Redo Thread', 'RW', 'Row Wait', 'SQ', 'Sequence Number', 'ST', 'Diskspace Transaction', 'TE', 'Extend Table', 'TT', 'Temp Table', 'TX', 'Transaction', 'TM', 'DML', 'UL', 'PLSQL User_lock', 'UN', 'User Name', 'Nothing-'  ) AS waiter_lock_type
      , DECODE (lw.request, 0, 'None' /* Mon Lock equivalent */ , 1, 'NoLock' /* N */, 2, 'Row-Share (SS)' /* L */ , 3, 'Row-Exclusive (SX)' /* R */ , 4, 'Share-Table' /* S */ , 5, 'Share-Row-Exclusive (SSX)' /* C */ , 6, 'Exclusive' /* X */ , '[Nothing]' ) AS waiter_mode_request
      , ih.instance_name AS locking_instance
      , sh.status AS locking_status
      , lh.sid AS locking_sid
      , sh.serial# AS locking_serial_num
      , sh.username AS locking_oracle_username
      , sh.osuser AS locking_os_username
      , sh.machine AS locking_machine
      , ph.spid AS locking_spid
      , SUBSTR(sh.terminal,0, 39) AS locking_terminal
      , SUBSTR(sh.program,0, 39) AS locking_program
      , ROUND(lh.ctime/60) AS locking_lock_time_min
      , aw.sql_text AS waiting_sql_text
    FROM gv\$lock     lw
      , gv\$lock     lh
      , gv\$instance iw
      , gv\$instance ih
      , gv\$session  sw
      , gv\$session  sh
      , gv\$process  pw
      , gv\$process  ph
      , gv\$sqlarea  aw
    WHERE iw.inst_id  = lw.inst_id
    AND ih.inst_id  = lh.inst_id
    AND sw.inst_id  = lw.inst_id
    AND sh.inst_id  = lh.inst_id
    AND pw.inst_id  = lw.inst_id
    AND ph.inst_id  = lh.inst_id
    AND aw.inst_id  = lw.inst_id
    AND sw.sid      = lw.sid
    AND sh.sid      = lh.sid
    AND lh.id1      = lw.id1
    AND lh.id2      = lw.id2
    AND lh.request  = 0
    AND lw.lmode    = 0
    AND (lh.id1, lh.id2) IN ( select id1, id2 FROM gv\$lock WHERE request = 0 INTERSECT select id1, id2 FROM gv\$lock WHERE  lmode = 0)
    AND sw.paddr  = pw.addr (+)
    AND sh.paddr  = ph.addr (+)
    AND sw.sql_address  = aw.address
    ORDER BY iw.instance_name, lw.sid;
    TYPE t_BlockingLockRecord IS RECORD (
        WaitingInstanceName       VARCHAR2(16)
      , WaitingStatus             VARCHAR2(8)
      , WaitingSid                NUMBER
      , WaitingSerialNum          NUMBER
      , WaitingOracleUsername     VARCHAR2(30)
      , WaitingOSUsername         VARCHAR2(30)
      , WaitingMachine            VARCHAR2(64)
      , WaitingSpid               VARCHAR2(12)
      , WaitingTerminal           VARCHAR2(30)
      , WaitingProgram            VARCHAR2(48)
      , WaitingLockTimeMinute     NUMBER
      , WaiterLockType            VARCHAR2(30)
      , WaiterModeRequest         VARCHAR2(30)
      , LockingInstanceName       VARCHAR2(16)
      , LockingStatus             VARCHAR2(8)
      , LockingSid                NUMBER
      , LockingSerialNum          NUMBER
      , LockingOracleUsername     VARCHAR2(30)
      , LockingOSUsername         VARCHAR2(30)
      , LockingMachine            VARCHAR2(64)
      , LockingSpid               VARCHAR2(12)
      , LockingTerminal           VARCHAR2(30)
      , LockingProgram            VARCHAR2(48)
      , LockingLockTimeMinute     NUMBER
      , SQLText                   VARCHAR2(1000));
    TYPE t_BlockingLockRecordTable IS TABLE OF t_BlockingLockRecord INDEX BY BINARY_INTEGER;
    v_BlockingLockArray             t_BlockingLockRecordTable;
    v_BlockingLockRec               cur_BlockingLocks%ROWTYPE;
    v_NumBlockingLocksIncidents     BINARY_INTEGER := 0;
BEGIN
    DBMS_OUTPUT.ENABLE(1000000);
    OPEN cur_BlockingLocks;
    LOOP
        FETCH cur_BlockingLocks INTO v_BlockingLockRec;
        EXIT WHEN cur_BlockingLocks%NOTFOUND;
        v_NumBlockingLocksIncidents := v_NumBlockingLocksIncidents + 1;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingInstanceName      := v_BlockingLockRec.waiting_instance;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingStatus            := v_BlockingLockRec.waiting_status;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingSid               := v_BlockingLockRec.waiting_sid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingSerialNum         := v_BlockingLockRec.waiting_serial_num;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingOracleUsername    := v_BlockingLockRec.waiting_oracle_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingOSUsername        := v_BlockingLockRec.waiting_os_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingMachine           := v_BlockingLockRec.waiting_machine;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingSpid              := v_BlockingLockRec.waiting_spid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingTerminal          := v_BlockingLockRec.waiting_terminal;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingProgram           := v_BlockingLockRec.waiting_program;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingLockTimeMinute    := v_BlockingLockRec.waiting_lock_time_min;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaiterLockType           := v_BlockingLockRec.waiter_lock_type;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaiterModeRequest        := v_BlockingLockRec.waiter_mode_request;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingInstanceName      := v_BlockingLockRec.locking_instance;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingStatus            := v_BlockingLockRec.locking_status;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingSid               := v_BlockingLockRec.locking_sid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingSerialNum         := v_BlockingLockRec.locking_serial_num;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingOracleUsername    := v_BlockingLockRec.locking_oracle_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingOSUsername        := v_BlockingLockRec.locking_os_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingMachine           := v_BlockingLockRec.locking_machine;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingSpid              := v_BlockingLockRec.locking_spid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingTerminal          := v_BlockingLockRec.locking_terminal;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingProgram           := v_BlockingLockRec.locking_program;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingLockTimeMinute    := v_BlockingLockRec.locking_lock_time_min;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).SQLText                  := v_BlockingLockRec.waiting_sql_text;
    END LOOP;
    CLOSE cur_BlockingLocks;
    DBMS_OUTPUT.PUT_LINE('Number of blocking lock incidents: ' || v_BlockingLockArray.COUNT);
    DBMS_OUTPUT.PUT(chr(10));
    FOR RowIndex IN 1 .. v_BlockingLockArray.COUNT
    LOOP
        DBMS_OUTPUT.PUT_LINE('Incident ' || RowIndex);
        DBMS_OUTPUT.PUT_LINE('---');
        DBMS_OUTPUT.PUT_LINE('                        WAITING                                  BLOCKING');
        DBMS_OUTPUT.PUT_LINE('                        ---------------------------------------- ----------------------------------------');
        DBMS_OUTPUT.PUT_LINE('Instance Name         : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingInstanceName, 41)   || v_BlockingLockArray(RowIndex).LockingInstanceName);
        DBMS_OUTPUT.PUT_LINE('Oracle SID            : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingSid, 41)            || v_BlockingLockArray(RowIndex).LockingSid);
        DBMS_OUTPUT.PUT_LINE('Serial#               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingSerialNum, 41)      || v_BlockingLockArray(RowIndex).LockingSerialNum);
        DBMS_OUTPUT.PUT_LINE('Oracle User           : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingOracleUsername, 41) || v_BlockingLockArray(RowIndex).LockingOracleUsername);
        DBMS_OUTPUT.PUT_LINE('O/S User              : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingOSUsername, 41)     || v_BlockingLockArray(RowIndex).LockingOSUsername);
        DBMS_OUTPUT.PUT_LINE('Machine               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingMachine, 41)        || v_BlockingLockArray(RowIndex).LockingMachine);
        DBMS_OUTPUT.PUT_LINE('O/S PID               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingSpid, 41)           || v_BlockingLockArray(RowIndex).LockingSpid);
        DBMS_OUTPUT.PUT_LINE('Terminal              : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingTerminal, 41)       || v_BlockingLockArray(RowIndex).LockingTerminal);
        DBMS_OUTPUT.PUT_LINE('Lock Time             : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingLockTimeMinute      || ' minutes', 41) || v_BlockingLockArray(RowIndex).LockingLockTimeMinute ||' minutes');
        DBMS_OUTPUT.PUT_LINE('Status                : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingStatus, 41)         || v_BlockingLockArray(RowIndex).LockingStatus);
        DBMS_OUTPUT.PUT_LINE('Program               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingProgram, 41)        || v_BlockingLockArray(RowIndex).LockingProgram);
        DBMS_OUTPUT.PUT_LINE('Waiter Lock Type      : ' || v_BlockingLockArray(RowIndex).WaiterLockType);
        DBMS_OUTPUT.PUT_LINE('Waiter Mode Request   : ' || v_BlockingLockArray(RowIndex).WaiterModeRequest);
        DBMS_OUTPUT.PUT_LINE('Waiting SQL           : ' || v_BlockingLockArray(RowIndex).SQLText);
        DBMS_OUTPUT.PUT(chr(10));
    END LOOP;
END;
/
quit;
EOF
}
#
#########################################################################################################
# LOCKED OBJECTS
#########################################################################################################
#
DBA_031() {
sqlplus -S / as sysdba <<EOF
SET ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 500 PAGESIZE 50000 TERMOUT ON TIMING OFF TRIMOUT ON TRIMSPOOL ON VERIFY OFF timing on
prompt ##############################################################
prompt # LOCKED OBJECTS
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
COLUMN instance_name                FORMAT a9           HEADING 'Instance'
COLUMN sid                          FORMAT 999999       HEADING 'SID'
COLUMN sid_serial                   FORMAT a20          HEADING 'SID / Serial#'
COLUMN session_status               FORMAT a9           HEADING 'Status'
COLUMN locking_oracle_user          FORMAT a20          HEADING 'Locking Oracle User'
COLUMN object_owner                 FORMAT a20          HEADING 'Object Owner'
COLUMN object_name                  FORMAT a30          HEADING 'Object Name'
COLUMN object_type                  FORMAT a25          HEADING 'Object Type'
COLUMN locked_mode                  FORMAT a35          HEADING 'Locked Mode'
CLEAR BREAKS
select i.instance_name                    instance_name
  , l.session_id || ' / ' || s.serial#    sid_serial
  , s.status                              session_status
  , l.oracle_username                     locking_oracle_user
  , o.owner                               object_owner
  , o.object_name                         object_name
  , o.object_type                         object_type
  , DECODE (   l.locked_mode
             , 0, 'None'                        /* Mon Lock equivalent */
             , 1, 'NoLock'                      /* N */
             , 2, 'Row-Share (SS)'              /* L */
             , 3, 'Row-Exclusive (SX)'          /* R */
             , 4, 'Share-Table'                 /* S */
             , 5, 'Share-Row-Exclusive (SSX)'   /* C */
             , 6, 'Exclusive'                   /* X */
             ,    '[Nothing]' )                 locked_mode
FROM dba_objects       o
  , gv\$session        s
  , gv\$locked_object  l
  , gv\$instance       i
WHERE i.inst_id     = l.inst_id
  AND s.inst_id     = l.inst_id
  AND s.sid         = l.session_id
  AND o.object_id   = l.object_id
ORDER BY i.instance_name, l.session_id;
quit;
EOF
}
#
#########################################################################################################
# BLOCKING LOCKS [ SUMARY ]
#########################################################################################################
#
DBA_032() {
sqlplus -S / as sysdba <<EOF
SET TERMOUT OFF TERMOUT ON ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 256 PAGESIZE 50000 TERMOUT ON TIMING ON TRIMOUT ON TRIMSPOOL ON VERIFY OFF timing on
prompt ##############################################################
prompt # BLOCKING LOCKS [ SUMARY ]
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
COLUMN waiting_instance_sid_serial  FORMAT a24          HEADING '[WAITING]|Instance - SID / Serial#'
COLUMN waiting_oracle_username      FORMAT a20          HEADING '[WAITING]|Oracle User'
COLUMN waiting_pid                  FORMAT a11          HEADING '[WAITING]|PID'
COLUMN waiting_machine              FORMAT a15          HEADING '[WAITING]|Machine'   TRUNC
COLUMN waiting_os_username          FORMAT a15          HEADING '[WAITING]|O/S User'
COLUMN waiter_lock_type_mode_req    FORMAT a35          HEADING 'Waiter Lock Type / Mode Requested'
COLUMN waiting_lock_time_min        FORMAT a10          HEADING '[WAITING]|Lock Time'
COLUMN waiting_instance_sid         FORMAT a15          HEADING '[WAITING]|Instance - SID'
COLUMN waiting_sql_text             FORMAT a105         HEADING '[WAITING]|SQL Text'    WRAP
COLUMN locking_instance_sid_serial  FORMAT a24          HEADING '[LOCKING]|Instance - SID / Serial#'
COLUMN locking_oracle_username      FORMAT a20          HEADING '[LOCKING]|Oracle User'
COLUMN locking_oracle_program       FORMAT a25          HEADING '[LOCKING]|Oracle Program'
COLUMN locking_pid                  FORMAT a11          HEADING '[LOCKING]|PID'
COLUMN locking_machine              FORMAT a15          HEADING '[LOCKING]|Machine'   TRUNC
COLUMN locking_os_username          FORMAT a15          HEADING '[LOCKING]|O/S User'
COLUMN locking_lock_time_min        FORMAT a10          HEADING '[LOCKING]|Lock Time'
COLUMN instance_name                FORMAT a8           HEADING 'Instance'
COLUMN sid                          FORMAT 999999       HEADING 'SID'
COLUMN session_status               FORMAT a9           HEADING 'Status'
COLUMN locking_oracle_user          FORMAT a20          HEADING 'Locking Oracle User'
COLUMN locking_os_user              FORMAT a20          HEADING 'Locking O/S User'
COLUMN locking_os_pid               FORMAT a11          HEADING 'Locking PID'
COLUMN locking_machine              FORMAT a15          HEADING 'Locking Machine'   TRUNC
COLUMN object_owner                 FORMAT a15          HEADING 'Object Owner'
COLUMN object_name                  FORMAT a25          HEADING 'Object Name'
COLUMN object_type                  FORMAT a15          HEADING 'Object Type'
COLUMN locked_mode                                      HEADING 'Locked Mode'
CLEAR BREAKS
select iw.instance_name || ' - ' || lw.sid || ' / ' || sw.serial#  waiting_instance_sid_serial
  , sw.username                                               waiting_oracle_username
  , ROUND(lw.ctime/60) || ' min.'                             waiting_lock_time_min
  , DECODE (   lh.type
             , 'CF', 'Control File'
             , 'DX', 'Distributed Transaction'
             , 'FS', 'File Set'
             , 'IR', 'Instance Recovery'
             , 'IS', 'Instance State'
             , 'IV', 'Libcache Invalidation'
             , 'LS', 'Log Start or Log Switch'
             , 'MR', 'Media Recovery'
             , 'RT', 'Redo Thread'
             , 'RW', 'Row Wait'
             , 'SQ', 'Sequence Number'
             , 'ST', 'Diskspace Transaction'
             , 'TE', 'Extend Table'
             , 'TT', 'Temp Table'
             , 'TX', 'Transaction'
             , 'TM', 'DML'
             , 'UL', 'PLSQL User_lock'
             , 'UN', 'User Name'
             , 'Nothing-' ) || ' / ' || DECODE ( lw.request
             , 0, 'None'                        /* Mon Lock equivalent */
             , 1, 'NoLock'                      /* N */
             , 2, 'Row-Share (SS)'              /* L */
             , 3, 'Row-Exclusive (SX)'          /* R */
             , 4, 'Share-Table'                 /* S */
             , 5, 'Share-Row-Exclusive (SSX)'   /* C */
             , 6, 'Exclusive'                   /* X */
             ,    '[Nothing]' )                                         waiter_lock_type_mode_req
  , ih.instance_name || ' - ' || lh.sid || ' / ' || sh.serial#          locking_instance_sid_serial
  , sh.username                                                         locking_oracle_username
  , sh.program                                                          locking_oracle_program
  , ROUND(lh.ctime/60) || ' min.'                                       locking_lock_time_min
FROM gv\$lock     lw
  , gv\$lock     lh
  , gv\$instance iw
  , gv\$instance ih
  , gv\$session  sw
  , gv\$session  sh
WHERE iw.inst_id  = lw.inst_id
  AND ih.inst_id  = lh.inst_id
  AND sw.inst_id  = lw.inst_id
  AND sh.inst_id  = lh.inst_id
  AND sw.sid      = lw.sid
  AND sh.sid      = lh.sid
  AND lh.id1      = lw.id1
  AND lh.id2      = lw.id2
  AND lh.request  = 0
  AND lw.lmode    = 0
  AND (lh.id1, lh.id2) IN (select id1, id2 FROM gv\$lock WHERE request = 0 INTERSECT select id1, id2 FROM gv\$lock WHERE lmode = 0)
ORDER BY iw.instance_name, lw.sid;
quit;
EOF
}
#
#########################################################################################################
# BLOCKING LOCKS [ USER DETAILS ]
#########################################################################################################
#
DBA_033() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # BLOCKING LOCKS [ USER DETAILS ]
prompt ##############################################################
col waiting_instance_sid_serial for a30
col waiting_oracle_username for a15
col waiting_os_username for a15
col waiting_machine for a40
col waiting_pid for a10
col locking_instance_sid_serial for a30
col locking_oracle_username for a25
col locking_os_username for a20
col locking_machine for a20
col loocking_program for a20
col locking_pid for a10
select iw.instance_name || ' - ' || lw.sid || ' / ' || sw.serial#  waiting_instance_sid_serial
  , sw.username                                                    waiting_oracle_username
  , sw.osuser                                                      waiting_os_username
  , sw.machine                                                     waiting_machine
  , pw.spid                                                        waiting_pid
  , ih.instance_name || ' - ' || lh.sid || ' / ' || sh.serial#     locking_instance_sid_serial
  , sh.username                                                    locking_oracle_username
  , sh.osuser                                                      locking_os_username
  , sh.machine                                                     locking_machine
  , sh.program                                                     loocking_program
  , ph.spid                                                        locking_pid
FROM gv\$lock    lw
  , gv\$lock     lh
  , gv\$instance iw
  , gv\$instance ih
  , gv\$session  sw
  , gv\$session  sh
  , gv\$process  pw
  , gv\$process  ph
WHERE iw.inst_id  = lw.inst_id
  AND ih.inst_id  = lh.inst_id
  AND sw.inst_id  = lw.inst_id
  AND sh.inst_id  = lh.inst_id
  AND pw.inst_id  = lw.inst_id
  AND ph.inst_id  = lh.inst_id
  AND sw.sid      = lw.sid
  AND sh.sid      = lh.sid
  AND lh.id1      = lw.id1
  AND lh.id2      = lw.id2
  AND lh.request  = 0
  AND lw.lmode    = 0
  AND (lh.id1, lh.id2) IN (select id1, id2 FROM gv\$lock WHERE request = 0 INTERSECT select id1,id2 FROM gv\$lock WHERE lmode = 0)
  AND sw.paddr  = pw.addr (+)
  AND sh.paddr  = ph.addr (+)
ORDER BY iw.instance_name, lw.sid;
quit;
EOF
}
#
#########################################################################################################
# BLOCKING LOCKS [ WAITING SQL ]
#########################################################################################################
#
DBA_034() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # BLOCKING LOCKS [ WAITING SQL ]
prompt ##############################################################
select iw.instance_name || ' - ' || lw.sid || ' / ' || sw.serial#  waiting_instance_sid_serial
  , aw.sql_text                                                    waiting_sql_text
FROM gv\$lock     lw
  , gv\$lock     lh
  , gv\$instance iw
  , gv\$instance ih
  , gv\$session  sw
  , gv\$session  sh
  , gv\$sqlarea  aw
WHERE iw.inst_id  = lw.inst_id
  AND ih.inst_id  = lh.inst_id
  AND sw.inst_id  = lw.inst_id
  AND sh.inst_id  = lh.inst_id
  AND aw.inst_id  = lw.inst_id
  AND sw.sid      = lw.sid
  AND sh.sid      = lh.sid
  AND lh.id1      = lw.id1
  AND lh.id2      = lw.id2
  AND lh.request  = 0
  AND lw.lmode    = 0
  AND (lh.id1, lh.id2) IN (select id1, id2 FROM gv\$lock WHERE request = 0 INTERSECT select id1, id2 FROM gv\$lock WHERE lmode = 0)
  AND sw.sql_address  = aw.address
ORDER BY iw.instance_name, lw.sid;
quit;
EOF
}
#
#########################################################################################################
# LOCKED OBJECTS [ DETAILS ]
#########################################################################################################
#
DBA_035() {
sqlplus -S / as sysdba <<EOF
set pages 1000 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # LOCKED OBJECTS [ DETAILS ]
prompt ##############################################################
col INSTANCE for a10
col status for a10
col OBJECT_NAME for a30
col MACHINE for a30
col oracle_user for a15
col OS_USER for a15
col PROGRAM for a25
col USER for a10
col OWNER for a15
col OS_PID for a8
col LOCKED_MODE for a20
col OBJECT_TYPE for a15
col OBJECT_OWNER for a15
col LOCKING_OS_PID for a8
col LOCKING_OS_USER for a20
select i.instance_name        instance
  , l.session_id              sid
  , s.status                  status
  , l.oracle_username         oracle_user
  , o.owner                   owner
  , s.osuser                  os_user
  , s.machine                 machine
  , p.spid                    os_pid
  , o.object_name             object_name
  , o.object_type             object_type
  , s.program                 program
  , DECODE (   l.locked_mode
             , 0, 'None'                        /* Mon Lock equivalent */
             , 1, 'NoLock'                      /* N */
             , 2, 'Row-Share (SS)'              /* L */
             , 3, 'Row-Exclusive (SX)'          /* R */
             , 4, 'Share-Table'                 /* S */
             , 5, 'Share-Row-Exclusive (SSX)'   /* C */
             , 6, 'Exclusive'                   /* X */
             ,    '[Nothing]')                  locked_mode
FROM dba_objects       o
  , gv\$session        s
  , gv\$process        p
  , gv\$locked_object  l
  , gv\$instance       i
WHERE i.inst_id     = l.inst_id
  AND s.inst_id     = l.inst_id
  AND s.inst_id     = p.inst_id
  AND s.sid         = l.session_id
  AND o.object_id   = l.object_id
  AND s.paddr       = p.addr
ORDER BY i.instance_name, l.session_id;
quit;
EOF
}
#
#########################################################################################################
# DML AND DDL LOCKS
#########################################################################################################
#
DBA_036() {
sqlplus -S / as sysdba <<EOF
SET TERMOUT OFF TERMOUT ON ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 256 PAGESIZE 50000 TERMOUT ON TRIMOUT ON TRIMSPOOL ON VERIFY OFF timing on colsep '|'
prompt ##############################################################
prompt # DML AND DDL LOCKS
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
COLUMN instance_name         FORMAT a10       HEADING 'Instance'
COLUMN sid_serial            FORMAT a15       HEADING 'SID / Serial#'
COLUMN session_status        FORMAT a9        HEADING 'Status'
COLUMN locking_oracle_user   FORMAT a20       HEADING 'Locking Oracle User'
COLUMN lock_type             FORMAT a9        HEADING 'Lock Type'
COLUMN mode_held             FORMAT a10       HEADING 'Mode Held'
COLUMN object                FORMAT a42       HEADING 'Object'
COLUMN program               FORMAT a20       HEADING 'Program'
COLUMN wait_time_sec         FORMAT 999,999   HEADING 'Wait Time (sec)'
COLUMN wait_time_min         FORMAT 999,999   HEADING 'Wait Time (min)'
COLUMN wait_time_hour        FORMAT 999,999   HEADING 'Wait Time (hour)'
CLEAR BREAKS
select i.instance_name                   instance_name
  , l.session_id || ' / ' || s.serial#   sid_serial
  , s.status                             session_status
  , s.username                           locking_oracle_user
  , l.lock_type                          lock_type
  , l.mode_held                          mode_held
  , o.owner || '.' || o.object_name      object
  , SUBSTR(s.program, 0, 20)             program
  , ROUND(w.seconds_in_wait, 2)          wait_time_sec
  , ROUND(w.seconds_in_wait/60, 2)       wait_time_min
  , ROUND(w.seconds_in_wait/60/60, 2)       wait_time_hour
FROM v\$instance      i
   , v\$session       s
   , dba_locks        l
   , dba_objects      o
   , v\$session_wait  w
WHERE s.sid = l.session_id
AND l.lock_type IN ('DML','DDL')
AND l.lock_id1 = o.object_id
AND l.session_id = w.sid
ORDER BY i.instance_name, l.session_id;
quit;
EOF
}
#
#########################################################################################################
# DML TABLE LOCKS TIME
#########################################################################################################
#
DBA_037() {
sqlplus -S / as sysdba <<EOF
SET TERMOUT ON TERMOUT ON ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 256 PAGESIZE 50000 TERMOUT ON TIMING ON TRIMOUT ON TRIMSPOOL ON VERIFY OFF timing on colsep '|'
prompt ##############################################################
prompt # DML TABLE LOCKS TIME
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
COLUMN instance_name                FORMAT a10          HEADING 'Instance'
COLUMN locking_oracle_user          FORMAT a20          HEADING 'Locking Oracle User'
COLUMN sid_serial                   FORMAT a15          HEADING 'SID / Serial#'
COLUMN mode_held                    FORMAT a15          HEADING 'Mode Held'
COLUMN mode_requested               FORMAT a15          HEADING 'Mode Requested'
COLUMN lock_type                    FORMAT a15          HEADING 'Lock Type'
COLUMN object                       FORMAT a42          HEADING 'Object'
COLUMN program                      FORMAT a20          HEADING 'Program'
COLUMN lock_time_min                FORMAT 999,999      HEADING 'Lock Time (min)'
COLUMN lock_time_hours              FORMAT 999,999      HEADING 'Lock Time (hours)'
COLUMN lock_time_days               FORMAT 999,999      HEADING 'Lock Time (days)'
CLEAR BREAKS
select i.instance_name instance_name
  , l.sid || ' / ' || s.serial# sid_serial
  , s.username locking_oracle_user
  , DECODE(   l.lmode
            , 1, NULL
            , 2, 'Row Share'
            , 3, 'Row Exclusive'
            , 4, 'Share'
            , 5, 'Share Row Exclusive'
            , 6, 'Exclusive'
            ,    'None') mode_held
  , DECODE(   l.request
            , 1, NULL
            , 2, 'Row Share'
            , 3, 'Row Exclusive'
            , 4, 'Share'
            , 5, 'Share Row Exclusive'
            , 6, 'Exclusive'
            ,    'None') mode_requested
  , DECODE (   l.type
             , 'CF', 'Control File'
             , 'DX', 'Distributed Transaction'
             , 'FS', 'File Set'
             , 'IR', 'Instance Recovery'
             , 'IS', 'Instance State'
             , 'IV', 'Libcache Invalidation'
             , 'LS', 'Log Start or Log Switch'
             , 'MR', 'Media Recovery'
             , 'RT', 'Redo Thread'
             , 'RW', 'Row Wait'
             , 'SQ', 'Sequence Number'
             , 'ST', 'Diskspace Transaction'
             , 'TE', 'Extend Table'
             , 'TT', 'Temp Table'
             , 'TX', 'Transaction'
             , 'TM', 'DML'
             , 'UL', 'PLSQL User_lock'
             , 'UN', 'User Name'
             ,       'Nothing'
           ) lock_type
  , o.owner || '.' || o.object_name object
  , ROUND(l.ctime/60, 2) lock_time_min
  , ROUND(l.ctime/60/60, 2) lock_time_hours
  , ROUND(l.ctime/60/60/24, 2) lock_time_days
FROM v\$instance    i
   , v\$session     s
   , v\$lock        l
   , dba_objects    o
   , dba_tables     t
WHERE l.id1            =  o.object_id
  AND s.sid            =  l.sid
  AND o.owner          =  t.owner
  AND o.object_name    =  t.table_name
  AND o.owner          <> 'SYS'
  AND l.type           =  'TM'
ORDER BY i.instance_name, l.sid;
quit;
EOF
}
#
#########################################################################################################
# VERIFY SESSIONS [ @ ]
#########################################################################################################
#
DBA_038() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY SESSIONS [ @ ]
prompt ##############################################################
col MACHINE for a45
col OSUSER for a25
col EVENT for a30
col PROGRAM for a60
col username for a20
select MACHINE
  , OSUSER
  , USERNAME
  , SID
  , SERIAL#
  , event
  , PROGRAM
from v\$session
where osuser not in ('GRID','grid','ORACLE','oracle')
order by 1,2,5,6;
quit;
EOF
}
#
#########################################################################################################
# TOP 20 DATABASE SESSIONS
#########################################################################################################
#
DBA_039() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # TOP 20 DATABASE SESSIONS
prompt ##############################################################
col rank form 99
col sql_id for a15
col MACHINE for a30
col event for a30
-- col CPUMins for a10
-- col CPUHours for a10
col username for a20
col OSUSER for a20
col PROGRAM for a30
select rownum as rank
  , a.sid
  , a.serial#
  , a.sql_id
  , a.username
  , a.osuser
  , a.machine
  , a.program
--, a.event
  , a.CPUMins
  , a.CPUHours
  , a.CPUDays
from (select v.sid
        , serial#
        , sql_id
        , username
        , osuser
        , machine
        , program
    --  , event
        , round(v.value/(100*60), 0) CPUMins
        , round(v.value/60/60)/100 CPUHours
        , round(v.value/60/60/24)/100 CPUDays
      FROM gv\$statname s, gv\$sesstat v, gv\$session sess
      WHERE s.name = 'CPU used by this session'
      and sess.sid = v.sid
      and v.statistic# = s.statistic#
      and v.value > 0
      ORDER BY v.value DESC) a
where rownum < 21
and osuser not in ('GRID','grid','ORACLE','oracle');
quit;
EOF
}
#
#########################################################################################################
# VERIFY TABLESPACES
#########################################################################################################
#
DBA_040() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # Tablespaces                                                #
prompt ##############################################################
col "USAGE (%)"          for a9
col "FREE (%)"           for a9
col Tablespace           for a20
col "Type"               for a12
col "USED USAGE"         for a12
col "FREE USAGE"         for a12
col "USED SIZE(MB)"      for a12
col "USED SIZE(GB)"      for a12
col "USED SIZE(TB)"      for a12
col "FREE SIZE(MB)"      for a12
col "FREE SIZE(GB)"      for a12
col "FREE SIZE(TB)"      for a12
col "MAX SIZE"           for a12
col "Status"             for a7
col "Status Size"        for a13
column "USED SIZE(MB)"   format 9g999g999g990 heading  'USED SIZE(MB)'
column "USED SIZE(GB)"   format 9g999g999g990 heading  'USED SIZE(GB)'
column "USED SIZE(TB)"   format 9g999g999g990 heading  'USED SIZE(TB)'
column "FREE SIZE(MB)"   format 9g999g999g990 heading  'FREE SIZE(MB)'
column "FREE SIZE(GB)"   format 9g999g999g990 heading  'FREE SIZE(GB)'
column "FREE SIZE(TB)"   format 9g999g999g990 heading  'FREE SIZE(TB)'
column "TOTAL SIZE(MB)"  format 9g999g999g990 heading  'TOTAL SIZE(MB)'
column "TOTAL SIZE(GB)"  format 9g999g999g990 heading  'TOTAL SIZE(GB)'
column "TOTAL SIZE(TB)"  format 9g999g999g990 heading  'TOTAL SIZE(TB)'
column "MAX SIZE(GB)"    format 9g999g999g990 heading  'MAX SIZE(GB)'
break on report
compute sum of "USED SIZE(MB)"   on report
compute sum of "USED SIZE(GB)"   on report
compute sum of "USED SIZE(TB)"   on report
compute sum of "FREE SIZE(MB)"   on report
compute sum of "FREE SIZE(GB)"   on report
compute sum of "FREE SIZE(TB)"   on report
compute sum of "TOTAL SIZE(MB)"  on report
compute sum of "TOTAL SIZE(GB)"  on report
compute sum of "TOTAL SIZE(TB)"  on report
compute sum of "MAX SIZE(GB)"    on report
select substr(A.tablespace_name,1,20) "Tablespace"
   , MAX(A.contents) "Type"
   , MAX(A.status) "Status"
-- , MAX(A.max_extents) "Max extents"
-- , MAX(A.pct_increase) "Pct_increase"
   , (SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024)-(ROUND(SUM(C.BYTES)/1024/1024/COUNT(DISTINCT B.FILE_ID))) "USED SIZE(MB)"
   , ROUND(SUM(C.BYTES)/1024/1024/COUNT(DISTINCT B.FILE_ID)) "FREE SIZE(MB)"
   , SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024 "TOTAL SIZE(MB)"
   , (SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024)-(ROUND(SUM(C.BYTES)/1024/1024/1024/COUNT(DISTINCT B.FILE_ID))) "USED SIZE(GB)"
   , ROUND(SUM(C.BYTES)/1024/1024/1024/COUNT(DISTINCT B.FILE_ID)) "FREE SIZE(GB)"
   , SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024 "TOTAL SIZE(GB)"
-- , (SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024/1024)-(ROUND(SUM(C.BYTES)/1024/1024/1024/1024/COUNT(DISTINCT B.FILE_ID))) "USED SIZE(TB)"
   , ROUND(SUM(C.BYTES)/1024/1024/1024/1024/COUNT(DISTINCT B.FILE_ID)) "FREE SIZE(TB)"
   , SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024/2014 "TOTAL SIZE(TB)"
-- , (SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID))-(SUM(C.BLOCKS)/COUNT(DISTINCT B.FILE_ID)) "USED BLOCKS"
-- , SUM(C.BLOCKS)/COUNT(DISTINCT B.FILE_ID) "FREE BLOCKS"
   , TO_CHAR(100-(SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID),'999.99') || '%' "USAGE (%)"
   , TO_CHAR((SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID),'999.99') || '%' "FREE (%)"
-- , SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID) "TOTAL BLOCKS"
   , SUM(B.MAXBYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024 "MAX SIZE(GB)"
   , case
       when TO_CHAR(100-(SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID)) < 80 then 'Size OK'
       when TO_CHAR(100-(SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID)) < 90 then 'Warning'
       else 'Critical' end as "Status Size"
from dba_tablespaces A, DBA_DATA_FILES B, DBA_FREE_SPACE C
WHERE A.TABLESPACE_NAME=B.TABLESPACE_NAME
AND A.TABLESPACE_NAME=C.TABLESPACE_NAME
GROUP BY A.TABLESPACE_NAME
order by 1;
prompt
prompt ##############################################################
prompt # Datafiles                                                  #
prompt ##############################################################
TTITLE OFF
BTITLE OFF
SET FEEDBACK ON
column "Size (M)" format 9g999g999g990     heading 'Size (M)'
column "Size (G)" format 9g999g999g990     heading 'Size (G)'
column "Used (M)" format 9g999g999g990     heading 'Used (M)'
column "Used (G)" format 9g999g999g990     heading 'Used (G)'
column "Free (M)" format 9g999g999g990     heading 'Free (M)'
column "Free (G)" format 9g999g999g990     heading 'Free (G)'
column "MAX (G)"  format 9g999g999g990     heading 'MAX (G)'
col "FILE NAME"          for a80
col "AUTOEXTENSIBLE"     for a15
col "Status"             for a10
col "Tablespace Name"    for a20
col "Used (%)"           for a11
-- col "Size (M)"        for a11
-- col "Size (g)"        for a11
-- col "Used (M)"        for a15
-- col "Used (G)"        for a15
-- col "Free (M)"        for a15
-- col "Free (G)"        for a15
-- col "Max (G)"         for a15
select Substr(df.tablespace_name,1,20)           "Tablespace Name"
  , Substr(df.file_name, 1, 80)                  "File Name"
--  , AUTOEXTENSIBLE as                          "AUTOEXTENSIBLE"
  , status as                                    "Status"
  , round(df.bytes/1024/1024, 2)                 "Size (M)"
  , round(e.used_bytes/1024/1024, 2)             "Used (M)"
  , round(f.free_bytes/1024/1024, 2)             "Free (M)"
--  , case when round(df.bytes/1024/1024, 2) = round(e.used_bytes/1024/1024, 2) then 'Full/100%' else to_char(round(f.free_bytes/1024/1024, 2)) end as "Free (M)"
  , round(df.bytes/1024/1024/1024, 2)            "Size (G)"
  , round(e.used_bytes/1024/1024/1024, 2)        "Used (G)"
  , round(f.free_bytes/1024/1024/1024, 2)        "Free (G)"
--  , case when Round(df.bytes/1024/1024/1024, 2) = Round(e.used_bytes/1024/1024/1024, 2) then 'Full/100%' else to_char(Round(f.free_bytes/1024/1024/1024, 2)) end as "Free (G)"
  , df.maxbytes/1024/1024/1024 as                "Max (G)"
  , rpad(' '|| Rpad ('X',Round(e.used_bytes*10/df.bytes,0), 'X'),11,'-') "Used (%)"
FROM DBA_DATA_FILES df,
   (select file_id, Sum(Decode(bytes,NULL,0,bytes)) used_bytes FROM dba_extents GROUP by file_id) E,
   (select Max(bytes) free_bytes, file_id FROM dba_free_space GROUP BY file_id) f
WHERE e.file_id (+) = df.file_id
AND df.file_id = f.file_id (+)
ORDER BY df.tablespace_name, df.file_name;
prompt
prompt ##############################################################
prompt # TempFiles                                                  #
prompt ##############################################################
column "Size (M)" format 9g999g999 heading 'Size (M)'
column "Used (M)" format 9g999g999 heading 'Used (M)'
column "Free (M)" format 9g999g999 heading 'Free (M)'
column "Size (G)" format 9g999g999 heading 'Size (G)'
column "Used (G)" format 9g999g999 heading 'Used (G)'
column "Free (G)" format 9g999g999 heading 'Free (G)'
column "MAX (G)"  format 9g999g999 heading 'MAX (G)'
col "FILE NAME"          for a80
col "AUTOEXTENSIBLE"     for a15
col "Status"             for a10
col "Tablespace Name"    for a20
col "Used (%)"           for a11
col "Free (M)"           for a9
col "Free (G)"           for a9
-- col "Max (G)"         for a15
select substr(df.tablespace_name,1,20) as    "Tablespace Name"
  , substr(df.file_name, 1, 80) as           "File Name"
  , AUTOEXTENSIBLE as                        "AUTOEXTENSIBLE"
  , status as                                "Status"
  , round(df.bytes/1024/1024, 2) as          "Size (M)"
  , round(e.used_bytes/1024/1024, 2) as      "Used (M)"
  , case when Round(df.bytes/1024/1024, 2) = Round(e.used_bytes/1024/1024, 2) then 'Full/100%' else to_char(Round(f.free_bytes/1024/1024, 2)) end as "Free (M)"
  , round(df.bytes/1024/1024/1024, 2) as     "Size (G)"
  , round(e.used_bytes/1024/1024/1024, 2) as "Used (G)"
  , case when Round(df.bytes/1024/1024/1024, 2) = Round(e.used_bytes/1024/1024/1024, 2) then 'Full/100%' else to_char(Round(f.free_bytes/1024/1024/1024, 2)) end as "Free (G)"
  , df.maxbytes/1024/1024/1024 as            "Max (G)"
  , rpad(' '|| Rpad ('X',Round(e.used_bytes*10/df.bytes,0), 'X'),11,'-') as "Used (%)"
FROM DBA_TEMP_FILES df,
   (select file_id, sum(Decode(bytes,NULL,0,bytes)) used_bytes FROM dba_extents GROUP by file_id) E,
   (select max(bytes) free_bytes, file_id FROM dba_free_space GROUP BY file_id) f
WHERE e.file_id (+) = df.file_id
AND df.file_id  = f.file_id (+)
ORDER BY df.tablespace_name, df.file_name;
quit;
EOF
}
#
#########################################################################################################
# VERIFY STATISTICS - TABLES [ @ ]
#########################################################################################################
#
DBA_041() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY STATISTICS - TABLES [ @ ]
prompt ##############################################################
col schema for a20
col object for a50
select S.Owner as                                        "Schema"
  , S.Table_Name as                                      "Object"
  , S.Object_Type as                                     "Object Type"
  , S.Num_Rows as                                        "Qtd. of Lines"
  , To_Char(S.Last_Analyzed, 'dd/mm/yyyy HH24:mm:ss') as "Last Analyzed"
  , case when S.Last_Analyzed > sysdate - 7
    then 'Status OK' when S.Last_Analyzed > sysdate - 30 then 'Warning' else 'Critical' end as "Status of Statistics"
FROM sys.dba_tab_statistics S
ORDER BY S.Owner, S.Table_Name, S.Num_Rows, S.Last_Analyzed;
prompt
prompt ##############################################################
prompt # Quantity of Objects with Status OK - (Collected on the lasts 7 days)
prompt ##############################################################
col owner for a30
select a.owner, count(*)
from sys.dba_tab_statistics a
where a.last_analyzed > sysdate - 7
group by a.owner
order by a.owner;
prompt
prompt ##############################################################
prompt # Quantity of Objects with Warning - (Collected between 7 and 30 days)
prompt ##############################################################
col owner for a30
select a.owner, count(*)
from sys.dba_tab_statistics a
where a.last_analyzed < sysdate - 7
and a.last_analyzed < sysdate - 30
group by a.owner
order by a.owner;
prompt
prompt ##############################################################
prompt # Quantity of Objects with Critical - (Collected more them 30 days)
prompt ##############################################################
col owner for a30
select a.owner, count(*)
from sys.dba_tab_statistics a
where a.last_analyzed > sysdate - 30
and a.last_analyzed < sysdate - 90
group by a.owner
order by a.owner;
quit;
EOF
}
#
#########################################################################################################
# VERIFY STATISTICS - INDEXES [ @ ]
#########################################################################################################
#
DBA_042() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY STATISTICS - INDEXES [ @ ]
prompt ##############################################################
col schema for a20
col object for a50
select S.Owner as                                        "Schema"
  , S.Table_Name as                                      "Object"
  , S.Object_Type as                                     "Object Type"
  , S.Num_Rows as                                        "Qtd. of Lines"
  , To_Char(S.Last_Analyzed, 'dd/mm/yyyy HH24:mm:ss') as "Last Analyzed"
  , case when S.Last_Analyzed > sysdate - 7 then 'Status OK' when S.Last_Analyzed > sysdate -30 then 'Warning' else 'Critical' end as "Status of Statistics"
FROM sys.dba_ind_statistics S
ORDER BY S.Owner, S.Table_Name, S.Num_Rows, S.Last_Analyzed;
prompt ##############################################################
prompt # Quantity of Objects with Status OK - (Collected on the lasts 7 days)
prompt ##############################################################
prompt
col owner for a30
select a.owner, count(*)
from sys.dba_ind_statistics a
where a.last_analyzed > sysdate - 7
group by a.owner
order by a.owner;
prompt ##############################################################
prompt # Quantity of Objects with Warning - (Collected between 7 and 30 days)
prompt ##############################################################
prompt
col owner for a30
select a.owner, count(*)
from sys.dba_ind_statistics a
where a.last_analyzed < sysdate - 7
group by a.owner
order by a.owner;
prompt ##############################################################
prompt # Quantity of Objects with Critical - (Collected more them 30 days)
prompt ##############################################################
prompt
col owner for a30
select a.owner, count(*)
from sys.dba_ind_statistics a
where a.last_analyzed > sysdate - 30
group by a.owner
order by a.owner;
quit;
EOF
}
#
#########################################################################################################
# CAPTURE STATISTICS - OWNER [ @ ]
#########################################################################################################
#
DBA_043() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # CAPTURE STATISTICS - OWNER [ @ ]
prompt ##############################################################
col username for a30
col account_status for a25
col profile for a25
col default_tablespace for a25
col temporary_tablespace for a25
select username
   , account_status
   , profile
   , default_tablespace
   , temporary_tablespace
from dba_users
order by 1;
quit;
EOF
# DBA_043B $1
}
#
#########################################################################################################
# CAPTURE STATISTICS - OWNER [ @ ]
#########################################################################################################
#
DBA_043B() {
local OPT=$1
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
begin
  dbms_stats.gather_schema_stats('${OPT}', estimate_percent => dbms_stats.auto_sample_size, cascade => true);
end;
/
quit;
EOF
}
#
#########################################################################################################
# DBA: VALIDATE OBJECTS FROM ONE OWNER [ @ ]
#########################################################################################################
#
DBA_044() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VALIDATE OBJECTS FROM ONE OWNER [ @ ]
prompt ##############################################################
col username for a30
col account_status for a25
col profile for a25
col default_tablespace for a25
col temporary_tablespace for a25
select username
   , account_status
   , profile
   , default_tablespace
   , temporary_tablespace
from dba_users
order by 1;
quit;
EOF
# DBA_044B $1
}
#
#########################################################################################################
# VALIDATE OBJECTS FROM ONE OWNER [ @ ]
#########################################################################################################
#
DBA_044B() {
sqlplus -S / as sysdba <<EOF
local OPT=$1
set pages 700 lines 1000 timing on numwidth 20 SERVEROUTPUT ON FEEDBACK OFF colsep '|'
begin
  dbms_utility.compile_schema('${OPT}',false);
end;
/
quit;
EOF
}
#
#########################################################################################################
# VERIFY TABLES SIZE, VALIDATE OBJ - OWNERS [ @ ]
#########################################################################################################
#
DBA_045() {
sqlplus -S / as sysdba <<EOF
set pages 5000 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY TABLES SIZE, VALIDATE OBJ - OWNERS [ @ ]
prompt ##############################################################
col "OWNER" for a25
col "Table Name" for a35
col "Table Space" for a25
col "Last Analyzed" for a30
col "Status of Statistics" for a20
select t.owner as                                        "OWNER"
  , t.table_name as                                      "Table Name"
  , t.TABLESPACE_NAME as                                 "Table Space"
  , t.num_rows as                                        "Rows"
  , t.avg_row_len as                                     "Avg Row Len"
  , trunc((t.blocks * p.value)/1024/1024) as             "Size MB" -- numero de blocos X o seu tamanho em KBs
  , to_Char(t.Last_Analyzed, 'DD/MM/YYYY HH24:mm:ss') as "Last Analyzed"
  , case when t.Last_Analyzed > sysdate - 7 then 'Status OK' when t.Last_Analyzed > sysdate - 30 then 'Warning' else 'Critical' end as "Status of Statistics"
FROM dba_tables t, v\$parameter p
WHERE p.name = 'DBA_block_size'
ORDER BY 1,2;
quit;
EOF
}
#
#########################################################################################################
# OWNER X OBJECTS X TYPE X QTD
#########################################################################################################
#
DBA_046() {
sqlplus -S / as sysdba <<EOF
set pages 2000 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # OWNER X OBJECTS X TYPE X QTD
prompt ##############################################################
col owner for a30
col object_type for a20
Clear Breaks
Break on owner Skip 1
Compute Sum LABEL 'TOTAL' Of Qtde On owner
select owner
  , object_type
  , count(*) Qtde 
from dba_objects 
where owner not in ('SYS','SYSTEM','SYSMAN','DBSNMP') 
group by owner, object_type
union
select owner
  , 'CONSTRAINT ' || constraint_type
  , count(*) 
from dba_constraints 
where owner not in ('SYS','SYSTEM','SYSMAN','DBSNMP') 
group by owner, 'CONSTRAINT ' || constraint_type;
prompt
prompt ##############################################################
prompt # SHOW SIZE BY OWNER
prompt ##############################################################
col owner for a30
SELECT * 
FROM (SELECT OWNER
        , SUM(BYTES)/1048576 MB
      from DBA_SEGMENTS 
      GROUP BY OWNER ORDER BY MB DESC) 
WHERE ROWNUM < 20;
quit;
EOF
}
#
#########################################################################################################
# VERIFY INSTANCE CHARACTERSET
#########################################################################################################
#
DBA_047() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY INSTANCE CHARACTERSET
prompt ##############################################################
col parameter for a50
col value for a50
select * from nls_database_parameters;
quit;
EOF
}
#
#########################################################################################################
# CACHE HIT RATIO [ GOOD: > 90% ]
#########################################################################################################
#
DBA_048() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # CACHE HIT RATIO [ GOOD: > 90% ]
prompt ##############################################################
select sum(gets) "Data Dict Gets"
   , sum(getmisses) "Data Dict Cache Misses"
   , round((1-(sum(getmisses)/sum(gets)))*100) "DATA DICT CACHE HIT RATIO"
   , round(sum(getmisses)*100/sum(gets)) "% MISSED"
   , case when round((1-(sum(getmisses)/sum(gets)))*100) < 90 then 'Critical' else 'Status OK' end as status
from v\$rowcache;
quit;
EOF
}
#
#########################################################################################################
# VERIFY INSTANCE INSTALLED PRODUCTS
#########################################################################################################
#
DBA_049() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY INSTANCE INSTALLED PRODUCTS
prompt ##############################################################
col version_full for a15
col status for a10
col schema for a12
col comp_name for a40
select comp_name
  , version_full
--  , status
  , modified
--  , to_char(modified, 'DD/MM/YYYY HH24:MM:SS') as modified
  , schema
  , status
FROM dba_registry
order by 1, 2, 3;
quit;
EOF
}
#
#########################################################################################################
# INSTANCE PROPERTIES
#########################################################################################################
#
DBA_050() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # INSTANCE PROPERTIES
prompt ##############################################################
COLUMN PROPERTY_NAME FORMAT A70
COLUMN PROPERTY_VALUE FORMAT A70
select PROPERTY_NAME
  , PROPERTY_VALUE
FROM database_properties
ORDER BY PROPERTY_NAME;
quit;
EOF
}
#
#########################################################################################################
# INSTANCE OPTIONS
#########################################################################################################
#
DBA_051() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # INSTANCE OPTIONS
prompt ##############################################################
col value for A10
col parameter for A50
select * FROM v\$option
ORDER BY parameter;
quit;
EOF
}
#
#########################################################################################################
# INSTANCE DIFFERENTS PARAMETERS
#########################################################################################################
#
DBA_052() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # INSTANCE DIFFERENTS PARAMETERS
prompt ##############################################################
COLUMN name          FORMAT A30
COLUMN current_value FORMAT A110
COLUMN sid           FORMAT A10
COLUMN spfile_value  FORMAT A70
select p.name
  , i.instance_name as sid
  , upper(p.value) as current_value
  , sp.sid
  , upper(sp.value) as spfile_value
FROM v\$spparameter sp
  , v\$parameter p
  , v\$instance i
WHERE sp.name = p.name
AND upper(sp.value) != upper(p.value);
quit;
EOF
}
#
# select name, VALUE, ISSYS_MODIFIABLE from SYS.V\$PARAMETER
#
#########################################################################################################
# INSTANCE MODIFICABLES PARAMETERS
#########################################################################################################
#
DBA_053() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # INSTANCE MODIFICABLES PARAMETERS
prompt ##############################################################
COLUMN name  FORMAT A50
COLUMN value FORMAT A110
select p.name
  , p.type
  , p.value
  , p.isses_modifiable
  , p.issys_modifiable
  , p.isinstance_modifiable
FROM v\$parameter p
ORDER BY p.name;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DEAD LOCKS
#########################################################################################################
#
DBA_054() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # WHICH SESSION IS BLOCKING OTHER SESSION                    #
prompt ##############################################################
select (select username FROM gv\$session WHERE sid=a.sid) blocker
  , a.sid
  , ' is blocking ' as BLOCKING
  , (select username FROM gv\$session WHERE sid=b.sid) blockee
  , b.sid
FROM gv\$lock a, gv\$lock b
WHERE a.block = 1
AND b.request > 0
AND a.id1 = b.id1
AND a.id2 = b.id2;
prompt
prompt ##############################################################
prompt # VERIFY DEAD LOCKS
prompt ##############################################################
col username form A15
col sid form 9999999
col type form A4
col lmode form 9999999
col request form 9999999
col id1 form 9999990
col id2 form 9999990
col lmode for a20
col request for a20
break on id1 skip 1 dup
select sn.username
  , m.sid
  , m.type
  , DECODE(m.lmode, 0, 'None', 1, 'Null', 2, 'Row Share', 3, 'Row Excl.', 4, 'Share', 6, 'Exclusive', 5, 'S/Row Excl.', lmode, ltrim(to_char(lmode,'990'))) lmode
  , DECODE(m.request, 0, 'None', 1, 'Null', 2, 'Row Share', 3, 'Row Excl.', 4, 'Share', 5, 'S/Row Excl.', 6, 'Exclusive', request, ltrim(to_char(request,'990'))) request
  , m.id1
  , m.id2
FROM gv\$session sn, gv\$lock m
WHERE (sn.sid = m.sid AND m.request != 0) OR (sn.sid = m.sid AND m.request = 0 AND lmode != 4 AND (id1, id2)
IN (select s.id1, s.id2 FROM gv\$lock s WHERE request != 0 AND s.id1 = m.id1 AND s.id2 = m.id2))
ORDER BY id1,id2, m.request;
clear breaks
quit;
EOF
}
#
#########################################################################################################
# select (select username FROM gv$session WHERE sid=a.sid) blocker
#   , a.sid || ',' || (select serial# from gv$session c where sid=a.sid) sess1
#   , ' is blocking ' as BLOCKING
#   , (select username FROM gv$session WHERE sid=b.sid) blockee
#   , b.sid || ',' || (select serial# from gv$session c where sid=b.sid) sess2
# FROM gv$lock a, gv$lock b
# WHERE a.block = 1
# AND b.request > 0
# AND a.id1 = b.id1
# AND a.id2 = b.id2;
#########################################################################################################
#
#########################################################################################################
# VERIFY SESSIONS PER I/O CONSUME
#########################################################################################################
#
DBA_055() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY SESSIONS PER I/O CONSUME
prompt ##############################################################
clear breaks compute
set feedback 6 feedback off linesize 300 pagesize 10000 verify off echo on heading on timing on colsep '|'
undefine topN topStat topUser
define topN=3
define topStat=%
define pctMinimo=1
column pct for 999.9 heading "PCT"
column sid for a15
column top_stat_name format a35 heading 'STATISTIC_NAME' trunc
column sess_status format a10 heading 'STATUS' truncate
column username_osuser format a30 heading 'USERNAME/OSUSER'
column minutos format 9999 heading 'MIN'
column statistic_value format 9g999g999g999g990 heading 'STATISTIC_VAL'
column conn_time format a20 heading 'CONNECTED ON'
column "CONNECTED ON" for a20
column rank format 99
break on top_stat_name skip 1
compute sum of pct on statistic_name
select statistic_name as top_stat_name
   , rank
   , pct as "PCT"
   , sid || '/' || serial# as sid
   , decode( username, null, '(' || bg_name || ')', username) || decode(osuser, null, null, '/') || substr(osuser, 1+instr(osuser, '\')) as username_osuser
   , lpad(decode(trunc(sysdate - logon_time), 0, null, trunc(sysdate - logon_time) || 'd, ') || to_char(to_date(trunc(86400 * ((sysdate-logon_time) - trunc(sysdate - logon_time))), 'SSSSS'), 'hh24"h "mi"m"'), 10) as conn_time
   , round(last_call_et/60, 1) as minutos
   , decode(status, 'ACTIVE', 'ACTIVE', 'INACTIVE', 'INACTIVE', status) as sess_status
   , statistic_value
from (select sn.name as statistic_name
    , row_number() over (partition by sn.name order by sn.name, sv.value desc) as rank
    , 100 * ratio_to_report(sv.value) over (partition by sn.name) as pct
    , sv.value as statistic_value
    , bg.name as bg_name
    , ss.*
from v\$sesstat sv
    , v\$statname sn
    , v\$session ss
    , v\$bgprocess bg
where sn.statistic# = sv.statistic#
and ss.sid = sv.sid
and ss.paddr = bg.paddr(+)
and ss.type != 'BACKGROUND'
and ((status = 'INACTIVE' and last_call_et/60 < 5) or status = 'ACTIVE') and sv.value > 0
and sn.name
in ( 'consistent gets'
   , 'db block gets'
   , 'physical reads'
   , 'physical writes'
-- , 'physical reads direct'
-- , 'physical writes direct'
-- , 'bytes sent via SQL*Net to client'
-- , 'bytes received via SQL*Net from dblink'
-- , 'bytes sent via SQL*Net to dblink'
-- , 'enqueue releases'
-- , 'enqueue requests'
   , 'enqueue waits'
-- , 'recursive cpu usage'
-- , 'session logical reads'
-- , 'session pga memory'
-- , 'session uga memory'
   , 'session pga memory max'
   , 'session uga memory max'
   , 'execute count'
   , 'parse count (hard)'
-- , 'parse time cpu'
-- , 'parse time elapsed'
-- , 'parse count (total)'
-- , 'sorts (disk)'
-- , 'sorts (memory)'
   , 'sorts (rows)'
   , 'table scans (long tables)'
   , 'table fetch continued row'))
where trunc(pct) > &pctMinimo    -- percentuais maiores que pctMinimo
and rank < 1+&topN               -- "N" maiores sessoes que consomem aquele recurso
and upper(statistic_name) like upper('%&topStat.%') ;
quit;
EOF
}
#
#########################################################################################################
# VERIFY FREE SEGMENTS ON DATAFILES
#########################################################################################################
#
DBA_056() {
sqlplus -S / as sysdba <<EOF
set pages 5000 lines 5000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY FREE SEGMENTS ON DATAFILES
prompt ##############################################################
col "Name" for a50
select file_id
  , block_id
  , blocks*8192/1024 MB
  , owner || '.' || segment_name "Name"
  , block_id*8192/1024 "Position MB"
from  dba_Extents
where file_id = 21
union
select file_id
  , block_id
  , blocks*8192/1024, 'Free' "Name"
  , block_id*8192/1024 "Position MB"
from dba_free_space
order by 1,2,3;
quit;
EOF
}
#
#########################################################################################################
# VERIFY WHICH DATAFILE CAN BE RESIZED [ @ ]
#########################################################################################################
#
DBA_057() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY WHICH DATAFILE CAN BE RESIZED [ @ ]
prompt ##############################################################
column file_name format a120 word_wrapped
column smallest format 999,999,990 heading "Smallest|Size|Poss."
column currsize format 999,999,990 heading "Current|Size"
column savings format 999,999,990 heading "Poss.|Savings"
break on report
compute sum of smallest on report
compute sum of currsize on report
compute sum of savings on report
column value new_val blksize for a10
prompt ##############################################################
PROMPT # DB BLOCK SIZE                                              #
prompt ##############################################################
select value from v\$parameter where name = 'DBA_block_size';
prompt
prompt ##############################################################
prompt # INFORMATIONS ABOUT DATAFILES                               #
prompt ##############################################################
select 'DATAFILE ' as DATAFILE
  , file_name
  , ceil((nvl(hwm,1) * &&blksize)/1024/1024) smallest
  , ceil(blocks * &&blksize/1024/1024) currsize
  , ceil(blocks * &&blksize/1024/1024) - ceil((nvl(hwm,1) * &&blksize)/1024/1024) savings
  , case when ceil(blocks * &&blksize/1024/1024) - ceil((nvl(hwm,1) * &&blksize)/1024/1024) > 100 then 'Recomended' else 'Not Recomended' end as "Recomendation"
from dba_data_files a, (select file_id, max(block_id + blocks - 1) hwm from dba_extents group by file_id) b
where a.file_id = b.file_id(+);
prompt
prompt ##############################################################
prompt # COMMANDS TO RESIZE THE DATAFILES                           #
prompt ##############################################################
column "SQL Command" for a175 word_wrapped
select 'alter database datafile ''' || file_name || ''' resize ' || ceil((nvl(hwm,1) * &&blksize)/1024/1024) || 'M;' as "SQL Command"
from dba_data_files a, (select file_id, max(block_id + blocks - 1) hwm from dba_extents group by file_id) b
where a.file_id = b.file_id(+)
and ceil(blocks*&&blksize/1024/1024) - ceil((nvl(hwm,1)*&&blksize)/1024/1024) > 0;
quit;
EOF
# DBA_057B $1
}
#
#########################################################################################################
# VERIFY WHICH DATAFILE CAN BE RESIZED [ @ ]
#########################################################################################################
#
DBA_057B() {
local OPT=$1
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
# ${OPT}
quit;
EOF
}
#
#########################################################################################################
# VERIFY RECYCLEBIN
#########################################################################################################
#
DBA_058() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY RECYCLEBIN                                          #
prompt ##############################################################
col OBJECT_NAME for a25
col ORIGINAL_NAME for a25
col OPERATION for a10
select * from recyclebin;
quit;
EOF
}
#
#########################################################################################################
# CLEAR REYICLEBIN
#########################################################################################################
#
DBA_059() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY RECYCLEBIN                                          #
Prompt # WAIT A MOMENT PLEASE, THE CLEARING IS RUNNING              #
prompt ##############################################################
purge recyclebin;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DATABASE SESSIONS
#########################################################################################################
#
DBA_060() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY DATABASE SESSIONS
prompt ##############################################################
select total_sessions
  , active_sessions
  , (total_sessions - active_sessions) inactive_sessions
  , round( 100 * active_sessions / total_sessions, 2) pct_active
  , round( 100 * (total_sessions - active_sessions) / total_sessions, 2) pct_inactive
from (select count(*) total_sessions from v\$session where type <> 'BACKGROUND') st,
     (select count(*) active_sessions from v\$session where  status = 'ACTIVE' and type <> 'BACKGROUND') sa;
quit;
EOF
}
#
#########################################################################################################
# VERIFY ACTIVES SESSIONS PER OWNER
#########################################################################################################
#
DBA_061() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY ACTIVES SESSIONS PER OWNER
prompt ##############################################################
select total_sessions
  , active_sessions
  , (total_sessions - active_sessions) inactive_sessions
  , round( 100 * active_sessions / total_sessions, 2) pct_active
  , round( 100 * (total_sessions - active_sessions) / total_sessions, 2) pct_inactive
from (select count(*) total_sessions from v\$session where type <> 'BACKGROUND') st,
     (select count(*) active_sessions from v\$session where  status = 'ACTIVE' and type <> 'BACKGROUND') sa;
quit;
EOF
}
#
#########################################################################################################
# UNLOCKING A USER [ @ ]
#########################################################################################################
#
DBA_062() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # UNLOCKING A USER [ @ ]
prompt ##############################################################
col username for a30
col profile for a30
select user_id
  , username
  , account_status
  , default_tablespace
  , profile 
from dba_users
where account_status <> 'OPEN'
order by 2;
quit;
EOF
# DBA_062B $1
}
#
#########################################################################################################
# UNLOCKING A USER [ @ ]
#########################################################################################################
#
DBA_062B() {
local OPT=$1
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
# alter user ${OPT} account unlock;
quit;
EOF
}
#
#########################################################################################################
# LOCKING A USER [ @ ]
#########################################################################################################
#
DBA_063() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # LOCKING A USER [ @ ]
prompt ##############################################################
col username for a30
col profile for a30
select user_id
  , username
  , account_status
  , default_tablespace
  , profile 
from dba_users
where account_status = 'OPEN'
order by 2;
quit;
EOF
# DBA_063B $1
}
#
#########################################################################################################
# LOCKING A USER [ @ ]
#########################################################################################################
#
DBA_063B() {
local OPT=$1
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
# alter user ${OPT} account lock;
quit;
EOF
}
#########################################################################################################
# REDO GROUPS INFORMATIONS
#########################################################################################################
#
DBA_064() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col member FORMAT A90
col group# format 999
col status for a15
col "Thread#" for a10
col TOTAL_MB format 999,999,999,999
col TOTAL_GB format 999,999,999,999
col TOTAL_MB for a20
col TOTAL_GB for a20
break on report
break on top_stat_name skip 1
compute sum of TOTAL_MB on report
compute sum of TOTAL_GB on report
cl break
prompt ##############################################################
prompt # OnLine RedoLogs                                            #
prompt ##############################################################
select t1.GROUP#
   , to_char(t2.thread#) as "Thread#"
   , t1.TYPE
   , t2.status
   , t1.MEMBER
   , t1.IS_RECOVERY_DEST_FILE
   , to_char(t2.bytes/1024/1024, '9G999G999D999') TOTAL_MB
   , to_char(t2.bytes/1024/1024/1024, '999D999') TOTAL_GB
from v\$logfile t1, v\$log t2
where t1.group# = t2.group#
order by 1,2,3,4;
prompt
prompt ##############################################################
prompt # Standby RedoLogs                                           #
prompt ##############################################################
select s1.group#
  , to_char(s2.THREAD#) as "Thread#"
  , s1.type
  , s2.status
  , s1.member
  , 'N/A' as "N/A"
  , to_char(s2.bytes/1024/1024, '9G999G999D999') TOTAL_MB
  , to_char(s2.bytes/1024/1024/1024, '999D999') TOTAL_GB
from v\$logfile s1, v\$standby_log s2
where s1.group# = s2.group#
and s1.type = 'STANDBY'
order by 1,2,3,4;
prompt
prompt ##############################################################
prompt # Archiving Details                                          #
prompt ##############################################################
select PROCESS
  , STATUS
  , to_char(THREAD#) as "THREAD#"
  , SEQUENCE#
  , BLOCK#
  , BLOCKS
FROM V\$MANAGED_STANDBY;
prompt
prompt ##############################################################
prompt # Utilization of Current Redo Log ( in % )                   #
prompt ##############################################################
column "Percent Full" for 999.99 heading "Percent Full"
select le.leseq "Current log sequence No"
  , 100 * cp.cpodr_bno/le.lesiz "Percent Full"
  , cp.cpodr_bno "Current Block No"
  , le.lesiz "Size of Log in Blocks" 
from x\$kcccp cp, x\$kccle le 
where le.leseq =CP.cpodr_seq 
and bitand(le.leflg,24) = 8;
quit;
EOF
}
#
#########################################################################################################
# SHOW ALL CORRUPTED OBJECTS
#########################################################################################################
#
DBA_065() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # SHOW ALL CORRUPTED OBJECTS
prompt ##############################################################
select e.owner
  , e.segment_type
  , e.segment_name
  , e.partition_name
  , c.file#
  , greatest(e.block_id, c.block#) corr_start_block#
  , least(e.block_id+e.blocks-1
  , c.block#+c.blocks-1) corr_end_block#
  , least(e.block_id+e.blocks-1, c.block#+c.blocks-1)- greatest(e.block_id, c.block#) + 1 blocks_corrupted
  , null description
FROM dba_extents e, v\$database_block_corruption c
WHERE e.file_id = c.file#
AND e.block_id <= c.block# + c.blocks - 1
AND e.block_id + e.blocks - 1 >= c.block#
UNION
select s.owner
  , s.segment_type
  , s.segment_name
  , s.partition_name
  , c.file#
  , header_block corr_start_block#
  , header_block corr_end_block#
  , 1 blocks_corrupted
  , 'Segment Header' description
FROM dba_segments s, v\$database_block_corruption c
WHERE s.header_file = c.file#
AND s.header_block between c.block#
and c.block# + c.blocks - 1
UNION
select null owner
  , null segment_type
  , null segment_name
  , null partition_name
  , c.file#
  , greatest(f.block_id, c.block#) corr_start_block#
  , least(f.block_id+f.blocks-1, c.block#+c.blocks-1) corr_end_block#
  , least(f.block_id+f.blocks-1, c.block#+c.blocks-1) - greatest(f.block_id, c.block#) + 1 blocks_corrupted
  , 'Free Block' description
FROM dba_free_space f, v\$database_block_corruption c
WHERE f.file_id = c.file#
AND f.block_id <= c.block# + c.blocks - 1
AND block_id + f.blocks - 1 >= c.block#
order by file#, corr_start_block#;
quit;
EOF
}
#
#########################################################################################################
# VERIFY SPACE OF FLASH RECOVERY AREA
#########################################################################################################
#
DBA_066() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY SPACE OF FLASH RECOVERY AREA
prompt ##############################################################
col name for a75
col size_m for 999,999,999
col used_m for 999,999,999
col "% USED" for a30
select name
   , ceil(space_limit/1024/1024) SIZE_M
   , ceil(space_used/1024/1024) USED_M
   , case when ceil((space_used/space_limit)*100) < 80 then ceil((space_used/space_limit)*100) || '% - Status OK' when ceil((space_used/space_limit)*100) < 90 then ceil((space_used/space_limit)*100) || '% - Warning' else ceil((space_used/space_limit)*100) || '% - Critical' end as "% USED"
-- , decode(nvl(space_used, 2), 0, 0) as "#"
FROM v\$recovery_file_dest
ORDER BY name;
prompt
prompt ##############################################################
prompt # VERIFY SPACE OF FLASH RECOVERY AREA - DETAILS
prompt ##############################################################
col "Status Space" for a20
select FILE_TYPE
   , PERCENT_SPACE_USED
   , PERCENT_SPACE_RECLAIMABLE
   , NUMBER_OF_FILES
-- , CON_ID
   , case when PERCENT_SPACE_USED < 80 then 'Space OK' when PERCENT_SPACE_USED < 90 then 'Warning' else 'Critical' end as "Status Space"
FROM V\$RECOVERY_AREA_USAGE;
quit;
EOF
}
#
#########################################################################################################
# DBA: TOTAL USERS COUNT ON DATABASE
#########################################################################################################
#
DBA_067() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # DBA: TOTAL USERS COUNT ON DATABASE
prompt ##############################################################
prompt
break on report
compute SUM of tot on report
compute SUM of active on report
compute SUM of inactive on report
col username for a50
select DECODE(username,NULL,'INTERNAL',USERNAME) Username
  , count(*) TOT
  , COUNT(DECODE(status,'ACTIVE',STATUS)) ACTIVE
  , COUNT(DECODE(status,'INACTIVE',STATUS)) INACTIVE
from gv\$session
where status in ('ACTIVE','INACTIVE')
group by username;
quit;
EOF
}
#
#########################################################################################################
# VERIFY CONTROLFILES
#########################################################################################################
#
DBA_068() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY CONTROLFILES
prompt ##############################################################
col name for a120
select name
  , status
  , IS_RECOVERY_DEST_FILE
  , BLOCK_SIZE/1024 as BLOCK_SIZE_MB
from v\$controlfile;
quit;
EOF
}
#
#########################################################################################################
# VERIFY CONSUME PER CPU
#########################################################################################################
#
DBA_069() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY CONSUME PER CPU
prompt ##############################################################
COLUMN wait_class format a20
COLUMN name       format a55
COLUMN time_sec   format 999,999,999,999.99
COLUMN time_min   format 999,999,999,999,999.99
COLUMN time_hou   format 999,999,999,999,999,999.99
COLUMN time_day   format 999,999,999,999,999,999,999.99
COLUMN pct        format 999,99
COLUMN "% Used"   format a8 JUSTIFY RIGHT
select wait_class
   , NAME
   , ROUND(time_secs, 2) time_sec
   , ROUND(time_secs/60, 2) time_min
   , ROUND(time_secs/60/60, 2) time_hou
   , ROUND(time_secs/60/60/24, 2) time_day
   , ' ' || ROUND(time_secs * 100 / SUM (time_secs) OVER (), 2) || '%' as "% Used"
FROM (select n.wait_class, e.event NAME, e.time_waited / 100 time_secs FROM v\$system_event e, v\$event_name n WHERE n.NAME = e.event AND n.wait_class <> 'Idle' AND time_waited > 0
      UNION
      select 'CPU', 'server CPU', SUM (VALUE / 1000000) time_secs FROM v\$sys_time_model WHERE stat_name IN ('background cpu time', 'DB CPU'))
-- where ROUND(time_secs*100/SUM(time_secs) OVER (), 2) > 0
-- where "% Used" > 0
ORDER BY time_sec DESC;
quit;
EOF
}
#
#########################################################################################################
# QUICK TUNE
#########################################################################################################
#
DBA_070() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # QUICK TUNE
prompt ##############################################################
COL "MEMORY TYPE" FOR A16
--HEAD "SGA + RATIOS"
--COL "Total_Mem(Ko)" FOR A12
--COL "Free(Ko)" FOR A8
COL "###" FOR A3
COL "MEMORY RATIOS" FOR A28
COL "RATIO %" FOR A7
COL IDEAL FOR A8 ;
compute sum of "Total_Mem K" on report
compute sum of "Free K" on report
break on report ;
select pool as "MEMORY TYPE"
  , Total_Mem as "ALLOCATION K"
  , Free_Mem as "FREE K"
  , '###' "###"
  , RUBRIQUE "MEMORY RATIOS"
  , to_char(round(RATIO*100,1),'999.9') "RATIO %"
  , IDEAL
from (select rownum0, A.pool, A.Total_Mem, B.Free_Mem from (select (rownum) rownum0, A.* from (select pool, round(sum(bytes)/1024,0) Total_Mem from v\$sgastat where pool is not null group by pool
UNION
select name, round(bytes/1024) from v\$sgastat where pool is null and name !='fixed_sga') A
UNION ALL
select 6,'Sort Area Size' ,round(value/1024,0) from v\$parameter where name in ('sort_area_size')
UNION ALL
select 7,'Hash Area Size' ,round(value/1024,0) from v\$parameter where name in ('hash_area_size')) A, (select pool, round(bytes/1024,0) Free_Mem from v\$sgastat where name = 'free memory'
UNION ALL
select 'DBA_block_buffers', (select count(*) from v\$bh where status='free')*(select (round(value/1024,0)) from v\$parameter where name = 'DBA_block_size') from dual ) B where A.pool=B.pool(+)) SGA, (select 6 rownum0, 'DATA DICTIONARY CACHE' "RUBRIQUE", sum(getmisses)/sum(gets) "RATIO", ' < 15 %' "IDEAL" from v\$rowcache
UNION ALL
select 3,'SHARED POOL HIT RATIO',sum(pinhits-reloads)/sum(pins),' > 85 %' from v\$librarycache
UNION ALL
select 4 ,'SHARED POOL RELOAD %',sum (reloads)/sum(pins), ' <  2 %' from v\$librarycache
UNION ALL
select 2,'BUFFER CACHE Hit Ratio', (1-(sum(decode(name, 'physical reads', value, 0))/(sum(decode(name, 'db block gets',value,0)) + (sum(decode(name,'consistent gets', value, 0)))))), ' > 95 %' from v\$sysstat
UNION ALL
select 1,'BUFFER CACHE MISS RATIO', ((G-F)/(G-F+C+E)),' < 15 %' from (select sum(value) C  from v\$sysstat where name like '%- consistent read gets') c, (select value E from v\$sysstat where name = 'db block gets') e, (select value F from v\$sysstat where name = 'physical reads direct') f, (select value G from v\$sysstat where name = 'physical reads') g
UNION ALL
select 5, 'LOG BUFFER REQUESTS Ratio', -- '#Redo Space requests/#redo entries'
((req.value * 50)/entries.value), ' < 0.02%' from v\$sysstat req, v\$sysstat entries where req.name='redo log space requests' and entries.name = 'redo entries'
UNION ALL
select 7,'MEM SORTS/TOTAL SORTS', mem.value/(mem.value+disk.value),' > 95 %' from v\$sysstat mem, v\$sysstat disk where mem.name = 'sorts (memory)' and disk.name = 'sorts (disk)') RATIOS where SGA.rownum0(+) = RATIOS.ROWNUM0 order by SGA.rownum0 asc;
quit;
EOF
}
#
#########################################################################################################
# VERIFY RECOMENDATIONS TUNING TOP 20 [ @ ]
#########################################################################################################
#
DBA_071() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
DEF days_of_history_accessed = '31';
DEF captured_at_least_x_times = '10';
DEF captured_at_least_x_days_apart = '5';
DEF med_elap_microsecs_threshold = '1e4';
DEF min_slope_threshold = '0.1';
DEF max_num_rows = '20';
SET lin 200 ver OFF;
COL SLOPE for a15
COL row_n FOR A2 HEA '#';
COL med_secs_per_exec HEA 'Median Secs|Per Exec' for a20;
COL std_secs_per_exec HEA 'Std Dev Secs|Per Exec';
COL avg_secs_per_exec HEA 'Avg Secs|Per Exec';
COL min_secs_per_exec HEA 'Min Secs|Per Exec';
COL max_secs_per_exec HEA 'Max Secs|Per Exec';
COL plans FOR 9999;
COL sql_text_80 FOR A75;
prompt
prompt ##############################################################
prompt # SQL Statements with "Elapsed Time per Execution" changing over time
prompt ##############################################################
WITH
per_time AS (
select h.dbid
   , h.sql_id
   , SYSDATE - CAST(s.end_interval_time AS DATE) days_ago
   , SUM(h.elapsed_time_total) / SUM(h.executions_total) time_per_exec
FROM  dba_hist_sqlstat h, dba_hist_snapshot s
WHERE h.executions_total > 0
AND s.snap_id = h.snap_id
AND s.dbid = h.dbid
AND s.instance_number = h.instance_number
AND CAST(s.end_interval_time AS DATE) > SYSDATE - &&days_of_history_accessed
GROUP BY h.dbid, h.sql_id, SYSDATE - CAST(s.end_interval_time AS DATE)),
avg_time AS (
select dbid
   , sql_id
   , MEDIAN(time_per_exec) med_time_per_exec
   , STDDEV(time_per_exec) std_time_per_exec
   , AVG(time_per_exec)    avg_time_per_exec
   , MIN(time_per_exec)    min_time_per_exec
   , MAX(time_per_exec)    max_time_per_exec
FROM per_time
GROUP BY dbid, sql_id
HAVING COUNT(*) >= &&captured_at_least_x_times
AND MAX(days_ago) - MIN(days_ago) >= &&captured_at_least_x_days_apart
AND MEDIAN(time_per_exec) > &&med_elap_microsecs_threshold),
time_over_median AS (
select h.dbid
   ,  h.sql_id
   ,  h.days_ago
   ,  (h.time_per_exec / a.med_time_per_exec) time_per_exec_over_med
   ,  a.med_time_per_exec
   ,  a.std_time_per_exec
   ,  a.avg_time_per_exec
   ,  a.min_time_per_exec
   ,  a.max_time_per_exec
FROM per_time h, avg_time a WHERE a.sql_id = h.sql_id),
ranked AS (
select RANK () OVER (ORDER BY ABS(REGR_SLOPE(t.time_per_exec_over_med, t.days_ago)) DESC) rank_num
   ,  t.dbid
   ,  t.sql_id
   ,  CASE WHEN REGR_SLOPE(t.time_per_exec_over_med, t.days_ago) > 0 THEN 'IMPROVING' ELSE 'REGRESSING' END change
   ,  ROUND(REGR_SLOPE(t.time_per_exec_over_med, t.days_ago), 3) slope
   ,  ROUND(AVG(t.med_time_per_exec)/1e6, 3) med_secs_per_exec
   ,  ROUND(AVG(t.std_time_per_exec)/1e6, 3) std_secs_per_exec
   ,  ROUND(AVG(t.avg_time_per_exec)/1e6, 3) avg_secs_per_exec
   ,  ROUND(MIN(t.min_time_per_exec)/1e6, 3) min_secs_per_exec
   ,  ROUND(MAX(t.max_time_per_exec)/1e6, 3) max_secs_per_exec
FROM time_over_median t
GROUP BY t.dbid, t.sql_id
HAVING ABS(REGR_SLOPE(t.time_per_exec_over_med, t.days_ago)) > &&min_slope_threshold)
select LPAD(ROWNUM, 2) row_n
   ,  r.sql_id
   ,  r.change
   ,  TO_CHAR(r.slope, '990.000MI') slope
   ,  TO_CHAR(r.med_secs_per_exec, '999,990.000') med_secs_per_exec
   ,  TO_CHAR(r.std_secs_per_exec, '999,990.000') std_secs_per_exec
   ,  TO_CHAR(r.avg_secs_per_exec, '999,990.000') avg_secs_per_exec
   ,  TO_CHAR(r.min_secs_per_exec, '999,990.000') min_secs_per_exec
   ,  TO_CHAR(r.max_secs_per_exec, '999,990.000') max_secs_per_exec
   ,  (select COUNT(DISTINCT p.plan_hash_value) FROM dba_hist_sql_plan p WHERE p.dbid = r.dbid AND p.sql_id = r.sql_id) plans
--  ,  REPLACE((select DBMS_LOB.SUBSTR(s.sql_text, 80) FROM dba_hist_sqltext s WHERE s.dbid = r.dbid AND s.sql_id = r.sql_id), CHR(10)) sql_text_80
FROM ranked r
WHERE r.rank_num <= &&max_num_rows
ORDER BY r.rank_num
/
quit;
EOF
}
#
#########################################################################################################
# VERIFY TOP 20 TUNING HISTORY [ @ ]
#########################################################################################################
#
DBA_072() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on colsep '|' feedback off trimspool on echo off heading on wrap off
prompt ##############################################################
prompt # VERIFY TOP 20 TUNING HISTORY [ @ ]
prompt ##############################################################
select * from (select SQL_ID ,
sum(decode(session_state,'ON CPU',1,0)) as CPU,
sum(decode(session_state,'WAITING',1,0)) - sum(decode(session_state, 'WAITING', decode(wait_class, 'User I/O',1,0),0)) as WAIT,
sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as IO,
sum(decode(session_state,'ON CPU',1,1)) as TOTAL
from v\$active_session_history
where SQL_ID is not NULL
group by sql_id
order by sum(decode(session_state,'ON CPU',1,1)) desc)
where rownum < 21;
quit;
EOF
}
#
#########################################################################################################
# VERIFY BACKGROUND PROCESSESS
#########################################################################################################
#
DBA_073() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY BACKGROUND PROCESSESS
prompt ##############################################################
select min(name || ': '|| description) process_description FROM v\$bgprocess group by substr(name,1,3) ORDER BY 1;
quit;
EOF
}
#
#########################################################################################################
# TOP 100 QUERY RECOMMENDATIONS
#########################################################################################################
#
DBA_074() {
read
${ORACLE_HOME}/perl/bin/perl <<EOF
#!/usr/bin/perl
# -------------------------------------------------------------------------------------
# Performance Script
# -------------------------------------------------------------------------------------
local Hostname=${1};
local Database=${2};
local Port=${3};
local Username=${3};
local Password=${4};
local Schema=${5};
local AutoImplement=${6};
local Top=${7};
# -------------------------------------------------------------------------------------
# perl AutoDBMS_SQLTUNE.pl HOSTNAME SERVICE PORT USERNAME PASSWORD SCHEMA AUTOIMPLEMENT TOPSQL
# perl AutoDBMS_SQLTUNE.pl nerv01 prod 1521 PORTILHO Nerv2008 SOE N 10
# -------------------------------------------------------------------------------------
use strict;
use warnings;
use DBD::Oracle qw(:ora_session_modes);
# -------------------------------------------------------------------------------------
# Versão 2.00.
# -------------------------------------------------------------------------------------
# Oracle Variable Connections
# -------------------------------------------------------------------------------------
my $Hostname = $ARGV[0];
my $Database = $ARGV[1];
my $Port = $ARGV[2];
my $Username = $ARGV[3];
my $Password = $ARGV[4];
my $Schema = $ARGV[5];
my $AutoImplement = $ARGV[6];
my $Top = $ARGV[7];
# -------------------------------------------------------------------------------------
# Which is the creterie of SQLs to be analyze and in which order?
# -------------------------------------------------------------------------------------
my @Order = ('ELAPSED_TIME', 'CPU_TIME', 'DISK_READS', 'BUFFER_GETS', 'DIRECT_WRITES', 'SORTS');
# -------------------------------------------------------------------------------------
my $oracle_dbh = DBI->connect("dbi:Oracle:host=$Hostname;service_name=$Database;port=$Port", $Username, $Password, {RaiseError => 1, AutoCommit => 0, ora_session_mode => ORA_SYSDBA});
$oracle_dbh->{LongReadLen} = 20*1024*1024; # 20MB
# -------------------------------------------------------------------------------------
open(LOG, '>AutoDBMS_SQLTUNE.log') || die ("Could not open file!");
# -------------------------------------------------------------------------------------
# Remove the Tuning Task Pack if it exists already.
# -------------------------------------------------------------------------------------
my $task_exist = 0;
my $oracle_sql_01 = "select TASK_ID FROM DBA_ADVISOR_TASKS WHERE OWNER = 'SYS' AND TASK_NAME = 'Auto DBMS_SQLTUNE Tuning Task'";
my $oracle_sth_01 = $oracle_dbh->prepare($oracle_sql_01);
$oracle_sth_01->execute();
while (my $oracle_ref_01 = $oracle_sth_01->fetchrow_hashref())
{
  $task_exist++;
}
$oracle_sth_01->finish();
if ($task_exist > 0)
{
  my $oracle_sql_02 = "BEGIN DBMS_SQLTUNE.DROP_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task'); END;";
  my $oracle_sth_02 = $oracle_dbh->prepare($oracle_sql_02);
  $oracle_sth_02->execute();
  $oracle_sth_02->finish();
}

foreach (@Order)
{
  my $Order = $_;
  print "\nAnalisando os TOP $Top SQLs ordenados por $Order...\n\n";
  print LOG "\nAnalisando os $Top 100 SQLs ordenados por $Order...\n\n";
# -------------------------------------------------------------------------------------
# Search for the Top SQLs.
# -------------------------------------------------------------------------------------
my $oracle_sql_03 = "select SQL_ID, SQL_TEXT FROM (select SQL_ID, SQL_TEXT FROM GV\$SQL WHERE PARSING_SCHEMA_NAME = '$Schema' ORDER BY $Order) WHERE ROWNUM < $Top";
my $oracle_sth_03 = $oracle_dbh->prepare($oracle_sql_03);
$oracle_sth_03->execute();
while (my $oracle_ref_03 = $oracle_sth_03->fetchrow_hashref())
{
  my $sql_id = $oracle_ref_03->{SQL_ID};
  my $sql_text = $oracle_ref_03->{SQL_TEXT};
# -------------------------------------------------------------------------------------
# Verify if the SQL stil exists.
# -------------------------------------------------------------------------------------
  my $sql_exist = 0;
  my $oracle_sql_04 = "select SQL_TEXT FROM V\$SQL WHERE SQL_ID= '$sql_id'";
  my $oracle_sth_04 = $oracle_dbh->prepare($oracle_sql_04);
  $oracle_sth_04->execute();
  while (my $oracle_ref_04 = $oracle_sth_04->fetchrow_hashref())
  {
    $sql_exist++;
  }
  $oracle_sth_04->finish();
# -------------------------------------------------------------------------------------
# Execute the Tuning Task
# -------------------------------------------------------------------------------------
  if ($sql_exist > 0)
  {
  my $oracle_sql_05 = "DECLARE RET_VAL VARCHAR2(4000); BEGIN RET_VAL := DBMS_SQLTUNE.CREATE_TUNING_TASK(SQL_ID => '$sql_id', SCOPE => DBMS_SQLTUNE.SCOPE_COMPREHENSIVE, TIME_LIMIT => 600, TASK_NAME => 'Auto DBMS_SQLTUNE Tuning Task', DESCRIPTION => 'Auto DBMS_SQLTUNE Tuning Task'); END;";
  my $oracle_sth_05 = $oracle_dbh->prepare($oracle_sql_05);
  $oracle_sth_05->execute();
  $oracle_sth_05->finish();

  my $oracle_sql_06 = "BEGIN DBMS_SQLTUNE.EXECUTE_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task'); END;";
  my $oracle_sth_06 = $oracle_dbh->prepare($oracle_sql_06);
  $oracle_sth_06->execute();
  $oracle_sth_06->finish();
# -------------------------------------------------------------------------------------
# Show the Recomendations.
# -------------------------------------------------------------------------------------
  my $oracle_sql_07 = "select DBMS_SQLTUNE.REPORT_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task') RECOMMENTATION FROM DUAL";
  my $oracle_sth_07 = $oracle_dbh->prepare($oracle_sql_07);
  $oracle_sth_07->execute();
  while (my $oracle_ref_07 = $oracle_sth_07->fetchrow_hashref())
  {
    my $recommendation = $oracle_ref_07->{RECOMMENTATION};
    print "$recommendation\n\n";
    print LOG "$recommendation\n\n";
  }
# -------------------------------------------------------------------------------------
# Execute the Recomendations.
# -------------------------------------------------------------------------------------
  my $oracle_sql_08 = "select DBMS_SQLTUNE.SCRIPT_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task') RECOMMENTATION FROM DUAL";
  my $oracle_sth_08 = $oracle_dbh->prepare($oracle_sql_08);
  $oracle_sth_08->execute();
  while (my $oracle_ref_08 = $oracle_sth_08->fetchrow_hashref())
  {
    my $recommendation = $oracle_ref_08->{RECOMMENTATION};
    if ($recommendation !~ m/There are no recommended actions for this task under the given filters./)
    {
      my @CompleteRecommendation =  split /\n/, $recommendation;
      foreach (@CompleteRecommendation)
      {
        my $RecommendationLine = $_;
        unless ($RecommendationLine =~ /;/gm) {next;}

        if ($RecommendationLine =~ /^create index /) {$RecommendationLine =~ s/;//;}
        if ($RecommendationLine =~ /^execute /) {$RecommendationLine =~ s/execute //; $RecommendationLine = "BEGIN $RecommendationLine END;";}
        my $oracle_sql_09 = "$RecommendationLine";
        my $oracle_sth_09 = $oracle_dbh->prepare($oracle_sql_09);
        print "Recommendation to implement: $RecommendationLine\n\n";
        print LOG "Recommendation to implement:: $RecommendationLine\n\n";

        my $YesOrNo;
        print "Do you wish to implement it? (Y/N)";
        if ($AutoImplement eq 'Y')
        {
          $YesOrNo = 'Y';
        }
        else
        {
          $YesOrNo = <STDIN>;
          chomp $YesOrNo;
        }
							
        if ($YesOrNo eq 'Y')
        {
          $oracle_sth_09->execute();
          $oracle_sth_09->finish();
          print "Recommendation IMPLEMENTED.\n\n";
          print LOG "Recommendation IMPLEMENTED.\n\n";
          last;
        }
        elsif ($YesOrNo eq 'N')
        {
          print "Recommendation NOT IMPLEMENTED.\n\n";
          print LOG "Recommendation NOT IMPLEMENTED.\n\n";
          last;
        }
        else
        {
          print "\nWell, I don´t know what to do...\n";
          print LOG "\nWell, I don´t know what to do...\n";
        }
        }
    }
      print "\n\n\n\n\n";
    }
    $oracle_sth_08->finish();

    my $oracle_sql_10 = "BEGIN DBMS_SQLTUNE.DROP_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task'); END;";
    my $oracle_sth_10 = $oracle_dbh->prepare($oracle_sql_10);
    $oracle_sth_10->execute();
    $oracle_sth_10->finish();
    }
  }
  $oracle_sth_03->finish();
}
$oracle_dbh->disconnect;
exit;
EOF
}
#
#########################################################################################################
# VERIFY DYNAMICS PARAMETERS [ SPFILE ]
#########################################################################################################
#
DBA_075() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY DYNAMICS PARAMETERS [ SPFILE ]
prompt ##############################################################
col sid for a10
col name for a45
col type for a15
col display_value for a100
select sid
  , name
  , type
  , display_value
from v\$spparameter
order by name;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DBA FEATURES USAGE STATISTICS
#########################################################################################################
#
DBA_076() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY DBA FEATURES USAGE STATISTICS
prompt ##############################################################
col "NAME" for a70
col "DETECTED USAGES" for a20
col "USING NOW Y/N" for a15
select name
  , case when DETECTED_USAGES = 0 then 'Never Used' else to_char(DETECTED_USAGES) || ' Time(s) Used' end as "DETECTED USAGES"
  , case when CURRENTLY_USED = 'FALSE' then 'Not Using' when CURRENTLY_USED = 'TRUE' then 'Using' else 'UNKNOWN' end as "USING NOW Y/N"
  , FIRST_USAGE_DATE
  , LAST_USAGE_DATE
from dba_feature_usage_statistics a, v\$instance b
where a.version = b.version
order by 1;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DBA HIGH WATER MARK STATISTICS
#########################################################################################################
#
DBA_077() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY DBA HIGH WATER MARK STATISTICS
prompt ##############################################################
col NAME for a30
col VERSION for a15
col HIGHWATER for a20
col LAST_VALUE for a20
col DESCRIPTION for a70
select distinct a.NAME
  , a.VERSION
  , to_char(HIGHWATER) as HIGHWATER
  , to_char(LAST_VALUE) as LAST_VALUE
  , DESCRIPTION
from DBA_HIGH_WATER_MARK_STATISTICS a, v\$instance b
where a.version = b.version
order by 1,2;
quit;
EOF
}
#
#########################################################################################################
# GLOBAL INFORMATION ABOUT I/O
#########################################################################################################
#
DBA_078() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
set feedback off trimspool on echo off wrap off;
prompt ##############################################################
prompt # REPORT SQL MONITOR                                         #
prompt ##############################################################
select dbms_sqltune.report_sql_monitor from dual;
prompt
prompt ##############################################################
prompt # GLOBAL INFORMATION ABOUT I/O                               #
prompt ##############################################################
set pages 700 lines 700 timing on long 10000000 longchunksize 10000000 colsep '|' numwidth 20 heading on echo on verify on feedback on colsep '|' lin 200 ver off;
COL instance_number FOR 9999 HEA 'Inst';
COL end_time HEA 'End Time';
COL plan_hash_value HEA 'Plan|Hash Value';
COL executions_total FOR 999,999 HEA 'Execs|Total';
COL rows_per_exec HEA 'Rows Per Exec';
COL et_secs_per_exec HEA 'Elap Secs|Per Exec';
COL cpu_secs_per_exec HEA 'CPU Secs|Per Exec';
COL io_secs_per_exec HEA 'IO Secs|Per Exec';
COL cl_secs_per_exec HEA 'Clus Secs|Per Exec';
COL ap_secs_per_exec HEA 'App Secs|Per Exec';
COL cc_secs_per_exec HEA 'Conc Secs|Per Exec';
COL pl_secs_per_exec HEA 'PLSQL Secs|Per Exec';
COL ja_secs_per_exec HEA 'Java Secs|Per Exec';
select h.instance_number
   , TO_CHAR(CAST(s.end_interval_time AS DATE), 'DD/MM/YYYY HH24:MI:SS') end_time
   , h.plan_hash_value
   , h.executions_total
   , TO_CHAR(ROUND(h.rows_processed_total / h.executions_total), '999,999,999,999') rows_per_exec
   , TO_CHAR(ROUND(h.elapsed_time_total / h.executions_total / 1e6, 3), '999,990.000') et_secs_per_exec
   , TO_CHAR(ROUND(h.cpu_time_total / h.executions_total / 1e6, 3), '999,990.000') cpu_secs_per_exec
   , TO_CHAR(ROUND(h.iowait_total / h.executions_total / 1e6, 3), '999,990.000') io_secs_per_exec
   , TO_CHAR(ROUND(h.clwait_total / h.executions_total / 1e6, 3), '999,990.000') cl_secs_per_exec
   , TO_CHAR(ROUND(h.apwait_total / h.executions_total / 1e6, 3), '999,990.000') ap_secs_per_exec
   , TO_CHAR(ROUND(h.ccwait_total / h.executions_total / 1e6, 3), '999,990.000') cc_secs_per_exec
   , TO_CHAR(ROUND(h.plsexec_time_total / h.executions_total / 1e6, 3), '999,990.000') pl_secs_per_exec
   , TO_CHAR(ROUND(h.javexec_time_total / h.executions_total / 1e6, 3), '999,990.000') ja_secs_per_exec
FROM dba_hist_sqlstat h, dba_hist_snapshot s
WHERE h.sql_id = '${SQL_ID}'
AND h.executions_total > 0
AND s.snap_id = h.snap_id
AND s.dbid = h.dbid
AND s.instance_number = h.instance_number
ORDER BY h.sql_id, h.instance_number, s.end_interval_time, h.plan_hash_value;
prompt
prompt ##############################################################
prompt # For Full Table scans:
prompt ##############################################################
select sql_text 
from v\$sqltext t, v$sql_plan p
where t.hash_value = p.hash_value 
and p.operation = 'TABLE ACCESS'
and p.options = 'FULL'
order by p.hash_value, t.piece;
prompt
prompt ##############################################################
prompt # For Fast Full Index scans:
prompt ##############################################################
select sql_text 
from v\$sqltext t, v$sql_plan p
where t.hash_value = p.hash_value 
and p.operation = 'INDEX'
and p.options = 'FULL SCAN'
order by p.hash_value, t.piece;
prompt
prompt ##############################################################
prompt # Control File Reads and Writes
prompt ##############################################################
select P1
  , P2 
from v\$SESSION_WAIT
where EVENT like 'control file%';
quit;
EOF
}
#
#########################################################################################################
# WHICH SEG. HAVE TOP LOGICAL I/O - PHYSICAL I/O
#########################################################################################################
#
DBA_079() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # WHICH SEG. HAVE TOP LOGICAL I/O - PHYSICAL I/O
prompt ##############################################################
col owner for a30
col OBJECT_NAME for a40
select ROWNUM AS Rank
  , Seg_Lio.*
FROM (select St.Owner
  , St.Obj#
  , St.Object_Type
  , St.Object_Name
  , to_char(St.VALUE) as VALUE
  , 'LIO' AS Unit
FROM v\$segment_Statistics St
WHERE St.Statistic_Name = 'logical reads'
ORDER BY St.VALUE DESC) Seg_Lio WHERE ROWNUM <= 15
UNION ALL
select ROWNUM AS Rank
  , Seq_Pio_r.*
FROM (select St.Owner
  , St.Obj#
  , St.Object_Type
  , St.Object_Name
  , to_char(St.VALUE) as VALUE
  , 'PIO Reads' AS Unit
FROM V\$segment_Statistics St
WHERE St.Statistic_Name = 'physical reads'
ORDER BY St.VALUE DESC) Seq_Pio_r
WHERE ROWNUM <= 15
UNION ALL
select ROWNUM AS Rank
  , Seq_Pio_w.*
FROM (select St.Owner
  , St.Obj#
  , St.Object_Type
  , St.Object_Name
  , to_char(St.VALUE) as VALUE
  , 'PIO Writes' AS Unit
FROM V\$segment_Statistics St
WHERE St.Statistic_Name = 'physical writes'
ORDER BY St.VALUE DESC) Seq_Pio_w
WHERE ROWNUM <= 15;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DBLINKS & FOLDERS INFO
#########################################################################################################
#
DBA_080() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # DATABASE LINKS                                             #
prompt ##############################################################
set long 1000 serveroutput on verify off lines 700
DECLARE
   v_output CLOB := NULL;
BEGIN
   DBMS_OUTPUT.put_line ('DDL For Database Links');
   FOR tt IN (select owner, db_link FROM dba_db_links)
   LOOP
      select DBMS_METADATA.get_ddl ('DB_LINK', tt.db_link, tt.owner) INTO v_output FROM DUAL;
      DBMS_OUTPUT.put_line (v_output);
   END LOOP;
END;
/
prompt
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col owner for a15
col db_link for a30
col username for a15
col host for a100
select * from dba_db_links order by 1,2,3;
prompt
prompt ##############################################################
prompt # Verify Wich DB LINK are Opened                             #
prompt ##############################################################
COL DBA_LINK FORMAT A25 
COL OWNER_ID FORMAT 99999 HEADING "OWNID" 
COL LOGGED_ON FORMAT A5 HEADING "LOGON" 
COL HETEROGENEOUS FORMAT A5 HEADING "HETER" 
COL PROTOCOL FORMAT A8 
COL OPEN_CURSORS FORMAT 999 HEADING "OPN_CUR" 
COL IN_TRANSACTION FORMAT A3 HEADING "TXN" 
COL UPDATE_SENT FORMAT A6 HEADING "UPDATE" 
COL COMMIT_POINT_STRENGTH FORMAT 99999 HEADING "C_P_S" 
select * from v\$DBLINK;
prompt
prompt ##############################################################
prompt # FOLDERS                                                    #
prompt ##############################################################
col folders for a200
select 'create or replace directory ' || directory_name || ' as ' || '''' || directory_path || ''';' as folders from all_directories;
quit;
EOF
}
#
#########################################################################################################
# IDENTIFYING WHEN A PASSWORD WAS LAST CHANGED
#########################################################################################################
#
DBA_081() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # IDENTIFYING WHEN A PASSWORD WAS LAST CHANGED
prompt ##############################################################
col name form a30
col "Created" for a20
col "Last_Changed" for a20
select name
  , ctime as "Created"
  , ptime as "Last_Changed"
  , case when ptime = ctime then 'Never Changed' when ptime < sysdate - 30 and ctime < sysdate - 30 then 'Change Recomended' else 'Recently Changed' end as "Result"
FROM sys.user\$ a, dba_users b
where a.name = b.username
order by 1;
quit;
EOF
}
#
#########################################################################################################
# VERIFY UNDO SEGMENTS
#########################################################################################################
#
DBA_082() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY UNDO SEGMENTS
prompt ##############################################################
select to_char(begin_time, 'DD/MM/YYYY HH24:MI') begin_time
  , to_char(end_time, 'DD/MM/YYYY HH24:MI') end_time
  , tuned_undoretention
from v\$undostat
order by end_time;
prompt
prompt ##############################################################
prompt # VERIFY UNDO SEGMENTS - DETAILS
prompt ##############################################################
select TO_CHAR(BEGIN_TIME, 'DD/MM/YYYY HH24:MI') BEGIN_TIME
  , TO_CHAR(END_TIME, 'DD/MM/YYYY HH24:MI') END_TIME
  , UNDOTSN
  , UNDOBLKS
  , TXNCOUNT
  , MAXCONCURRENCY AS "MAXCON"
FROM v\$UNDOSTAT
WHERE rownum <= 144;
prompt
prompt ##############################################################
prompt # VERIFY UNDO SEGMENTS - STATUS
prompt ##############################################################
select segment_name
  , status
FROM dba_rollback_segs;
prompt
prompt ##############################################################
prompt # VERIFY UNDO SEGMENTS - ROLLBACK
prompt ##############################################################
column "% Waits" format 999.99 heading "% Waits"
select rn.Name "Rollback Segment"
  , rs.RSSize/1024 "Size (KB)"
  , rs.Gets "Gets"
  , rs.waits "Waits"
  , (rs.Waits/rs.Gets)*100 "% Waits"
  , rs.Shrinks "# Shrinks"
  , rs.Extends "# Extends"
FROM sys.v_\$rollName rn, sys.v_\$rollStat rs
WHERE rn.usn = rs.usn
order by "Size (KB)", "Waits", "% Waits";
quit;
EOF
}
#
#########################################################################################################
# VERIFY ALL SQL STATEMENTS
#########################################################################################################
#
DBA_083() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 5000 lines 80 timing on long 9999999 numwidth 20 heading on echo off verify off feedback on colsep '|' head off
prompt ##############################################################
prompt # VERIFY ALL SQL STATEMENTS
prompt ##############################################################
select /*+ CHOOSE*/
'Session Id...........................: ' || s.sid,
'Serial Num...........................: ' || s.serial#,
'User Name............................: ' || s.username,
'SQL ID...............................: ' || s.sql_id,
'Session Status.......................: ' || s.status,
'Client Process Id on Client Machine..: ' || '*' || s.process || '*' Client,
'Server Process ID....................: ' || p.spid Server,
'Sql_Address..........................: ' || s.sql_address,
'Sql_hash_value.......................: ' || s.sql_hash_value,
'Schema Name..........................: ' || s.SCHEMANAME,
'Program..............................: ' || s.program,
'Module...............................: ' || s.module,
'Action...............................: ' || s.action,
'Terminal.............................: ' || s.terminal,
'Client Machine.......................: ' || s.machine,
'LAST_CALL_ET.........................: ' || s.last_call_et,
'S.LAST_CALL_ET/3600..................: ' || s.last_call_et/3600
from v\$session s, v\$process p
where p.addr = s.paddr;
-- and s.sid = nvl('${ORACLE_SID}', s.sid);
quit;
EOF
}
#
#########################################################################################################
# CLONE USER COMMANDS [ @ ]
#########################################################################################################
#
DBA_084() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # CLONE USER COMMANDS [ @ ]
prompt ##############################################################
col username for a30
col profile for a20
select username
  , account_status
  , default_tablespace
  , temporary_tablespace
  , profile
from dba_users
where username not in ('SYS','SYSTEM','XDB','XS$NULL','ANONYMOUS')
order by 1,2;
quit;
EOF
}
#
#########################################################################################################
# VERIFY ALL INFOS ABOUT SYSAUX
#########################################################################################################
#
DBA_085() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # AWR Retention Time                                         #
prompt ##############################################################
select a.dbid
  , c.name
  , b.instance_name
  , a.retention
from DBA_HIST_WR_CONTROL a, v\$instance b, v\$database c
where a.dbid = c.dbid (+);
prompt
prompt ##############################################################
prompt # Statistics Retention History                               #
prompt ##############################################################
select dbms_stats.get_stats_history_retention from dual;
prompt
prompt ##############################################################
prompt # Statistics Availability History                            #
prompt ##############################################################
select dbms_stats.get_stats_history_availability from dual;
prompt
prompt ##############################################################
prompt # Duration Time of SnapShots                                 #
prompt ##############################################################
col "Start Time" for a25
col "End Time" for a25
select min(snap_id) as "First Snap ID"
  , max(snap_id) as "Last Snap ID"
  , min(to_char(begin_interval_time,'DD/MM/YYYY HH24:MI:SS')) as "Start Time"
  , max(to_char(end_interval_time,'DD/MM/YYYY HH24:MI:SS')) as "End Time"
from dba_hist_snapshot;
prompt
prompt ##############################################################
prompt # Infos About SYSAUX TBS                                     #
prompt ##############################################################
COLUMN "Item" FORMAT A25
COLUMN "Space Used (GB)" FORMAT 999.999
COLUMN "Schema" FORMAT A25
COLUMN "Move Procedure" FORMAT A50
select occupant_name "Item"
  , space_usage_kbytes/1048576 "Space Used (GB)"
  , schema_name "Schema"
  , move_procedure "Move Procedure"
FROM gv_\$sysaux_occupants
ORDER BY 1;
prompt
prompt ##############################################################
prompt # Controlling the Size and Age of the OS Audit Trail         #
prompt ##############################################################
COLUMN parameter_name FORMAT A30
COLUMN parameter_value FORMAT A20
COLUMN audit_trail FORMAT A20
select * FROM dba_audit_mgmt_config_params
WHERE parameter_name LIKE 'AUDIT FILE MAX%';
quit;
EOF
}
#
#########################################################################################################
# VERIFY ALL INFOS ABOUT I/O + LATENCY
#########################################################################################################
#
DBA_086() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|' trim on trims on numformat 999999999999999
prompt ##############################################################
prompt # VERIFY ALL INFOS ABOUT I/O & LATENCY
prompt ##############################################################
col name for a70
select to_char(sn.END_INTERVAL_TIME, 'dd/mm/YYYY HH24:MI:SS') "End snapshot time"
  , sum(after.PHYRDS + after.PHYWRTS - before.PHYWRTS - before.PHYRDS) "number of IOs"
  , trunc(10 * sum(after.READTIM + after.WRITETIM - before.WRITETIM - before.READTIM) / sum(1 + after.PHYRDS + after.PHYWRTS - before.PHYWRTS - before.PHYRDS)) "ave IO time (ms)"
  , trunc((select value from v\$parameter where name = 'DBA_block_size') * sum(after.PHYBLKRD + after.PHYBLKWRT - before.PHYBLKRD - before.PHYBLKWRT) / sum(1 + after.PHYRDS + after.PHYWRTS - before.PHYWRTS - before.PHYRDS)) "ave IO size (bytes)"
from DBA_HIST_FILESTATXS before
  , DBA_HIST_FILESTATXS after
  , DBA_HIST_SNAPSHOT sn
where after.file# = before.file#
and after.snap_id = before.snap_id + 1
and before.instance_number = after.instance_number
and after.snap_id = sn.snap_id
and after.instance_number = sn.instance_number
group by to_char(sn.END_INTERVAL_TIME, 'dd/mm/YYYY HH24:MI:SS')
order by to_char(sn.END_INTERVAL_TIME, 'dd/mm/YYYY HH24:MI:SS');
prompt
prompt ##############################################################
prompt # Physical Reads and Writes                                  #
prompt ##############################################################
col name for a100
select NAME
  , PHYRDS "Physical Reads"
  , round((PHYRDS / PD.PHYS_READS)*100,2) "Read %"
  , PHYWRTS "Physical Writes"
  , round(PHYWRTS * 100 / PD.PHYS_WRTS,2) "Write %"
  , fs.PHYBLKRD+FS.PHYBLKWRT "Total Block I/O's"
from (select sum(PHYRDS) PHYS_READS, sum(PHYWRTS) PHYS_WRTS from v\$filestat) pd
  , v\$datafile df
  , v\$filestat fs
where df.FILE# = fs.FILE#
order by fs.PHYBLKRD+fs.PHYBLKWRT desc;
prompt
prompt ##############################################################
prompt # ??? #
prompt ##############################################################
col event for a70
col total_waits for a15
col total_timeouts for a15
col time_waited for a15
select EVENT
  , to_char(TOTAL_WAITS) as TOTAL_WAITS
  , to_char(TOTAL_TIMEOUTS) as TOTAL_TIMEOUTS
  , to_char(TIME_WAITED) as TIME_WAITED
  , round(AVERAGE_WAIT,2) "Average Wait"
from v\$system_event
order by event, to_char(TOTAL_WAITS);
prompt
prompt ##############################################################
prompt # Datafiles Sync Status                                      #
prompt ##############################################################
col name format a100
select distinct name
  , asynch_io
from v\$datafile d
inner join v\$iostat_file f on d.file# = f.file_no
order by 1, 2;
prompt
-- SET SERVEROUTPUT ON
-- DECLARE
  -- lat  INTEGER;
  -- iops INTEGER;
  -- mbps INTEGER;
-- BEGIN
  -- DBMS_RESOURCE_MANAGER.CALIBRATE_IO(
    -- 1    /* # of disks */
    -- , 10   /* maximum tolerable latency in milliseconds */
    -- , iops /* I/O rate per second */
    -- , mbps /* throughput, MB per second */
    -- , lat  /* actual latency in milliseconds */
   -- );
  -- DBMS_OUTPUT.PUT_LINE('max_iops = ' || iops);
  -- DBMS_OUTPUT.PUT_LINE('latency  = ' || lat);
  -- DBMS_OUTPUT.PUT_LINE('max_mbps = ' || mbps);
-- END;
-- /
prompt ##############################################################
prompt # Datafiles Size Reads                                       #
prompt ##############################################################
col name for a100
select d.name
  , f.file_no
  , f.small_read_megabytes
  , f.small_read_reqs
  , f.large_read_megabytes
--  , f.large_read_reqs
from v\$iostat_file f
inner join v\$datafile d on f.file_no = d.file#
order by 1, 2;
quit;
EOF
}
#
#########################################################################################################
# VERIFY MAIN TOP WAIT EVENTS PER WEEK
#########################################################################################################
#
DBA_087() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|' trim on trims on numformat 999999999999999
-- Auslesen Event Historie (cursor: mutex S) - je Report
prompt ##############################################################
prompt # VERIFY MAIN TOP WAIT EVENTS PER WEEK
prompt ##############################################################
col begin_interval_time format a20
col end_interval_time format a20
col AVG_WAIT_TIME_MSEC for a30
col EVENT_NAME for a40
col total_waits for a15
col total_waited_sec for a15
col week for a5
col AVG_WAIT_TIME_MSEC for 999999999,99
select dhs.snap_id
  , to_char(dhs.begin_interval_time,'iw') week
  , to_char(dhs.begin_interval_time,'dd/mm/yyyy hh24:mi:ss') begin_interval_time
  , to_char(dhs.end_interval_time,'dd/mm/yyyy hh24:mi:ss') end_interval_time
  , to_char(event_name) event_name
  , to_char(total_waits) total_waits
  , to_char(round(total_waited_micro/1000000)) as total_waited_sec
  , decode(total_waits,0,0,round(total_waited_micro/total_waits/1000,2)) avg_wait_time_msec
FROM (select snap_id
        , event_name
        , total_waits - lag( total_waits) OVER(ORDER BY snap_id) AS total_waits
        , time_waited_micro - lag (time_waited_micro) over (ORDER BY snap_id) as total_waited_micro
      FROM dba_hist_system_event
      WHERE event_name in ('db file sequential read','direct path read','direct path read temp','direct path sync','direct path write','direct path write temp','log file sync','db file scattered read','cursor: mutex S')
      ORDER BY snap_id) details,
dba_hist_snapshot dhs
WHERE dhs.snap_id = details.snap_id
and total_waits > 0
-- and begin_interval_time > sysdate - 12/24
ORDER BY dhs.snap_id;
quit;
EOF
}
#
#########################################################################################################
# VERIFY OBJECTS SIZE
#########################################################################################################
#
DBA_088() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # SIZE BY OWNER                                              #
prompt ##############################################################
col size_mb for a20
col size_gb for a20
col size_tb for a20
col owner for a30
select owner
  , to_char(sum(bytes)/1024/1024,'999G999G999D999') as SIZE_MB
  , to_char(sum(bytes)/1024/1024/1024,'999G999G999D999') as SIZE_GB
  , to_char(sum(bytes)/1024/1024/1024/1024,'999G999G999D999') as SIZE_TB
From dba_segments
group by owner
order by owner;
prompt
prompt ##############################################################
prompt # VERIFY LARGESTS OBJECTS
prompt ##############################################################
col owner format a30
col segment_name format a50
col segment_type format a20
col tablespace_name format a20
col mb format 999,999,999,999
col gb format 999,999,999,999
col tb format 999,999,999,999
select owner
  , segment_name
  , segment_type
  , tablespace_name
  , mb
  , gb
  , tb
from (select owner
        , segment_name
        , segment_type
        , tablespace_name
        , bytes/1024/1024 "MB"
        , bytes/1024/1024/1024 "GB"
        , bytes/1024/1024/1024/1024 "TB"
      from dba_segments
      order by bytes desc)
where rownum < 26;
quit;
EOF
}
#
#########################################################################################################
# GENERAL DATABASE OVERVIEW
#########################################################################################################
#
DBA_089() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 1000 lines 5000 timing off long 9999999 numwidth 20 heading on echo off verify on colsep '|' head off TRIMSPOOL ON NEWPAGE NONE
prompt ##############################################################
prompt # GENERAL DATABASE OVERVIEW
prompt ##############################################################
col PROPERTY_NAME for a25
col PROPERTY_VALUE for a15
col DESCRIPTION for a35
col DIRECTORY_PATH for a70
col directory_name for a25
col OWNER for a10
col DBA_LINK for a40
col HOST for a20
col "User_Concurrent_Queue_Name" format a50 heading 'Manager'
col "Running_Processes" for 9999 heading 'Running'
break on utl_file_dir
select '------------------------ Getting Database Information ------------------------' from dual;
select 'Database Name.....................: ' || name from v\$database;
select 'Database Status...................: ' || open_mode from v\$database;
select 'Archiving Status..................: ' || log_mode from v\$database;
select 'Global Name.......................: ' || global_name from global_name;
select 'Service Name......................: ' || value from v\$parameter where name = 'service names';
select 'Creation Date.....................: ' || to_char(created,'DD/MM/YYYY HH24:MI:SS') from v\$database;
select 'Checking For Missing File.........: ' || count(*) from v\$recover_file;
select 'Checking Missing File Name .......: ' || count(*) from v\$datafile where name like '%MISS%';
select 'Total SGA MB......................: ' || round(sum(value)/(1024*1024)) || ' MB' from v\$sga ;
select 'Total SGA GB......................: ' || round(sum(value)/(1024*1024*1024)) || ' GB' from v\$sga ;
select 'Total SGA TB......................: ' || round(sum(value)/(1024*1024*1024*1024)) || ' TB' from v\$sga ;
select 'Database Version..................: ' || version from v\$instance;
select 'Database Size MB..................: ' || trim(to_char(sum(bytes)/1024/1024,'9G999G999D99')) || ' MB' from (select sum(bytes) bytes from dba_data_files
union all
select sum(bytes) bytes from dba_temp_files
union all
select sum(bytes * members) from v\$log
union all
select sum(block_size * file_size_blks) from v\$controlfile);
select 'Database Size GB..................: ' || trim(to_char(sum(bytes)/1024/1024/1024,'9G999G999D99')) || ' GB' from (select sum(bytes) bytes from dba_data_files
union all
select sum(bytes) bytes from dba_temp_files
union all
select sum(bytes * members) from v\$log
union all
select sum(block_size * file_size_blks) from v\$controlfile);
select 'Database Size TB..................: ' || trim(to_char(sum(bytes)/1024/1024/1024/1024,'9G999G999D99')) || ' TB' from (select sum(bytes) bytes from dba_data_files
union all
select sum(bytes) bytes from dba_temp_files
union all
select sum(bytes * members) from v\$log
union all
select sum(block_size * file_size_blks) from v\$controlfile);
select 'Temporary Tablespace..............: ' || property_value from database_properties where property_name like 'default_temp_tablespace';
select 'Apps Temp Tablespace..............: ' || temporary_tablespace from dba_users where username like '%APPS%';
select 'Temp Tablespace Size..............: ' || sum(maxbytes/1024/1024/1024) || ' GB' from dba_temp_files group by tablespace_name;
select 'No of Invalid Object .............: ' || count(*) from dba_objects where status = 'INVALID' ;
select 'plsql Code Type...................: ' || value from v\$parameter2 where name = 'plsql_code_type';
select 'plsql Subdir Count................: ' || value from v\$parameter2 where name = 'plsql_native_library_subdir_count';
select 'plsql Native Library Dir..........: ' || value from v\$parameter2 where name = 'plsql_native_library_dir';
select 'Shared Pool Size.........,........: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'shared_pool_size';
select 'Log Buffer........................: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'log_buffer';
select 'Buffer Cache MB...................: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'DBA_cache_size';
select 'Buffer Cache GB...................: ' || (value/1024/1024/1024) || ' GB' from v\$parameter where name = 'DBA_cache_size';
select 'Buffer Cache TB...................: ' || (value/1024/1024/1024/1024) || ' TB' from v\$parameter where name = 'DBA_cache_size';
select 'Large Pool Size MB................: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'large_pool_size';
select 'Large Pool Size GB................: ' || (value/1024/1024/1024) || ' GB' from v\$parameter where name = 'large_pool_size';
select 'Java Pool Size MB.................: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'java_pool_size';
select 'Java Pool Size GB.................: ' || (value/1024/1024/1024) || ' GB' from v\$parameter where name = 'java_pool_size';
select 'utl_file_dir......................: ' || value from v\$parameter2 where name = 'utl_file_dir';
select directory_name || '................: ' || directory_path from all_directories where rownum < 15;
quit;
EOF
}
#
#########################################################################################################
# DBA: SQL SESSION MONITOR
#########################################################################################################
#
DBA_090() {
sqlplus -S / as sysdba <<EOF
set pages 50000 lines 32767 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # DBA: SQL SESSION MONITOR
prompt ##############################################################
COL SID FORMAT a15
COL STATUS FORMAT A8
COL PROCESS FORMAT A10
COL SCHEMANAME FORMAT A16
COL OSUSER FORMAT A20
COL SQL_TEXT FORMAT A120 HEADING 'SQL QUERY'
COL PROGRAM FORMAT A30
SELECT s.sid || ',' || s.serial# as sid
  , s.status
  , s.process
  , s.schemaname
  , s.osuser
  , a.sql_text
  , p.program
FROM v\$session s
  , v\$sqlarea a
  , v\$process p
WHERE s.SQL_HASH_VALUE = a.HASH_VALUE
AND s.SQL_ADDRESS = a.ADDRESS
AND s.PADDR = p.ADDR
order by 1,2,3;
prompt
prompt ##############################################################
prompt # Total user count on database
prompt ##############################################################
compute SUM of tot on report
compute SUM of active on report
compute SUM of inactive on report
col username for a50
select DECODE(username,NULL,'INTERNAL',USERNAME) Username
  , count(*) TOT
  , COUNT(DECODE(status,'ACTIVE',STATUS)) ACTIVE
  , COUNT(DECODE(status,'INACTIVE',STATUS)) INACTIVE
from gv\$session 
where status in ('ACTIVE','INACTIVE') 
group by username
order by 1,2,3;
prompt
prompt ##############################################################
prompt # Users Details Session
prompt ##############################################################
column box format a30
column sid format a15
column spid format a10
column username format a30
column program format a30
column os_user format a20
column LOGON_TIME format a20
select b.inst_id
  , b.sid || ',' || b.serial# as sid
  , a.spid
  , substr(b.machine,1,30) box
  , to_char(b.logon_time, 'dd-mon-yyyy hh24:mi:ss') logon_time
  , substr(b.username,1,30) username
  , substr(b.osuser,1,20) os_user
  , substr(b.program,1,30) program
  , status
  , b.last_call_et AS last_call_et_secs
  , b.sql_id 
from gv\$session b
  , gv\$process a 
where b.paddr = a.addr
and a.inst_id = b.inst_id 
and type='USER' 
order by logon_time;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
column box format a30
column sid format a15
column spid format a10
column username format a30
column program format a30
column os_user format a20
select b.sid || ',' || b.serial# as sid
  , a.spid
  , substr(b.machine,1,30) box
  , b.logon_time logon_date
  , to_char (b.logon_time, 'hh24:mi:ss') logon_time
  , substr(b.username,1,30) username
  , substr(b.osuser,1,20) os_user
  , substr(b.program,1,30) program
  , status
  , b.last_call_et AS last_call_et_secs
  , b.sql_id 
from v\$session b
  , v\$process a 
where b.paddr = a.addr
and type='USER' 
order by b.sid;
prompt
prompt ##############################################################
prompt # All Active and Inactive connections
prompt ##############################################################
col program for a40
col machine for a30
col terminal for a15
col sid for a15
col action for a15
select s.sid || ',' || s.serial# as sid
--  , '' || s.process || '' Client
--  , p.spid as Server
  , s.sql_address
  , s.sql_hash_value
  , s.username
--  , s.action
  , s.program
--  , s.terminal
  , s.machine
  , s.status
  , s.last_call_et
  , s.last_call_et/3600 
from gv\$session s
  , gv\$process p 
where p.addr=s.paddr 
and s.type != 'BACKGROUND'
order by 1,2,3;
prompt
prompt ##############################################################
prompt # Find active transactions
prompt ##############################################################
col name format a15 
col sid format a15
col username format a15 
col osuser format a20
col name format a40
col start_time format a17 
col status format a12 
tti 'Active transactions' 
select s.sid || ',' || s.serial# as sid
  , username
  , t.start_time
  , r.name
  , t.used_ublk "USED BLKS"
  , decode(t.space, 'YES', 'SPACE TX', decode(t.recursive, 'YES', 'RECURSIVE TX', decode(t.noundo, 'YES', 'NO UNDO TX', t.status))) status 
from sys.v_\$transaction t
  , sys.v_\$rollname r
  , sys.v_\$session s 
where t.xidusn = r.usn 
and t.ses_addr = s.saddr
order by 1,2,3;
quit;
EOF
}
#
#########################################################################################################
# VERIFY ALL SQL IDS STATEMENTS
#########################################################################################################
#
DBA_091() {
sqlplus -S / as sysdba <<EOF
set pages 50000 lines 32767 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # Session related Queries                                    #
prompt ##############################################################
prompt # Last/Latest Running SQL                                    #
prompt ##############################################################
col username for a20
col "Last SQL" for a130
col "SID" for a15
select s.username
  , s.sid || ',' || s.serial# || '@' || t.inst_id as "SID"
  , t.sql_id
  , t.sql_text "Last SQL"
FROM gv\$session s, gv\$sqlarea t
WHERE s.sql_address = t.address
AND s.sql_hash_value = t.hash_value;
quit;
EOF
}
#
#########################################################################################################
# VERIFY NLS CONFIGURATION
#########################################################################################################
#
DBA_092() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY NLS CONFIGURATION                                   #
prompt ##############################################################
COL PARAMETER FOR A30
COL DATABASE FOR A30
COL INSTANCE FOR A30
COL SESSION FOR A30
SELECT DB.PARAMETER
  , DB.VALUE "DATABASE"
  , I.VALUE "INSTANCE"
  , S.VALUE "SESSION"
FROM NLS_DATABASE_PARAMETERS DB, NLS_INSTANCE_PARAMETERS I, NLS_SESSION_PARAMETERS S
WHERE DB.PARAMETER=I.PARAMETER(+) AND DB.PARAMETER=S.PARAMETER(+)
ORDER BY 1;
quit;
EOF
}
#
#########################################################################################################
# DBA: VERIFY FAILED LOGIN 
#########################################################################################################
#
DBA_093() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # DBA: VERIFY FAILED LOGIN 
prompt ##############################################################
col username for a15
col os_username for a20
col userhost for a30
col client_id for a20
select username
  , os_username
  , userhost
  , client_id
  , trunc(timestamp)
  , count(*) failed_logins
from dba_audit_trail
where returncode = 1017 --1017 is invalid username/password
and timestamp > sysdate - 7
group by username, os_username, userhost, client_id, trunc(timestamp)
order by 1,2,3;
prompt
prompt ##############################################################
prompt # DBA: VERIFY FAILED LOGIN DETAILS
prompt ##############################################################
col ntimestamp# for a30
col userid for a20
col userhost for a30
col spare1 for a20
col comment\$text for a70
select ntimestamp#
  , userid
  , userhost
  , spare1
  , comment\$text 
from sys.aud\$ 
where returncode=1017 
order by 1,2,3;
prompt
prompt ##############################################################
prompt # DBA: VERIFY FAILED LOGIN DETAILS II
prompt ##############################################################
col username for a15
col os_username for a20
col userhost for a40
col client_id for a20
select OS_USERNAME
  , USERNAME
  , USERHOST
  , to_char(timestamp,'YYYY-MM-DD HH24:MI:SS') as time
  , returncode
from dba_audit_trail 
where returncode > 0
order by 1,2,3;
prompt
prompt ##############################################################
prompt # DBA: VERIFY FAILED LOGIN DETAILS III
prompt ##############################################################
col username for a15  
col userhost for a40
col timestamp for a20
col terminal for a23  
SELECT username
  , userhost
  , terminal
  , to_char(timestamp,'DD/MM/YY HH24:MI:SS') "TIMESTAMP"
  , CASE when returncode = 1017 then 'INVALID-attempt' when returncode = 28000 then 'account locked' end "FAILED LOGIN ACTION" 
FROM dba_audit_session 
where timestamp > sysdate -1/9 
and returncode in (1017,28000)
order by 1,2,3;
quit;
EOF
}
#
#########################################################################################################
# VERIFY ALL SQL IDS STATEMENTS
#########################################################################################################
#
DBA_094() {
local OPT=$1
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
clear col bre comp
set pages 700 lines 700 long 9999999 numwidth 20 echo off verify off feedback off colsep '|'
col elapsed_time_in_sec format 9999.99
col first_load_time format a19
col last_load_time format a19
col SQL_FULLTEXT format a150
col child_number format 999 heading "CHLD|NUM"
col executions format 99999999 heading "EXECS"
col END_OF_FETCH_COUNT heading "FULL|EXECS"
col disk_reads heading "DISK|READS"
col buffer_gets heading "BUFFER|GETS"
col DIRECT_WRITES heading "DIRECT|WRITES"
col APPLICATION_WAIT_TIME heading "APP|WAIT|TIME"
col CONCURRENCY_WAIT_TIME heading "CONC|WAIT|TIME"
col CLUSTER_WAIT_TIME heading "CLUS|WAIT|TIME"
col USER_IO_WAIT_TIME heading "IO|WAIT|TIME"
col PLSQL_EXEC_TIME heading "PLSQL|EXEC|TIME"
col JAVA_EXEC_TIME heading "JAVA|EXEC|TIME"
col rows_processed format 999999999999 heading "ROWS|PROCESSED"
col optimizer_cost format 99999990 heading "COST"
col cpu_sec format 9999990.00 heading "CPU_TIME|SEC"
col elap_sec format 9999990.00 heading "ELAPSED|SEC"
col module format a50
col action format a50
col SHARABLE_MEM heading "SHARE|MEM"
col PERSISTENT_MEM heading "PERST|MEM"
col RUNTIME_MEM heading "RUN|MEM"
col LOADED_VERSIONS format 9999 heading "LOADED|VERS"
col KEPT_VERSIONS format 999 heading "KEPT|VERS"
col OPEN_VERSIONS format 999 heading "OPEN|VERS"
col loads format 9999
col INVALIDATIONS format 99999 heading "INVL"
col PARSE_CALLS format 99999999 heading "PARSE|CALLS"
col PARSING_USER_ID format 999999 heading "PARSING|USER|ID"
col PARSING_SCHEMA_ID format 999999 heading "PARSING|SCHEMA|ID"
prompt ##############################################################
prompt # CHECK MODULE AND ACTION                                    #
prompt ##############################################################
select child_number
  , MODULE
  , ACTION
  , PROGRAM_ID
  , PROGRAM_LINE#
from v\$sql
where sql_id='${OPT}'
/
prompt
prompt ##############################################################
prompt # CHECK MEMORY                                               #
prompt ##############################################################
select child_number
  , SHARABLE_MEM
  , PERSISTENT_MEM
  , RUNTIME_MEM
  , LOADED_VERSIONS
  , KEPT_VERSIONS
  , OPEN_VERSIONS
  , LOADS
  , INVALIDATIONS
  , PARSE_CALLS
  , FIRST_LOAD_TIME
  , LAST_LOAD_TIME
  , PARSING_USER_ID
  , PARSING_SCHEMA_ID
from v\$sql
-- where sql_id='${OPT}'
/
prompt
prompt ##############################################################
prompt # CHECK EXECS                                                #
prompt ##############################################################
select CHILD_NUMBER
  , EXECUTIONS
  , END_OF_FETCH_COUNT
  , DISK_READS
  , BUFFER_GETS
  , sorts
  , DIRECT_WRITES
  , FETCHES
  , ROWS_PROCESSED
  , OPTIMIZER_COST
from v\$sql
-- where sql_id='${OPT}'
/
prompt
prompt ##############################################################
prompt # CHECK CPU TIME                                             #
prompt ##############################################################
select CHILD_NUMBER
  , round(cpu_time/1000000,2) CPU_SEC
  , round(elapsed_time/1000000,2) elap_sec
  , APPLICATION_WAIT_TIME
  , CONCURRENCY_WAIT_TIME
  , CLUSTER_WAIT_TIME
  , USER_IO_WAIT_TIME
  , PLSQL_EXEC_TIME
  , JAVA_EXEC_TIME
from v\$sql
-- where sql_id='${OPT}'
/
prompt
prompt ##############################################################
prompt # CHECK SQL FULL TEXT OF STATEMENT                           #
prompt ##############################################################
select SQL_FULLTEXT
from v\$sql;
-- where sql_id='${OPT}';
prompt
prompt ##############################################################
prompt # CHECK OBJECT LOB OF THE STATEMENT                          #
prompt ##############################################################
select distinct object_name LOB_NAME
from sys.x\$kglob, dba_objects
where KGLNAOBJ like 'table%'
and object_id = to_number(regexp_substr(KGLNAOBJ, '[^_]+', 1, 4),'xxxx');
-- and kglobt03 = '${OPT}';
prompt
prompt ##############################################################
prompt # CHECK CPU COSTS OF THE STATEMENT                           #
prompt ##############################################################
select SQL_ID
  , PLAN_HASH_VALUE
  , sum(EXECUTIONS_DELTA) EXECUTIONS
  , sum(ROWS_PROCESSED_DELTA) CROWS
  , trunc(sum(CPU_TIME_DELTA)/1000000/60) CPU_MINS
  , trunc(sum(ELAPSED_TIME_DELTA)/1000000/60) ELA_MINS
from DBA_HIST_SQLSTAT
where SQL_ID in ('${OPT}')
group by SQL_ID , PLAN_HASH_VALUE
order by SQL_ID, CPU_MINS
/
prompt
prompt ##############################################################
prompt # CHECK XPLAN FROM AWR REPORT                                #
prompt ##############################################################
select * FROM table(DBMS_XPLAN.DISPLAY_AWR('${SQL_ID}'))
/
prompt
prompt ##############################################################
prompt # CHECK SQL BASELINE FOR DIFFERENT EXECUTION PLAN PER TIME   #
prompt ##############################################################
select
-- q.snap_id,
to_char(s.begin_interval_time,'dd/mm/yyyy hh24:mi:ss') begin_interval_time,
-- to_char(s.end_interval_time,'dd/mm/yyyy hh24:mi:ss') end_interval_time,
PLAN_HASH_VALUE,
-- ROWS_PROCESSED_DELTA,
round(ROWS_PROCESSED_DELTA/executions_delta,0) rows_processed,
executions_delta executions_per_report,
round(executions_delta/900,0) executions_per_sec,
-- buffer_gets_delta,
round(buffer_gets_DELTA/executions_delta,0) buffer_gets,
round(DISK_READS_DELTA/executions_delta,0) disk_read,
round(ELAPSED_TIME_DELTA/executions_delta/1000000,3) elapsed_time_in_sec
from dba_hist_sqlstat q, dba_hist_snapshot s
where q.snap_id = s.snap_id
and  sql_id='${OPT}'
and  executions_delta > 0
order by q.snap_id
/
prompt
prompt ##############################################################
prompt # CHECK SQL BASELINE FOR EXECUTION PLAN                      #
prompt ##############################################################
col execs for 999,999,999
col avg_etime for 999,999.999
col avg_lio for 999,999,999.9
col begin_interval_time for a20
col node for 99999
break on plan_hash_value on startup_time skip 1
select ss.snap_id
  , ss.instance_number node
  , to_char(begin_interval_time, 'dd/mm/yyyy HH24:mm:ss') as begin_interval_time
  , sql_id
  , plan_hash_value
  , nvl(executions_delta,0) execs
  , (elapsed_time_delta/decode(nvl(executions_delta,0),0,1,executions_delta))/1000000 avg_etime
  , (buffer_gets_delta/decode(nvl(buffer_gets_delta,0),0,1,executions_delta)) avg_lio
from DBA_HIST_SQLSTAT S, DBA_HIST_SNAPSHOT SS
where sql_id = '${OPT}'
and ss.snap_id = S.snap_id
and ss.instance_number = S.instance_number
and executions_delta > 0
order by 1, 2, 3;
undefine SQL_ID
quit;
EOF
}
#
#########################################################################################################
# VERIFY ALL PATCHES APPLIED
#########################################################################################################
#
DBA_095() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # SHOW INFORMATION ABOUT PATCHES                             #
prompt ##############################################################
COLUMN action_time FORMAT A20
COLUMN action FORMAT A10
-- COLUMN bundle_series FORMAT A10
COLUMN comments FORMAT A30
COLUMN description FORMAT A90
COLUMN namespace FORMAT A20
COLUMN status FORMAT A15
COLUMN version FORMAT A10
SELECT TO_CHAR(action_time, 'DD/MM/YYYY HH24:MI:SS') AS action_time
  , action
  , status
  , description
-- , version
  , patch_id
-- , bundle_series
FROM sys.dba_registry_sqlpatch
ORDER by action_time;
prompt
prompt ##############################################################
prompt # SHOW INFORMATION ABOUT PATCHES WITH DETAILS                #
prompt ##############################################################
col version for a20
col namespace for a25
col comments for a85
SELECT TO_CHAR(action_time, 'DD/MM/YYYY HH24:MI:SS') AS action_time
  , action
  , namespace
  , version
--  , id
  , comments
  , bundle_series
FROM sys.registry\$history
ORDER by action_time;
quit;
EOF
}
#
#########################################################################################################
# VERIFY CPU USAGE BY MINUTE
#########################################################################################################
#
DBA_096() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col sample_time for a20
col CONFIGURATION head "CONFIG" for 99.99
col ADMINISTRATIVE head "ADMIN" for 99.99
col OTHER for 99.99
col OTHER for a10
col CLUST for a10
col QUEUEING for a10
col NETWORK for a10
col ADMINISTRATIVE for a10
col CONFIGURATION for a10
col COMMIT for a10
col APPLICATION for a15
col CONCURRENCY for a15
col SYSTEM_IO for a10
col USER_IO for a10
col SCHEDULER for a10
col CPU for a10
col BACKGROUND_CPU for a15
SELECT TO_CHAR(SAMPLE_TIME, 'DD/MM/YYYY HH24:MI:SS') AS SAMPLE_TIME
  , to_char(ROUND(OTHER/60, 3)) AS OTHER
  , to_char(ROUND(CLUST/60, 3)) AS CLUST
  , to_char(ROUND(QUEUEING/60, 3)) AS QUEUEING
  , to_char(ROUND(NETWORK/60, 3)) AS NETWORK
  , to_char(ROUND(ADMINISTRATIVE/60, 3)) AS ADMINISTRATIVE
  , to_char(ROUND(CONFIGURATION/60, 3)) AS CONFIGURATION
  , to_char(ROUND(COMMIT/60, 3)) AS COMMIT
  , to_char(ROUND(APPLICATION/60, 3)) AS APPLICATION
  , to_char(ROUND(CONCURRENCY/60, 3)) AS CONCURRENCY
  , to_char(ROUND(SIO/60, 3)) AS SYSTEM_IO
  , to_char(ROUND(UIO/60, 3)) AS USER_IO
  , to_char(ROUND(SCHEDULER/60, 3)) AS SCHEDULER
  , to_char(ROUND(CPU/60, 3)) AS CPU
  , to_char(ROUND(BCPU/60, 3)) AS BACKGROUND_CPU
FROM (SELECT TRUNC(SAMPLE_TIME, 'MI') AS SAMPLE_TIME
        , DECODE(SESSION_STATE, 'ON CPU'
	      , DECODE(SESSION_TYPE, 'BACKGROUND', 'BCPU', 'ON CPU')
	      , WAIT_CLASS) AS WAIT_CLASS 
      FROM V\$ACTIVE_SESSION_HISTORY 
      WHERE SAMPLE_TIME > SYSDATE - INTERVAL '2' HOUR 
      AND SAMPLE_TIME <= TRUNC(SYSDATE, 'MI')) ASH PIVOT(COUNT(*) FOR WAIT_CLASS IN 
      ('ON CPU' AS CPU
       , 'BCPU' AS BCPU
       , 'Scheduler' AS SCHEDULER
       , 'User I/O' AS UIO
       , 'System I/O' AS SIO
       , 'Concurrency' AS CONCURRENCY
       , 'Application' AS APPLICATION
       , 'Commit' AS COMMIT
       , 'Configuration' AS CONFIGURATION
       , 'Administrative' AS ADMINISTRATIVE
       , 'Network' AS NETWORK
       , 'Queueing' AS QUEUEING
       , 'Cluster' AS CLUST
       , 'Other' AS OTHER))
order by 1;
quit;
EOF
}
#
#########################################################################################################
# VERIFY STANDBY CONFIGURATION
#########################################################################################################
#
DBA_097() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # DBA: Basic Configuration
prompt ##############################################################
column name for a30
column display_value for a100
column ID format 99
column "SRLs" format 99
column active format 99
column type format a4
column ID format 99
column "SRLs" format 99
column active format 99
column type format a4
column PROTECTION_MODE for a20
column RECOVERY_MODE for a20
column db_mode for a15
SELECT name, display_value 
FROM v\$parameter 
WHERE name IN ('db_name'
  , 'db_unique_name'
  , 'log_archive_config'
  , 'log_archive_dest_2'
  , 'log_archive_dest_state_2'
  , 'fal_client'
  , 'fal_server'
  , 'standby_file_management'
  , 'standby_archive_dest'
  , 'db_file_name_convert'
  , 'log_file_name_convert'
  , 'remote_login_passwordfile'
  , 'local_listener'
  , 'dg_broker_start'
  , 'dg_broker_config_file1'
  , 'dg_broker_config_file2'
  , 'log_archive_max_processes') 
order by name;
prompt
prompt ##############################################################
prompt # DBA: Database Role, Archive, Flashback, Force Logging
prompt ##############################################################
column name for a10
column DATABASE_ROLE for a10
column force_logging for a13
SELECT name
  , db_unique_name
  , DATABASE_ROLE
  , log_mode
  , force_logging
  , flashback_on
  , protection_mode
  , PROTECTION_LEVEL
  , OPEN_MODE
  , switchover_status 
from v\$database;
prompt
prompt ##############################################################
prompt # DBA: Database Threads
prompt ##############################################################
select thread#
  , max(sequence#) 
from v\$archived_log 
group by thread#;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
column severity for a15
column message for a70
column timestamp for a20
select severity
  , error_code
  , to_char(timestamp,'DD-MON-YYYY HH24:MI:SS') "timestamp"
  , message 
from v\$dataguard_status 
where dest_id=2;
prompt
prompt ##############################################################
prompt # DBA: Database Configuration Standby Details
prompt ##############################################################
col recovery_mode for a25
select ds.dest_id id
  , ad.status
  , ds.database_mode db_mode
  , ad.archiver type
  , ds.recovery_mode
  , ds.protection_mode
  , ds.standby_logfile_count "SRLs"
  , ds.standby_logfile_active active
  , ds.archived_seq#
from v\$archive_dest_status ds
  , v\$archive_dest ad
where ds.dest_id = ad.dest_id
and ad.status != 'INACTIVE'
order by ds.dest_id;
prompt
prompt ##############################################################
prompt # DBA: Recovery File Dest Usage
prompt ##############################################################
column FILE_TYPE format a20
col name format a60
select name
  , floor(space_limit/1024/1024) "Size MB"
  , ceil(space_used/1024/1024) "Used MB"
from v\$recovery_file_dest
order by name;
prompt
prompt ##############################################################
prompt # ON STANDBY
prompt ##############################################################
column name for a30
column display_value for a100
col value for a10
col PROTECTION_MODE for a15
col DATABASE_Role for a15
SELECT name
  , display_value 
FROM v\$parameter 
WHERE name IN ('db_name'
  , 'db_unique_name'
  , 'log_archive_config'
  , 'log_archive_dest_2'
  , 'log_archive_dest_state_2'
  , 'fal_client'
  , 'fal_server'
  , 'standby_file_management'
  , 'standby_archive_dest'
  , 'db_file_name_convert'
  , 'log_file_name_convert'
  , 'remote_login_passwordfile'
  , 'local_listener'
  , 'dg_broker_start'
  , 'dg_broker_config_file1'
  , 'dg_broker_config_file2'
  , 'log_archive_max_processes') 
order by name;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
col name for a10
col DATABASE_ROLE for a10
SELECT name
  , db_unique_name
  , protection_mode
  , DATABASE_ROLE
  , OPEN_MODE 
from v\$database;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
select thread#
  , max(sequence#) 
from v\$archived_log 
where applied='YES' 
group by thread#;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
select process
  , status
  , thread#
  , sequence# 
from v\$managed_standby;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
SELECT ARCH.THREAD# "Thread"
  , ARCH.SEQUENCE# "Last Sequence Received"
  , APPL.SEQUENCE# "Last Sequence Applied"
  , (ARCH.SEQUENCE# - APPL.SEQUENCE#) "Difference"
FROM 
(SELECT THREAD#, SEQUENCE# FROM V\$ARCHIVED_LOG WHERE (THREAD#, FIRST_TIME) IN 
(SELECT THREAD#, MAX(FIRST_TIME) FROM V\$ARCHIVED_LOG GROUP BY THREAD#)) ARCH,
(SELECT THREAD#, SEQUENCE# FROM V\$LOG_HISTORY WHERE (THREAD#, FIRST_TIME) IN 
(SELECT THREAD#, MAX(FIRST_TIME) FROM V\$LOG_HISTORY GROUP BY THREAD#)) APPL
WHERE ARCH.THREAD# = APPL.THREAD# ORDER BY 1;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
col name for a30 
select * from v\$dataguard_stats; 
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
select * from v\$archive_gap; 
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
col name format a60 
select name
  , floor(space_limit/1024/1024) "Size MB"
  , ceil(space_used/1024/1024) "Used MB" 
from v\$recovery_file_dest 
order by name;
quit;
EOF
}
#
#########################################################################################################
# VERIFY GRANTS AND PERMISSIONS BY OWNER
#########################################################################################################
#
DBA_098() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col PRIVILEGE for a40
col OBJ_OWNER for a20
col OBJ_NAME for a40
col USERNAME for a20
col GRANT_SOURCES for a40
SELECT PRIVILEGE
  , OBJ_OWNER
  , OBJ_NAME
  , USERNAME
  , LISTAGG(GRANT_TARGET, ',') WITHIN GROUP (ORDER BY GRANT_TARGET) AS GRANT_SOURCES
  , MAX(ADMIN_OR_GRANT_OPT) AS ADMIN_OR_GRANT_OPT
  , MAX(HIERARCHY_OPT) AS HIERARCHY_OPT
FROM (WITH ALL_ROLES_FOR_USER AS (SELECT DISTINCT CONNECT_BY_ROOT GRANTEE AS GRANTED_USER, GRANTED_ROLE FROM DBA_ROLE_PRIVS CONNECT BY GRANTEE = PRIOR GRANTED_ROLE)
    SELECT PRIVILEGE
      , OBJ_OWNER
      , OBJ_NAME
      , USERNAME
      , REPLACE(GRANT_TARGET, USERNAME, 'Direct to user') AS GRANT_TARGET
      , ADMIN_OR_GRANT_OPT
      , HIERARCHY_OPT
    FROM (SELECT PRIVILEGE, NULL AS OBJ_OWNER, NULL AS OBJ_NAME, GRANTEE AS USERNAME, GRANTEE AS GRANT_TARGET, ADMIN_OPTION AS ADMIN_OR_GRANT_OPT, NULL AS HIERARCHY_OPT FROM DBA_SYS_PRIVS WHERE GRANTEE IN (SELECT USERNAME FROM DBA_USERS)
        UNION ALL
        SELECT PRIVILEGE, NULL AS OBJ_OWNER, NULL AS OBJ_NAME, ALL_ROLES_FOR_USER.GRANTED_USER AS USERNAME, GRANTEE AS GRANT_TARGET, ADMIN_OPTION AS ADMIN_OR_GRANT_OPT, NULL AS HIERARCHY_OPT FROM DBA_SYS_PRIVS
        JOIN ALL_ROLES_FOR_USER ON ALL_ROLES_FOR_USER.GRANTED_ROLE = DBA_SYS_PRIVS.GRANTEE
        UNION ALL
        SELECT PRIVILEGE, OWNER AS OBJ_OWNER, TABLE_NAME AS OBJ_NAME, GRANTEE AS USERNAME, GRANTEE AS GRANT_TARGET, GRANTABLE, HIERARCHY FROM DBA_TAB_PRIVS WHERE GRANTEE IN (SELECT USERNAME FROM DBA_USERS)
        UNION ALL
        SELECT PRIVILEGE, OWNER AS OBJ_OWNER, TABLE_NAME AS OBJ_NAME, GRANTEE AS USERNAME, ALL_ROLES_FOR_USER.GRANTED_ROLE AS GRANT_TARGET, GRANTABLE, HIERARCHY FROM DBA_TAB_PRIVS
        JOIN ALL_ROLES_FOR_USER ON ALL_ROLES_FOR_USER.GRANTED_ROLE = DBA_TAB_PRIVS.GRANTEE
    ) ALL_USER_PRIVS
      -- WHERE USERNAME in ('')
	) DISTINCT_USER_PRIVS
GROUP BY PRIVILEGE, OBJ_OWNER, OBJ_NAME, USERNAME;
quit;
EOF
}
#
#########################################################################################################
# DBA: USER DETAILS SESSIONS
#########################################################################################################
#
DBA_099() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # DBA: USER DETAILS SESSIONS
prompt ##############################################################
prompt
column box format a25
column session_id for a15
column spid format a10
column username format a20 
column program format a30
column os_user format a20
col LOGON_TIME for a20  
select b.sid || ',' || b.serial# || '@' || b.inst_id as session_id
  , a.spid
  , substr(b.machine,1,30) box
  , to_char(b.logon_time, 'dd/mm/yyyy hh24:mi:ss') logon_time
  , substr(b.username,1,30) username
  , substr(b.osuser,1,20) os_user
  , substr(b.program,1,30) program
  , status
  , b.last_call_et AS last_call_et_secs
  , b.sql_id 
 from gv\$session b,gv\$process a 
 where b.paddr = a.addr 
 and a.inst_id = b.inst_id  
 and type = 'USER'  
 order by b.inst_id,b.sid;
quit;
EOF
}
#
#########################################################################################################
# VERIFY BACKUP RUNNING ON REAL TIME
#########################################################################################################
#
DBA_100() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
COL MESSAGE FORMAT A100
COL FILENAME FORMAT A100
SELECT SID
  , SERIAL#
  , START_TIME
  , ((SOFAR/TOTALWORK)*100) as TOTAL_WORKED
  , '%' as PERC
  , TIME_REMAINING
  , MESSAGE 
FROM V\$SESSION_LONGOPS 
where TIME_REMAINING > 0 
ORDER BY TIME_REMAINING;
prompt
prompt ##############################################################
prompt
prompt ##############################################################
SELECT FILENAME
  , BYTES/1024/1024/1024
FROM GV\$BACKUP_ASYNC_IO 
WHERE STATUS='IN PROGRESS';
prompt
prompt ##############################################################
prompt
prompt ##############################################################
SELECT INPUT_TYPE
  , TO_CHAR(START_TIME, 'DD/MM/YYYY, HH24:MI:SS') as STARTED
  , TO_CHAR(END_TIME, 'DD/MM/YYYY, HH24:MI:SS') as FINISHED
  , STATUS 
FROM V\$RMAN_BACKUP_JOB_DETAILS 
ORDER BY START_TIME;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DATABASE COMPONENTS FROM REGISTRY
#########################################################################################################
#
DBA_101() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col COMP_ID format a15
col COMP_NAME format a50
col SCHEMA format a15
col STATUS format a15
col VERSION format a15
col CON_ID format 99
select CON_ID
  , COMP_ID
  , comp_name
  , schema
  , status
  , version 
from CDB_REGISTRY 
order by 1,2;
quit;
EOF
}
#
#########################################################################################################
# DBA: VERIFY ORACLE NET SEND AND RECEIVE SIZE VOLUME
#########################################################################################################
#
DBA_102() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col name for a50
col event for a50
col format_size for a20
col format_size2 for a20
col FORMAT_NUMBER for a20
col FORMAT_NUMBER2 for a20
prompt ##############################################################
prompt # DBA: VERIFY ORACLE NET SEND AND RECEIVE SIZE VOLUME
prompt ##############################################################
select name
  , dbms_xplan.FORMAT_SIZE(value) as FORMAT_SIZE
  , dbms_xplan.FORMAT_SIZE2(value) FORMAT_SIZE2 
from v\$sysstat 
where name like 'bytes%SQL*Net%' 
and value > 0 
order by value desc;
prompt
prompt ##############################################################
prompt # DBA: VERIFY ORACLE NET SEND AND RECEIVE SIZE VOLUME
prompt ##############################################################
select event
  , dbms_xplan.FORMAT_NUMBER(total_waits) as FORMAT_NUMBER
  , dbms_xplan.FORMAT_NUMBER2(total_waits) as FORMAT_NUMBER2 
from v\$system_event 
where event like '%SQL*Net%' 
order by total_waits desc;
quit;
EOF
}
#
#########################################################################################################
# DBA: START AN ADVISOR TASK
#########################################################################################################
#
DBA_103() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 1000 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|' LONG 1000000 LONGCHUNKSIZE 100000 SERVEROUTPUT ON
prompt
prompt ##############################################################
prompt # DBA: START AN ADVISOR TASK
prompt ##############################################################
DECLARE
  v_tname   VARCHAR2(128) := 'TEST_TASK_DBNITRO';
  v_ename   VARCHAR2(128) := NULL;
  v_report  CLOB := NULL;
  v_script  CLOB := NULL;
BEGIN
  v_tname  := DBMS_STATS.CREATE_ADVISOR_TASK(v_tname);
  v_ename  := DBMS_STATS.EXECUTE_ADVISOR_TASK(v_tname);
  v_report := DBMS_STATS.REPORT_ADVISOR_TASK(v_tname);
  DBMS_OUTPUT.PUT_LINE(v_report);
END;
/
quit;
EOF
}
#
#########################################################################################################
# DBA: SQL ID WITH PARAMETER
#########################################################################################################
#
SQLID() {
local SQLID=$1
if [[ "${SQLID}" == "" ]]; then
  echo ""
  echo " -- YOU NEED TO EXECUTE THIS FUNCTION WITH THE SQL_ID AFTER THE NAME: EXAMPLE: SQLID xxx000xxx000xxx"
  echo ""
else
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # SQL ID
prompt ##############################################################
col sql_id for a15
col sql_text for a50
SELECT sql_id
  , sql_text
  , elapsed_time / 1000000 AS elapsed_seconds
  , cpu_time / 1000000 AS cpu_seconds
  , executions
  , buffer_gets
  , disk_reads
  , optimizer_cost
  , plan_hash_value
FROM gv\$sql
WHERE sql_id = '${SQLID}';
quit;
EOF
fi
}
#
#########################################################################################################
# Finish of the System
#########################################################################################################
#
