
#########################################################################################################
#########################################################################################################
#########################################################################################################
#########################################################################################################
#########################################################################################################
# DATABASE Funtions
#
#########################################################################################################
# DATABASE: VERIFY DATABASE VERSION
#########################################################################################################

|#[ DBA_007 ] DBA: TOP 20 DB-CPU ACTIVITY                             |#|[ DBA_008 ] DBA: VERIFY SESSIONS PER MEMORY                     |#|
|#[ DBA_009 ] DBA: DATABASE SIZE                                      |#|[ DBA_010 ] DBA: VERIFY SESSIONS PER I/O                        |#|
|#[ DBA_011 ] DBA: HIT RATIO THE LASTS 30 DAYS                        |#|[ DBA_012 ] DBA: VERIFY LONG OPERATIONS                         |#|
|#[ DBA_013 ] DBA: INVALIDS OBJECTS [ @ ]                             |#|[ DBA_014 ] DBA: JOBS CONTROL OF THE CLIENT [ @ ]               |#|
|#[ DBA_015 ] DBA: MATERIALIZEDS VIEWS DISABLED                       |#|[ DBA_016 ] DBA: VERIFY RUNNING JOBS                            |#| 
|#[ DBA_017 ] DBA: KILL A RUNNING SESSION [ @ ]                       |#|[ DBA_018 ] DBA: VERIFY PROFILE INFORMATION                     |#| 
|#[ DBA_019 ] DBA: BACKUP STATISTICS                                  |#|[ DBA_020 ] DBA: QTD OF ARCHIVES PER HOUR                       |#| 
|#[ DBA_021 ] DBA: LAST FILE OF LAST BACKUP ARCH - RMAN               |#|[ DBA_022 ] DBA: LAST FILE OF LAST BACKUP FULL - RMAN           |#| 
|#[ DBA_023 ] DBA: ARCHIVES GENERATED PER DAY                         |#|[ DBA_024 ] DBA: BACKUP LOG OF LAST BACKUP FULL - RMAN          |#| 
|#[ DBA_025 ] DBA: BACKUP LOG OF LASTS ARCHIVES - RMAN                |#|[ DBA_026 ] DBA: ERRORS ON ALERT LOG FILE                       |#| 
|#[ DBA_027 ] DBA: ORACLE ENTERPRISE MANAGER ALERT                    |#|[ DBA_028 ] DBA: CAPTURE STATISTICS OF DATA DICTIONARY          |#| 
|#[ DBA_029 ] DBA: CAPTURE STATISTICS OF ALL DATABASE                 |#|[ DBA_030 ] DBA: BLOCKING LOCKS                                 |#| 
|#[ DBA_031 ] DBA: LOCKED OBJECTS                                     |#|[ DBA_032 ] DBA: BLOCKING LOCKS [ SUMARY ]                      |#| 
|#[ DBA_033 ] DBA: BLOCKING LOCKS [ USER DETAILS ]                    |#|[ DBA_034 ] DBA: BLOCKING LOCKS [ WAITING SQL ]                 |#| 
|#[ DBA_035 ] DBA: LOCKED OBJECTS [ DETAILS ]                         |#|[ DBA_036 ] DBA: DML AND DDL LOCKS                              |#| 
|#[ DBA_037 ] DBA: DML TABLE LOCKS TIME                               |#|[ DBA_038 ] DBA: VERIFY SESSIONS [ @ ]                          |#| 
|#[ DBA_039 ] DBA: TOP 20 DATABASE SESSIONS                           |#|[ DBA_040 ] DBA: VERIFY TABLESPACES                             |#| 
|#[ DBA_041 ] DBA: VERIFY STATISTICS - TABLES [ @ ]                   |#|[ DBA_042 ] DBA: VERIFY STATISTICS - INDEXES [ @ ]              |#| 
|#[ DBA_043 ] DBA: CAPTURE STATISTICS - OWNER [ @ ]                   |#|[ DBA_044 ] DBA: VALIDATE OBJECTS FROM ONE OWNER [ @ ]          |#| 
|#[ DBA_045 ] DBA: VERIFY TABLES SIZE, VALIDATE OBJ - OWNERS [ @ ]    |#|[ DBA_046 ] DBA: OWNER X OBJECTS X TYPE X QTD                   |#| 
|#[ DBA_047 ] DBA: VERIFY INSTANCE CHARACTERSET                       |#|[ DBA_048 ] DBA: CACHE HIT RATIO [ GOOD: > 90% ]                |#| 
|#[ DBA_049 ] DBA: VERIFY INSTANCE INSTALLED PRODUCTS                 |#|[ DBA_050 ] DBA: INSTANCE PROPERTIES                            |#| 
|#[ DBA_051 ] DBA: INSTANCE OPTIONS                                   |#|[ DBA_052 ] DBA: INSTANCE DIFFERENTS PARAMETERS                 |#| 
|#[ DBA_053 ] DBA: INSTANCE MODIFICABLES PARAMETERS                   |#|[ DBA_054 ] DBA: VERIFY DEAD LOCKS                              |#| 
|#[ DBA_055 ] DBA: VERIFY SESSIONS PER I/O CONSUME                    |#|[ DBA_056 ] DBA: VERIFY FREE SEGMENTS ON DATAFILES              |#| 
|#[ DBA_057 ] DBA: VERIFY WHICH DATAFILE CAN BE RESIZED [ @ ]         |#|[ DBA_058 ] DBA: VERIFY RECYCLEBIN                              |#| 
|#[ DBA_059 ] DBA: CLEAR REYICLEBIN                                   |#|[ DBA_060 ] DBA: VERIFY DATABASE SESSIONS                       |#| 
|#[ DBA_061 ] DBA: VERIFY ACTIVES SESSIONS PER OWNER                  |#|[ DBA_062 ] DBA: UNLOCKING A USER [ @ ]                         |#| 
|#[ DBA_063 ] DBA: LOCKING A USER [ @ ]                               |#|[ DBA_064 ] DBA: REDO GROUPS INFORMATIONS                       |#| 
|#[ DBA_065 ] DBA: SHOW ALL CORRUPTED OBJECTS                         |#|[ DBA_066 ] DBA: VERIFY SPACE OF FLASH RECOVERY AREA            |#| 
|#[ DBA_067 ] DBA: TOTAL USERS COUNT ON DATABASE                      |#|[ DBA_068 ] DBA: VERIFY CONTROLFILES                            |#| 
|#[ DBA_069 ] DBA: VERIFY CONSUME PER CPU                             |#|[ DBA_070 ] DBA: QUICK TUNE                                     |#| 
|#[ DBA_071 ] DBA: VERIFY RECOMENDATIONS TUNING TOP 20 [ @ ]          |#|[ DBA_072 ] DBA: VERIFY TOP 20 TUNING HISTORY [ @ ]             |#| 
|#[ DBA_073 ] DBA: VERIFY BACKGROUND PROCESSESS                       |#|[ DBA_074 ] DBA: TOP 100 QUERY RECOMMENDATIONS                  |#| 
|#[ DBA_075 ] DBA: VERIFY DYNAMICS PARAMETERS [ SPFILE ]              |#|[ DBA_076 ] DBA: VERIFY DBA FEATURES USAGE STATISTICS           |#| 
|#[ DBA_077 ] DBA: VERIFY DBA HIGH WATER MARK STATISTICS              |#|[ DBA_078 ] DBA: GLOBAL INFORMATION ABOUT I/O                   |#| 
|#[ DBA_079 ] DBA: WHICH SEG. HAVE TOP LOGICAL I/O - PHYSICAL I/O     |#|[ DBA_080 ] DBA: VERIFY DBLINKS & FOLDERS INFO                  |#| 
|#[ DBA_081 ] DBA: IDENTIFYING WHEN A PASSWORD WAS LAST CHANGED       |#|[ DBA_082 ] DBA: VERIFY UNDO SEGMENTS                           |#| 
|#[ DBA_083 ] DBA: VERIFY ALL SQL STATEMENTS                          |#|[ DBA_084 ] DBA: CLONE USER COMMANDS [ @ ]                      |#| 
|#[ DBA_085 ] DBA: VERIFY ALL INFOS ABOUT SYSAUX                      |#|[ DBA_086 ] DBA: VERIFY ALL INFOS ABOUT I/O + LATENCY           |#| 
|#[ DBA_087 ] DBA: VERIFY MAIN TOP WAIT EVENTS PER WEEK               |#|[ DBA_088 ] DBA: VERIFY OBJECTS SIZE                            |#| 
|#[ DBA_089 ] DBA: GENERAL DATABASE OVERVIEW                          |#|[ DBA_090 ] DBA: DATABASE DASHBOARD                             |#| 
|#[ DBA_091 ] DBA: VERIFY ALL SQL IDS STATEMENTS                      |#|[ DBA_092 ] DBA: VERIFY NLS CONFIGURATION                       |#| 
|#[ DBA_093 ] DBA: VERIFY FAILED LOGIN                                |#|[ DBA_094 ] DBA: VERIFY ALL SQL IDS STATEMENTS                  |#|
|#[ DBA_095 ] DBA: VERIFY ALL PATCHES APPLIED                         |#|[ DBA_096 ] DBA: VERIFY CPU USAGE BY MINUTE                     |#|
|#[ DBA_097 ] DBA: VERIFY STANDBY CONFIGURATION                       |#|[ DBA_098 ] DBA: VERIFY GRANTS AND PERMISSIONS BY OWNER         |#|
|#[ DBA_099 ] DBA: USER DETAILS SESSIONS                              |#|[ DBA_100 ] DBA: VERIFY BACKUP RUNNING ON REAL TIME             |#|
|#[ DBA_101 ] DBA: VERIFY DATABASE COMPONENTS FROM REGISTRY           |#|[ DBA_102 ] DBA: VERIFY ORACLE NET SEND AND RECEIVE SIZE VOLUME |#|"




#########################################################################################################
# DATABASE SIZE
#########################################################################################################
#
function Func_DB_009()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_009
else
  Func_DB_NON_PDB_009
fi
}
# PDB
function Func_DB_PDB_009()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # DATABASE SIZE                                              #
prompt ##############################################################
col "SIZE MB" for a15
col "SIZE GB" for a15
col "SIZE TB" for a15
select to_char(sum(bytes)/1024/1024, '9G999G999D99') "SIZE MB"
  , to_char(sum(bytes)/1024/1024/1024, '9G999G999D99') "SIZE GB"
  , to_char(sum(bytes)/1024/1024/1024/1024, '9G999G999D999') "SIZE TB"
from (select sum(bytes) bytes from dba_data_files
union all
select sum(bytes) bytes from dba_temp_files
union all
select sum(bytes * members) from v\$log
union all
select sum(block_size * file_size_blks) from v\$controlfile);
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_009()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
prompt ##############################################################
prompt # DATABASE SIZE                                              #
prompt ##############################################################
col "SIZE MB" for a15
col "SIZE GB" for a15
col "SIZE TB" for a15
select to_char(sum(bytes)/1024/1024, '9G999G999D99') "SIZE MB"
  , to_char(sum(bytes)/1024/1024/1024, '9G999G999D99') "SIZE GB"
  , to_char(sum(bytes)/1024/1024/1024/1024, '9G999G999D999') "SIZE TB"
from (select sum(bytes) bytes from dba_data_files
union all
select sum(bytes) bytes from dba_temp_files
union all
select sum(bytes * members) from v\$log
union all
select sum(block_size * file_size_blks) from v\$controlfile);
quit;
EOF
}
#
#########################################################################################################
# VERIFY SESSIONS PER I/O
#########################################################################################################
#
function Func_DB_010()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_010
else
  Func_DB_NON_PDB_010
fi
}
# PDB
function Func_DB_PDB_010()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 2000 lines 2000 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # VERIFY SESSIONS PER I/O
prompt ##############################################################
col username for a25
col osuser for a25
select NVL(s.username, '(oracle)') AS username
  , s.osuser
  , s.sid
  , s.serial#
  , si.block_gets
  , si.consistent_gets
  , si.physical_reads
  , si.block_changes
  , si.consistent_changes
FROM v\$session s, v\$sess_io si
WHERE s.sid = si.sid
and s.osuser not in ('GRID','grid','ORACLE','oracle')
ORDER BY s.username, s.osuser, si.physical_reads;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_010()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 2000 lines 2000 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # VERIFY SESSIONS PER I/O
prompt ##############################################################
col username for a25
col osuser for a25
select NVL(s.username, '(oracle)') AS username
  , s.osuser
  , s.sid
  , s.serial#
  , si.block_gets
  , si.consistent_gets
  , si.physical_reads
  , si.block_changes
  , si.consistent_changes
FROM v\$session s, v\$sess_io si
WHERE s.sid = si.sid
and s.osuser not in ('GRID','grid','ORACLE','oracle')
ORDER BY s.username, s.osuser, si.physical_reads;
quit;
EOF
}
#
#########################################################################################################
# HIT RATIO THE LASTS 30 DAYS
#########################################################################################################
#
# NON PDB
function Func_DB_011()
{
sqlplus -S  '/ as sysdba' <<EOF
set feedback off timing off
exec dbms_application_info.set_action('latches');
set pages 700 lines 700 timing on feedback on colsep '|'
prompt ##############################################################
prompt # HIT RATIO THE LASTS 30 DAYS
prompt ##############################################################
col name for a40
col instance_name for a30
select instance_name
   , name
   , case when hit_ratio < 95 then 'Warning' when hit_ratio < 99 then 'Critical' end as hit_ratio
   , sleep_miss
from (select i.instance_name, l.name, round((gets-misses)/decode(gets,0,1,gets),3)*100 hit_ratio, round(sleeps/decode(misses,0,1,misses),3) sleep_miss
from gv\$latch l, gv\$instance i
where l.gets != 0
and l.inst_id = i.inst_id)
where hit_ratio < 100
order by hit_ratio;
quit;
EOF
}
#
#########################################################################################################
# VERIFY LONG OPERATIONS
#########################################################################################################
#
function Func_DB_012()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_012
else
  Func_DB_NON_PDB_012
fi
}
# PDB
function Func_DB_PDB_012()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # ACTIVE SESSIONS AND SQL STATEMENTS                         #
prompt ##############################################################
col USERNAME for a15
col "SID/SERIAL" for a15
col SQL_TEXT for a90
col machine for a35
col osuser for a15
select S.USERNAME
  , '( ' || s.sid || ',' || s.serial# || ' )' as "SID/SERIAL"
  , s.machine
  , s.osuser
  , s.seconds_in_wait as "waiting seg"
  , t.sql_id
  , sql_text
from v\$sqltext_with_newlines t, V\$SESSION s
where t.address = s.sql_address and t.hash_value = s.sql_hash_value and s.status = 'ACTIVE'
order by s.sid, t.piece;
prompt
prompt ##############################################################
prompt # LOCKED OBJECT ON LONG OPERATIONS                           #
prompt ##############################################################
col OBJECT_NAME for a30
select object_name
  , object_type
  , session_id
  , type
  , lmode
  , request
  , block
  , ctime
from v\$locked_object, all_objects, v\$lock
where v\$locked_object.object_id = all_objects.object_id 
and v\$lock.id1 = all_objects.object_id 
and v\$lock.sid = v\$locked_object.session_id
order by session_id, ctime desc, object_name;
prompt
prompt ##############################################################
prompt # OPERATION NAME, HOW LONG ARE RUNNING, MESSAGE              #
prompt ##############################################################
col OPNAME for a35
col TARGET for a20
col UNITS for a10
col MESSAGE for a100
col sql_id for a15
select distinct * from (select opname
                          , target
						  , sofar
						  , sql_id
						  , totalwork
						  , units
						  , elapsed_seconds
						  , message 
						from v\$session_longops 
						order by start_time desc) 
where rownum <= 10;
prompt
prompt ##############################################################
prompt # ??? #
prompt ##############################################################
col OPNAME for a35
col TARGET for a30
select opname
  , target
  , osuser
  , sl.sql_id
  , sl.sql_hash_value
  , elapsed_seconds
  , time_remaining
FROM v\$session_longops sl
inner join v\$session s ON sl.SID = s.SID AND sl.SERIAL# = s.SERIAL# WHERE time_remaining > 0;
prompt
prompt ##############################################################
prompt # ??? #
prompt ##############################################################
col USERNAME for a15
col sql_fulltext for a75
col TARGET for a20
select s.username
  , sl.sid
  , sq.executions
  , sl.last_update_time
  , sl.sql_id
  , sl.sql_hash_value
  , opname
  , target
  , elapsed_seconds
  , time_remaining
  , sq.sql_fulltext
FROM v\$session_longops sl
INNER JOIN v\$sql sq ON sq.sql_id = sl.sql_id
INNER JOIN v\$session s ON sl.SID = s.SID AND sl.serial# = s.serial#
WHERE time_remaining > 0;
prompt
prompt ##############################################################
prompt #  #
prompt ##############################################################
col sql_id for a15
col units for a15
col opname for a35
col started for a20
col now for a20
select sql_id
  , opname
  , to_char(start_time, 'DD/MM/YYYY HH24:MI:SS') as started
  , to_char(sysdate, 'DD/MM/YYYY HH24:MI:SS') as now
--  , trunc(((((86400*(sysdate-start_time))/60)/60)/24)/7) weeks
  , trunc((((86400*(sysdate-start_time))/60)/60)/24) days
  , trunc(((86400*(sysdate-start_time))/60)/60)-24*(trunc((((86400*(sysdate-start_time))/60)/60)/24)) hours
  , trunc((86400*(sysdate-start_time))/60)-60*(trunc(((86400*(sysdate-start_time))/60)/60)) minutes
  , trunc(86400*(sysdate-start_time))-60*(trunc((86400*(sysdate-start_time))/60)) seconds
  , sofar
  , totalwork
  , units
--  , round(elapsed_seconds/60/60,2) as seconds
  , round(time_remaining/60/60,2) as remaining
FROM v\$session_longops
WHERE sofar != totalwork;
quit;
EOF
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- Verify the SQL ID from Statements --"
Func_DB_SQLID
}
# NON PDB
function Func_DB_NON_PDB_012()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
prompt ##############################################################
prompt # ACTIVE SESSIONS AND SQL STATEMENTS                         #
prompt ##############################################################
col USERNAME for a15
col "SID/SERIAL" for a15
col SQL_TEXT for a90
col machine for a35
col osuser for a15
select S.USERNAME
  , '( ' || s.sid || ',' || s.serial# || ' )' as "SID/SERIAL"
  , s.machine
  , s.osuser
  , s.seconds_in_wait as "waiting seg"
  , t.sql_id
  , sql_text
from v\$sqltext_with_newlines t, V\$SESSION s
where t.address = s.sql_address and t.hash_value = s.sql_hash_value and s.status = 'ACTIVE'
order by s.sid, t.piece;
prompt
prompt ##############################################################
prompt # LOCKED OBJECT ON LONG OPERATIONS                           #
prompt ##############################################################
col OBJECT_NAME for a30
select object_name
  , object_type
  , session_id
  , type
  , lmode
  , request
  , block
  , ctime
from v\$locked_object, all_objects, v\$lock
where v\$locked_object.object_id = all_objects.object_id 
and v\$lock.id1 = all_objects.object_id 
and v\$lock.sid = v\$locked_object.session_id
order by session_id, ctime desc, object_name;
prompt
prompt ##############################################################
prompt # OPERATION NAME, HOW LONG ARE RUNNING, MESSAGE              #
prompt ##############################################################
col OPNAME for a35
col TARGET for a20
col UNITS for a10
col MESSAGE for a100
col sql_id for a15
select distinct * from (select opname
              , target
						  , sofar
						  , sql_id
						  , totalwork
						  , units
						  , elapsed_seconds
						  , message 
						from v\$session_longops 
						order by start_time desc) 
where rownum <= 10;
prompt
prompt ##############################################################
prompt # ??? #
prompt ##############################################################
col OPNAME for a35
col TARGET for a30
select opname
  , target
  , osuser
  , sl.sql_id
  , sl.sql_hash_value
  , elapsed_seconds
  , time_remaining
FROM v\$session_longops sl
inner join v\$session s ON sl.SID = s.SID AND sl.SERIAL# = s.SERIAL# WHERE time_remaining > 0;
prompt
prompt ##############################################################
prompt # ??? #
prompt ##############################################################
col USERNAME for a15
col sql_fulltext for a75
col TARGET for a20
select s.username
  , sl.sid
  , sq.executions
  , sl.last_update_time
  , sl.sql_id
  , sl.sql_hash_value
  , opname
  , target
  , elapsed_seconds
  , time_remaining
  , sq.sql_fulltext
FROM v\$session_longops sl
INNER JOIN v\$sql sq ON sq.sql_id = sl.sql_id
INNER JOIN v\$session s ON sl.SID = s.SID AND sl.serial# = s.serial#
WHERE time_remaining > 0;
prompt
prompt ##############################################################
prompt #  #
prompt ##############################################################
col sql_id for a15
col units for a15
col opname for a35
col started for a20
col now for a20
select sql_id
  , opname
  , to_char(start_time, 'DD/MM/YYYY HH24:MI:SS') as started
  , to_char(sysdate, 'DD/MM/YYYY HH24:MI:SS') as now
--  , trunc(((((86400*(sysdate-start_time))/60)/60)/24)/7) weeks
  , trunc((((86400*(sysdate-start_time))/60)/60)/24) days
  , trunc(((86400*(sysdate-start_time))/60)/60)-24*(trunc((((86400*(sysdate-start_time))/60)/60)/24)) hours
  , trunc((86400*(sysdate-start_time))/60)-60*(trunc(((86400*(sysdate-start_time))/60)/60)) minutes
  , trunc(86400*(sysdate-start_time))-60*(trunc((86400*(sysdate-start_time))/60)) seconds
  , sofar
  , totalwork
  , units
--  , round(elapsed_seconds/60/60,2) as seconds
  , round(time_remaining/60/60,2) as remaining
FROM v\$session_longops
WHERE sofar != totalwork;
quit;
EOF
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- Verify the SQL ID from Statements --"
Func_DB_SQLID
}
#
#########################################################################################################
# INVALIDS OBJECTS [ @ ]
#########################################################################################################
#
function Func_DB_013()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_013
else
  Func_DB_NON_PDB_013
fi
}
# PDB
function Func_DB_PDB_013()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # INVALIDS OBJECTS [ @ ]
prompt ##############################################################
prompt
col owner for a25
col OBJECT_TYPE for a25
col "Total of invalids objects." for a30
select owner
   , decode(object_type,null,'========================>', object_type) as "OBJECT_TYPE"
   , count(object_type) as "TOTAL"
   , decode(grouping(owner),0,null,1,'Total of invalids objects.') as " "
from dba_objects where status <> 'VALID'
group by rollup (owner, object_type)
order by owner, object_type desc;
quit;
EOF
Func_DB_Owner_Validate_Objects
}
# NON PDB
function Func_DB_NON_PDB_013()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # INVALIDS OBJECTS [ @ ]
prompt ##############################################################
col owner for a25
col OBJECT_TYPE for a25
col "Total of invalids objects." for a30
select owner
   , decode(object_type,null,'========================>', object_type) as "OBJECT_TYPE"
   , count(object_type) as "TOTAL"
   , decode(grouping(owner),0,null,1,'Total of invalids objects.') as " "
from dba_objects where status <> 'VALID'
group by rollup (owner, object_type)
order by owner, object_type desc;
quit;
EOF
Func_DB_Owner_Validate_Objects
}
#
#########################################################################################################
# JOBS CONTROL OF THE CLIENT [ @ ]
#########################################################################################################
#
function Func_DB_014()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_014
else
  Func_DB_NON_PDB_014
fi
}
# PDB
function Func_DB_PDB_014()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # JOBS CONTROL OF THE CLIENT [ @ ]
prompt ##############################################################
col COMMENTS for a120
col JOB_NAME for a30
col owner for a10
col state for a12
col SCHEDULE_TYPE for a16
col LAST_EXEC for a20
col enabled for a8
select JOB_NAME
 , STATE
 , ENABLED
 , PROGRAM_OWNER as OWNER
 , SCHEDULE_TYPE
 , RUN_COUNT
 , to_char(LAST_START_DATE, 'dd/mm/yyyy HH:MM:SS') as LAST_EXEC
 , COMMENTS
FROM DBA_SCHEDULER_JOBS
ORDER BY 1,2,3,4,5,6,7;
prompt
prompt ##############################################################
prompt # Show All Submited RDBMS Jobs
prompt ##############################################################
col proc format a50    heading 'Proc'
col job  format 99999  heading 'job#'
col subu format a10    heading 'Submiter' trunc
col lsd  format a10    heading 'Last|OK|Date'
col lst  format a5     heading 'Last|OK|Time'
col nrd  format a10    heading 'Next|Run|Date'
col nrt  format a5     heading 'Next|Run|Time'
col fail format 999    heading 'Errors'
col ok   format a2     heading 'OK'
select job
  , log_user as subu
  , what as proc
  , to_char(last_date,'MM/DD/YYYY') as lsd
  , substr(last_sec,1,5) as lst
  , to_char(next_date,'MM/DD/YYYY') as nrd
  , substr(next_sec,1,5) as nrt
  , failures as fail
  , decode(broken,'Y','N','Y') ok
from sys.dba_jobs;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_014()
{
sqlplus -S  '/ as sysdba' <<EOF
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|' numwidth 20
prompt ##############################################################
prompt # JOBS CONTROL OF THE CLIENT [ @ ]
prompt ##############################################################
col COMMENTS for a120
col JOB_NAME for a30
col owner for a10
col state for a12
col SCHEDULE_TYPE for a16
col LAST_EXEC for a20
col enabled for a8
select JOB_NAME
 , STATE
 , ENABLED
 , PROGRAM_OWNER as OWNER
 , SCHEDULE_TYPE
 , RUN_COUNT
 , to_char(LAST_START_DATE, 'dd/mm/yyyy HH:MM:SS') as LAST_EXEC
 , COMMENTS
FROM DBA_SCHEDULER_JOBS
ORDER BY 1,2,3,4,5,6,7;
prompt
prompt ##############################################################
prompt # Show All Submited RDBMS Jobs
prompt ##############################################################
col proc format a50    heading 'Proc'
col job  format 99999  heading 'job#'
col subu format a10    heading 'Submiter' trunc
col lsd  format a10    heading 'Last|OK|Date'
col lst  format a5     heading 'Last|OK|Time'
col nrd  format a10    heading 'Next|Run|Date'
col nrt  format a5     heading 'Next|Run|Time'
col fail format 999    heading 'Errors'
col ok   format a2     heading 'OK'
select job
  , log_user as subu
  , what as proc
  , to_char(last_date,'MM/DD/YYYY') as lsd
  , substr(last_sec,1,5) as lst
  , to_char(next_date,'MM/DD/YYYY') as nrd
  , substr(next_sec,1,5) as nrt
  , failures as fail
  , decode(broken,'Y','N','Y') ok
from sys.dba_jobs;
quit;
EOF
}
#
#########################################################################################################
# MATERIALIZEDS VIEWS DISABLED
#########################################################################################################
#
# NON PDB
function Func_DB_015()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
prompt ##############################################################
prompt # MATERIALIZEDS VIEWS DISABLED
prompt ##############################################################
col owner for a20
col type for a20
select owner
   , type
   , tablespace_name
   , round(sum(mb)) as mb
from (select owner,'mview' as type, tablespace_name, round(sum(bytes)/1024/1024) as mb from dba_segments where (owner,segment_name) in
     (select owner, mview_name from dba_mviews) group by owner, segment_type, tablespace_name
union
select owner
  , 'mview_log' as type
  , tablespace_name
  , round(sum(bytes)/1024/1024) as mb
from dba_segments
where (owner, segment_name) in
(select log_owner, log_table from dba_snapshot_logs)
group by owner, segment_type, tablespace_name
union
select owner
  , 'mview_index' as type
  , tablespace_name
  , round(sum(bytes)/1024/1024) as mb
from dba_segments
where (owner,segment_name) in
(select owner, index_name from dba_indexes where (owner,table_name) in
(select owner, mview_name from dba_mviews))
group by owner, segment_type, tablespace_name) t1
group by owner,type,tablespace_name;
quit;
EOF
}
#
#########################################################################################################
# VERIFY RUNNING JOBS
#########################################################################################################
#
function Func_DB_016()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_016
else
  Func_DB_NON_PDB_016
fi
}
# PDB
function Func_DB_PDB_016()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 1000 lines 700 timing on feedback on echo on heading on verify off colsep '|'
prompt
prompt ##############################################################
prompt # VERIFY RUNNING JOBS
prompt ##############################################################
col "Last Date" for a30
col "This Date" for a30
select a.job "Job"
  , a.sid
  , a.failures "Failures"
  , Substr(To_Char(a.last_date,'DD/MM/YYYY HH24:MI:SS'),1,20) "Last Date"
  , Substr(To_Char(a.this_date,'DD/MM/YYYY HH24:MI:SS'),1,20) "This Date"
FROM dba_jobs_running a;
SET VERIFY ON
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_016()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 1000 lines 500 timing on VERIFY OFF colsep '|'
prompt ##############################################################
prompt # VERIFY RUNNING JOBS
prompt ##############################################################
prompt
col "Last Date" for a30
col "This Date" for a30
select a.job "Job"
  , a.sid
  , a.failures "Failures"
  , Substr(To_Char(a.last_date,'DD/MM/YYYY HH24:MI:SS'),1,20) "Last Date"
  , Substr(To_Char(a.this_date,'DD/MM/YYYY HH24:MI:SS'),1,20) "This Date"
FROM dba_jobs_running a;
SET VERIFY ON
quit;
EOF
}
#
#########################################################################################################
# KILL A RUNNING SESSION [ @ ]
#########################################################################################################
#
function Func_DB_017()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_017
else
  Func_DB_NON_PDB_017
fi
}
# PDB
function Func_DB_PDB_017()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # KILL A RUNNING SESSION [ @ ]
prompt ##############################################################
col MACHINE for a30
col username for a25
col OSUSER for a30
col PROGRAM for a60
col "SID,SERIAL,@INST" for a20
select OSUSER
  , MACHINE
  , SID || ',' || SERIAL# || ',@' || INST_ID as "SID,SERIAL,@INST"
  , USERNAME
  , PROGRAM
from gv\$session
where osuser not in ('GRID','grid','ORACLE','oracle')
order by 1,2,3,5;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_017()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # KILL A RUNNING SESSION [ @ ]
prompt ##############################################################
col MACHINE for a30
col username for a25
col OSUSER for a30
col PROGRAM for a60
col "SID,SERIAL,@INST" for a20
select OSUSER
  , MACHINE
  , SID || ',' || SERIAL# || ',@' || INST_ID as "SID,SERIAL,@INST"
  , USERNAME
  , PROGRAM
from gv\$session
where osuser not in ('GRID','grid','ORACLE','oracle')
order by 1,2,3,5;
quit;
EOF
}
#
#########################################################################################################
# VERIFY PROFILE INFORMATION
#########################################################################################################
#
function Func_DB_018()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_018
else
  Func_DB_NON_PDB_018
fi
}
# PDB
function Func_DB_PDB_018()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}' ORDER BY CON_ID, NAME;
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # VERIFY PROFILE INFORMATION
prompt ##############################################################
COL RESOURCE_NAME FOR A40
COL LIMIT FOR A40
select resource_name, limit
from dba_profiles
order by 1,2;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_018()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
prompt ##############################################################
prompt # VERIFY PROFILE INFORMATION
prompt ##############################################################
prompt
COL RESOURCE_NAME FOR A40
COL LIMIT FOR A40
select resource_name, limit
from dba_profiles
order by 1,2;
quit;
EOF
}
#
#########################################################################################################
# BACKUP STATISTICS
#########################################################################################################
#
# NON PDB
function Func_DB_019()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
col STATUS format a30
col DURATION format a10
col INPUT_TYPE for a20
col OPTIMIZED for a10
col BACKUP_SIZE for a20
col BEGIN for a20
col END for a20
prompt ##############################################################
prompt # BACKUP STATISTICS
prompt ##############################################################
prompt
select * from (select INPUT_TYPE
    , STATUS
    , OPTIMIZED
    , to_char(START_TIME,'DD/MM/YYYY hh24:mi') as BEGIN
    , to_char(END_TIME,'DD/MM/YYYY hh24:mi') as END
    , TIME_TAKEN_DISPLAY as DURATION
    , d.OUTPUT_BYTES_DISPLAY as BACKUP_SIZE
from V\$RMAN_BACKUP_JOB_DETAILS d
where START_TIME > sysdate-30
-- and INPUT_TYPE = '${SRMAN_TYPE}'
-- and INPUT_TYPE in ('DB FULL', 'RECVR AREA', 'DB INCR', 'DATAFILE FULL', 'DATAFILE INCR', 'ARCHIVELOG', 'CONTROLFILE', 'SPFILE')
order by session_key, BEGIN desc);
quit;
EOF
}
#
#########################################################################################################
# QTD OF ARCHIVES PER HOUR
#########################################################################################################
#
# NON PDB
function Func_DB_020()
{
sqlplus -S  '/ as sysdba' <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 feedback off timing on colsep '|'
col 00 for a5
col 01 for a5
col 02 for a5
col 03 for a5
col 04 for a5
col 05 for a5
col 06 for a5
col 07 for a5
col 08 for a5
col 09 for a5
col 10 for a5
col 11 for a5
col 12 for a5
col 13 for a5
col 14 for a5
col 15 for a5
col 16 for a5
col 17 for a5
col 18 for a5
col 19 for a5
col 20 for a5
col 21 for a5
col 22 for a5
col 23 for a5
prompt ##############################################################
prompt # QTD OF ARCHIVES PER HOUR
prompt ##############################################################
select trunc(first_time) day
  , to_char(sum(decode(to_char(first_time,'HH24'),'00',1,0)), '9999') "00"
  , to_char(sum(decode(to_char(first_time,'HH24'),'01',1,0)), '9999') "01"
  , to_char(sum(decode(to_char(first_time,'HH24'),'02',1,0)), '9999') "02"
  , to_char(sum(decode(to_char(first_time,'HH24'),'03',1,0)), '9999') "03"
  , to_char(sum(decode(to_char(first_time,'HH24'),'04',1,0)), '9999') "04"
  , to_char(sum(decode(to_char(first_time,'HH24'),'05',1,0)), '9999') "05"
  , to_char(sum(decode(to_char(first_time,'HH24'),'06',1,0)), '9999') "06"
  , to_char(sum(decode(to_char(first_time,'HH24'),'07',1,0)), '9999') "07"
  , to_char(sum(decode(to_char(first_time,'HH24'),'08',1,0)), '9999') "08"
  , to_char(sum(decode(to_char(first_time,'HH24'),'09',1,0)), '9999') "09"
  , to_char(sum(decode(to_char(first_time,'HH24'),'10',1,0)), '9999') "10"
  , to_char(sum(decode(to_char(first_time,'HH24'),'11',1,0)), '9999') "11"
  , to_char(sum(decode(to_char(first_time,'HH24'),'12',1,0)), '9999') "12"
  , to_char(sum(decode(to_char(first_time,'HH24'),'13',1,0)), '9999') "13"
  , to_char(sum(decode(to_char(first_time,'HH24'),'14',1,0)), '9999') "14"
  , to_char(sum(decode(to_char(first_time,'HH24'),'15',1,0)), '9999') "15"
  , to_char(sum(decode(to_char(first_time,'HH24'),'16',1,0)), '9999') "16"
  , to_char(sum(decode(to_char(first_time,'HH24'),'17',1,0)), '9999') "17"
  , to_char(sum(decode(to_char(first_time,'HH24'),'18',1,0)), '9999') "18"
  , to_char(sum(decode(to_char(first_time,'HH24'),'19',1,0)), '9999') "19"
  , to_char(sum(decode(to_char(first_time,'HH24'),'20',1,0)), '9999') "20"
  , to_char(sum(decode(to_char(first_time,'HH24'),'21',1,0)), '9999') "21"
  , to_char(sum(decode(to_char(first_time,'HH24'),'22',1,0)), '9999') "22"
  , to_char(sum(decode(to_char(first_time,'HH24'),'23',1,0)), '9999') "23"
from gv\$log_history
where first_time > trunc(sysdate - 30)
and first_time < sysdate + 1
group by trunc(first_time)
order by 1;
quit;
EOF
}
#
#########################################################################################################
# LAST FILE OF LAST BACKUP ARCH - RMAN
#########################################################################################################
#
# NON PDB
function Func_DB_021()
{
sqlplus -S  '/ as sysdba' <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy hh24:mi';
set pages 700 lines 700 feedback off timing on colsep '|'
prompt ##############################################################
prompt # LAST FILE OF LAST BACKUP ARCH - RMAN
prompt ##############################################################
col PATH format a120
col tag format a25
col DEVICE format a10
col SIZE_BYTES_DISPLAY for a15
col BEGIN for a20
col END for a20
col STATUS for a20
select /*+ rule */ tag
  , device_type as DEVICE
  , handle as PATH
  , START_TIME as BEGIN
  , COMPLETION_TIME as END
  , rtrim(SIZE_BYTES_DISPLAY) as SIZE_BYTES_DISPLAY 
-- , status
from v\$backup_piece_details
where session_recid > (select max(session_recid) -10000 from V\$RMAN_BACKUP_JOB_DETAILS where START_TIME > sysdate-30 and input_type in('ARCHIVELOG') and status in ('COMPLETED','COMPLETED WITH WARNINGS'))
and START_TIME > sysdate-30
order by START_TIME;
quit;
EOF
}
#
#########################################################################################################
# LAST FILE OF LAST BACKUP FULL - RMAN
#########################################################################################################
#
# NON PDB
function Func_DB_022()
{
sqlplus -S  '/ as sysdba' <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy hh24:mi';
set pages 700 lines 700 feedback off timing on colsep '|'
prompt ##############################################################
prompt # LAST FILE OF LAST BACKUP FULL - RMAN
prompt ##############################################################
col PATH format a120
col tag format a25
col DEVICE format a10
col SIZE_BYTES_DISPLAY for a10
col BEGIN for a20
col END for a20
select /*+ rule */ tag
  , device_type as DEVICE
  , handle as PATH
  , START_TIME as BEGIN
  , COMPLETION_TIME as END
  , SIZE_BYTES_DISPLAY
from v\$backup_piece_details
where session_recid > (select max(session_recid) -10000 from V\$RMAN_BACKUP_JOB_DETAILS where START_TIME > sysdate-30 and input_type in('DB FULL', 'DB INCR') and status in ('COMPLETED','COMPLETED WITH WARNINGS'))
and START_TIME > sysdate-30
order by START_TIME;
quit;
EOF
}
#
#########################################################################################################
# ARCHIVES GENERATED PER DAY
#########################################################################################################
#
# NON PDB
function Func_DB_023()
{
sqlplus -S  '/ as sysdba' <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 feedback on timing on colsep '|'
prompt ##############################################################
prompt # ARCHIVES GENERATED PER DAY
prompt ##############################################################
col day for a20
col SIZE_MB for a20
col SIZE_GB for a20
col SIZE_TB for a20
select trunc(first_time) as day
  , to_char(sum(blocks * block_size)/1024/1024,'9G999G999D999') SIZE_MB
  , to_char(sum(blocks * block_size)/1024/1024/1024,'9G999G999D999') SIZE_GB
  , to_char(sum(blocks * block_size)/1024/1024/1024/1024,'9G999G999D999') SIZE_TB
from gv\$archived_log
where trunc(first_time) > sysdate -30
and trunc(first_time) < sysdate +1
group by trunc(first_time)
order by 1;
quit;
EOF
}
#
#########################################################################################################
# BACKUP LOG OF LAST BACKUP FULL - RMAN
#########################################################################################################
#
# NON PDB
function Func_DB_024()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 feedback off timing on colsep '|'
prompt ##############################################################
prompt # BACKUP LOG OF LAST BACKUP FULL - RMAN
prompt ##############################################################
select decode(status, 'COMPLETED', 0,1) as STATUS
  , case when decode(status, 'COMPLETED', 0,1) = 0 then 'Backup Not Running' else 'Backup Running' end as "Running Y/N"
from v\$RMAN_BACKUP_JOB_DETAILS
where session_key = (select max(session_key) from v\$RMAN_BACKUP_JOB_DETAILS where START_TIME > sysdate - 30 and input_type in('DB FULL', 'DB INCR','CONTROLFILE'));
quit;
EOF
echo ">------------------------------------------------------------------------------------------------------------"
echo " -- RMAN PROCESSES --"
echo ">------------------------------------------------------------------------------------------------------------"
ps -ef | grep rman | grep -v grep
}
#
#########################################################################################################
# BACKUP LOG OF LASTS ARCHIVES - RMAN
#########################################################################################################
#
# NON PDB
function Func_DB_025()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 feedback off timing on colsep '|'
prompt ##############################################################
prompt # BACKUP LOG OF LASTS ARCHIVES - RMAN
prompt ##############################################################
select decode(status, 'COMPLETED', 0,1) as STATUS
  , case when decode(status, 'COMPLETED', 0,1) = 0 then 'Backup Not Running' else 'Backup Running' end as "Running Y/N"
from v\$RMAN_BACKUP_JOB_DETAILS
where session_key = (select max(session_key) from v\$RMAN_BACKUP_JOB_DETAILS where START_TIME > sysdate - 30 and input_type in('ARCHIVELOG','CONTROLEFILE'));
quit;
EOF
echo ">------------------------------------------------------------------------------------------------------------"
echo " -- RMAN PROCESSES --"
echo ">------------------------------------------------------------------------------------------------------------"
ps -ef | grep rman | grep -v grep
}
#
#########################################################################################################
# ERRORS ON ALERT LOG FILE
#########################################################################################################
#
# NON PDB
function Func_DB_026()
{
sqlplus -S  '/ as sysdba' <<EOF
set feedback off timing off
var days_back number;
exec :days_back := 15;
set pages 3000 lines 3000 feedback off timing on colsep '|'
prompt ##############################################################
prompt # ERRORS ON ALERT LOG FILE
prompt ##############################################################
col "DATE_TIME" for a20
col host_address for a16
col MESSAGE_TEXT for a140
select to_char(ORIGINATING_TIMESTAMP, 'DD/MM/YYYY HH24:MI:SS') as "DATE_TIME", host_address, MESSAGE_TEXT
from sys.X\$DBGALERTEXT
where (lower(MESSAGE_TEXT) like '%ora-%' or lower(MESSAGE_TEXT) like '%error%' or lower(MESSAGE_TEXT) like '%checkpoint not complete%' or lower(MESSAGE_TEXT) like '%fail%')
and ORIGINATING_TIMESTAMP > sysdate-:days_back
order by ORIGINATING_TIMESTAMP;
col total for a80
prompt
prompt ##############################################################
select '[ GENERAL ERRORS ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where (lower(MESSAGE_TEXT) like '%error%' or lower(MESSAGE_TEXT) like '%checkpoint not complete%' or lower(MESSAGE_TEXT) like '%fail%')
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
select '[ ORACLE ERRORS ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where (lower(MESSAGE_TEXT) like '%ora-%' or lower(MESSAGE_TEXT) like '%error%' or lower(MESSAGE_TEXT) like '%fail%')
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
select '[ ORA-00600 ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where MESSAGE_TEXT like '%ORA-00600%'
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
select '[ ORA-00700 ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where MESSAGE_TEXT like '%ORA-00700%'
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
select '[ ORA-07445 ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where MESSAGE_TEXT like '%ORA-07445%'
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
quit;
EOF
}
#
#########################################################################################################
# ORACLE ENTERPRISE MANAGER ALERT
#########################################################################################################
#
# NON PDB
function Func_DB_027()
{
sqlplus -S  '/ as sysdba' <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 feedback off timing on colsep '|'
prompt ##############################################################
prompt # ORACLE ENTERPRISE MANAGER ALERT
prompt ##############################################################
col message_type for a30
col reason for a110
col date_alert for a20
col SUGGESTED_ACTION for a30
select to_char(TIME_SUGGESTED, 'dd/mm/yyyy hh24:mi') DATE_ALERT
  , message_type
  , reason
  , SUGGESTED_ACTION
FROM dba_outstanding_alerts
order by DATE_ALERT;
quit;
EOF
}
#
#########################################################################################################
# CAPTURE STATISTICS OF DATA DICTIONARY
#########################################################################################################
#
# NON PDB
function Func_DB_028()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
prompt ##############################################################
prompt # CAPTURE STATISTICS OF DATA DICTIONARY                      #
prompt # WAIT A MOMENT PLEASE, THE STATISTICS COLLECTION IS RUNNING #
prompt ##############################################################
-- begin
   exec DBMS_STATS.GATHER_DICTIONARY_STATS;
-- end;
-- /
quit;
EOF
}
#
# exec DBMS_STATS.SET_PARAM(AUTOSTATS_TARGET,'ORACLE');
# exec dbms_stats.gather_system_stats();
# exec dbms_stats.gather_system_stats('start');
# exec dbms_stats.gather_system_stats('stop');
# exec dbms_stats.gather_system_stats('interval',60);
# exec DBMS_STATS.GATHER_SCHEMA_STATS ('SYS');
#
#########################################################################################################
# CAPTURE STATISTICS OF ALL DATABASE
#########################################################################################################
#
# NON PDB
function Func_DB_029()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
prompt ##############################################################
prompt # CAPTURE STATISTICS OF ALL DATABASE                         #
Prompt # WAIT A MOMENT PLEASE, THE STATISTICS COLLECTION IS RUNNING #
prompt ##############################################################
-- begin
   exec DBMS_STATS.GATHER_DATABASE_STATS;
-- end;
-- /
quit;
EOF
}
#
#########################################################################################################
# BLOCKING LOCKS
#########################################################################################################
#
# NON PDB
function Func_DB_030()
{
sqlplus -S  '/ as sysdba' <<EOF
SET TERMOUT OFF TERMOUT ON ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 180 PAGESIZE 50000 TRIMSPOOL ON VERIFY OFF serveroutput ON FORMAT WRAPPED feedback OFF timing on
prompt ##############################################################
prompt # BLOCKING LOCKS
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
DECLARE
  CURSOR cur_BlockingLocks IS
    select iw.instance_name AS waiting_instance
      , sw.status AS waiting_status
      , lw.sid AS waiting_sid
      , sw.serial# AS waiting_serial_num
      , sw.username AS waiting_oracle_username
      , sw.osuser AS waiting_os_username
      , sw.machine AS waiting_machine
      , pw.spid AS waiting_spid
      , SUBSTR(sw.terminal,0, 39) AS waiting_terminal
      , SUBSTR(sw.program,0, 39) AS waiting_program
      , ROUND(lw.ctime/60) AS waiting_lock_time_min
      , DECODE (lh.type, 'CF', 'Control File', 'DX', 'Distributed Transaction', 'FS', 'File Set', 'IR', 'Instance Recovery', 'IS', 'Instance State', 'IV', 'Libcache Invalidation', 'LS', 'Log Start or Log Switch', 'MR', 'Media Recovery', 'RT', 'Redo Thread', 'RW', 'Row Wait', 'SQ', 'Sequence Number', 'ST', 'Diskspace Transaction', 'TE', 'Extend Table', 'TT', 'Temp Table', 'TX', 'Transaction', 'TM', 'DML', 'UL', 'PLSQL User_lock', 'UN', 'User Name', 'Nothing-'  ) AS waiter_lock_type
      , DECODE (lw.request, 0, 'None' /* Mon Lock equivalent */ , 1, 'NoLock' /* N */, 2, 'Row-Share (SS)' /* L */ , 3, 'Row-Exclusive (SX)' /* R */ , 4, 'Share-Table' /* S */ , 5, 'Share-Row-Exclusive (SSX)' /* C */ , 6, 'Exclusive' /* X */ , '[Nothing]' ) AS waiter_mode_request
      , ih.instance_name AS locking_instance
      , sh.status AS locking_status
      , lh.sid AS locking_sid
      , sh.serial# AS locking_serial_num
      , sh.username AS locking_oracle_username
      , sh.osuser AS locking_os_username
      , sh.machine AS locking_machine
      , ph.spid AS locking_spid
      , SUBSTR(sh.terminal,0, 39) AS locking_terminal
      , SUBSTR(sh.program,0, 39) AS locking_program
      , ROUND(lh.ctime/60) AS locking_lock_time_min
      , aw.sql_text AS waiting_sql_text
    FROM gv\$lock     lw
      , gv\$lock     lh
      , gv\$instance iw
      , gv\$instance ih
      , gv\$session  sw
      , gv\$session  sh
      , gv\$process  pw
      , gv\$process  ph
      , gv\$sqlarea  aw
    WHERE iw.inst_id  = lw.inst_id
    AND ih.inst_id  = lh.inst_id
    AND sw.inst_id  = lw.inst_id
    AND sh.inst_id  = lh.inst_id
    AND pw.inst_id  = lw.inst_id
    AND ph.inst_id  = lh.inst_id
    AND aw.inst_id  = lw.inst_id
    AND sw.sid      = lw.sid
    AND sh.sid      = lh.sid
    AND lh.id1      = lw.id1
    AND lh.id2      = lw.id2
    AND lh.request  = 0
    AND lw.lmode    = 0
    AND (lh.id1, lh.id2) IN ( select id1, id2 FROM gv\$lock WHERE request = 0 INTERSECT select id1, id2 FROM gv\$lock WHERE  lmode = 0)
    AND sw.paddr  = pw.addr (+)
    AND sh.paddr  = ph.addr (+)
    AND sw.sql_address  = aw.address
    ORDER BY iw.instance_name, lw.sid;
    TYPE t_BlockingLockRecord IS RECORD (
        WaitingInstanceName       VARCHAR2(16)
      , WaitingStatus             VARCHAR2(8)
      , WaitingSid                NUMBER
      , WaitingSerialNum          NUMBER
      , WaitingOracleUsername     VARCHAR2(30)
      , WaitingOSUsername         VARCHAR2(30)
      , WaitingMachine            VARCHAR2(64)
      , WaitingSpid               VARCHAR2(12)
      , WaitingTerminal           VARCHAR2(30)
      , WaitingProgram            VARCHAR2(48)
      , WaitingLockTimeMinute     NUMBER
      , WaiterLockType            VARCHAR2(30)
      , WaiterModeRequest         VARCHAR2(30)
      , LockingInstanceName       VARCHAR2(16)
      , LockingStatus             VARCHAR2(8)
      , LockingSid                NUMBER
      , LockingSerialNum          NUMBER
      , LockingOracleUsername     VARCHAR2(30)
      , LockingOSUsername         VARCHAR2(30)
      , LockingMachine            VARCHAR2(64)
      , LockingSpid               VARCHAR2(12)
      , LockingTerminal           VARCHAR2(30)
      , LockingProgram            VARCHAR2(48)
      , LockingLockTimeMinute     NUMBER
      , SQLText                   VARCHAR2(1000));
    TYPE t_BlockingLockRecordTable IS TABLE OF t_BlockingLockRecord INDEX BY BINARY_INTEGER;
    v_BlockingLockArray             t_BlockingLockRecordTable;
    v_BlockingLockRec               cur_BlockingLocks%ROWTYPE;
    v_NumBlockingLocksIncidents     BINARY_INTEGER := 0;
BEGIN
    DBMS_OUTPUT.ENABLE(1000000);
    OPEN cur_BlockingLocks;
    LOOP
        FETCH cur_BlockingLocks INTO v_BlockingLockRec;
        EXIT WHEN cur_BlockingLocks%NOTFOUND;
        v_NumBlockingLocksIncidents := v_NumBlockingLocksIncidents + 1;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingInstanceName      := v_BlockingLockRec.waiting_instance;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingStatus            := v_BlockingLockRec.waiting_status;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingSid               := v_BlockingLockRec.waiting_sid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingSerialNum         := v_BlockingLockRec.waiting_serial_num;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingOracleUsername    := v_BlockingLockRec.waiting_oracle_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingOSUsername        := v_BlockingLockRec.waiting_os_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingMachine           := v_BlockingLockRec.waiting_machine;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingSpid              := v_BlockingLockRec.waiting_spid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingTerminal          := v_BlockingLockRec.waiting_terminal;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingProgram           := v_BlockingLockRec.waiting_program;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingLockTimeMinute    := v_BlockingLockRec.waiting_lock_time_min;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaiterLockType           := v_BlockingLockRec.waiter_lock_type;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaiterModeRequest        := v_BlockingLockRec.waiter_mode_request;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingInstanceName      := v_BlockingLockRec.locking_instance;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingStatus            := v_BlockingLockRec.locking_status;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingSid               := v_BlockingLockRec.locking_sid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingSerialNum         := v_BlockingLockRec.locking_serial_num;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingOracleUsername    := v_BlockingLockRec.locking_oracle_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingOSUsername        := v_BlockingLockRec.locking_os_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingMachine           := v_BlockingLockRec.locking_machine;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingSpid              := v_BlockingLockRec.locking_spid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingTerminal          := v_BlockingLockRec.locking_terminal;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingProgram           := v_BlockingLockRec.locking_program;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingLockTimeMinute    := v_BlockingLockRec.locking_lock_time_min;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).SQLText                  := v_BlockingLockRec.waiting_sql_text;
    END LOOP;
    CLOSE cur_BlockingLocks;
    DBMS_OUTPUT.PUT_LINE('Number of blocking lock incidents: ' || v_BlockingLockArray.COUNT);
    DBMS_OUTPUT.PUT(chr(10));
    FOR RowIndex IN 1 .. v_BlockingLockArray.COUNT
    LOOP
        DBMS_OUTPUT.PUT_LINE('Incident ' || RowIndex);
        DBMS_OUTPUT.PUT_LINE('---');
        DBMS_OUTPUT.PUT_LINE('                        WAITING                                  BLOCKING');
        DBMS_OUTPUT.PUT_LINE('                        ---------------------------------------- ----------------------------------------');
        DBMS_OUTPUT.PUT_LINE('Instance Name         : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingInstanceName, 41)   || v_BlockingLockArray(RowIndex).LockingInstanceName);
        DBMS_OUTPUT.PUT_LINE('Oracle SID            : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingSid, 41)            || v_BlockingLockArray(RowIndex).LockingSid);
        DBMS_OUTPUT.PUT_LINE('Serial#               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingSerialNum, 41)      || v_BlockingLockArray(RowIndex).LockingSerialNum);
        DBMS_OUTPUT.PUT_LINE('Oracle User           : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingOracleUsername, 41) || v_BlockingLockArray(RowIndex).LockingOracleUsername);
        DBMS_OUTPUT.PUT_LINE('O/S User              : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingOSUsername, 41)     || v_BlockingLockArray(RowIndex).LockingOSUsername);
        DBMS_OUTPUT.PUT_LINE('Machine               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingMachine, 41)        || v_BlockingLockArray(RowIndex).LockingMachine);
        DBMS_OUTPUT.PUT_LINE('O/S PID               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingSpid, 41)           || v_BlockingLockArray(RowIndex).LockingSpid);
        DBMS_OUTPUT.PUT_LINE('Terminal              : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingTerminal, 41)       || v_BlockingLockArray(RowIndex).LockingTerminal);
        DBMS_OUTPUT.PUT_LINE('Lock Time             : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingLockTimeMinute      || ' minutes', 41) || v_BlockingLockArray(RowIndex).LockingLockTimeMinute ||' minutes');
        DBMS_OUTPUT.PUT_LINE('Status                : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingStatus, 41)         || v_BlockingLockArray(RowIndex).LockingStatus);
        DBMS_OUTPUT.PUT_LINE('Program               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingProgram, 41)        || v_BlockingLockArray(RowIndex).LockingProgram);
        DBMS_OUTPUT.PUT_LINE('Waiter Lock Type      : ' || v_BlockingLockArray(RowIndex).WaiterLockType);
        DBMS_OUTPUT.PUT_LINE('Waiter Mode Request   : ' || v_BlockingLockArray(RowIndex).WaiterModeRequest);
        DBMS_OUTPUT.PUT_LINE('Waiting SQL           : ' || v_BlockingLockArray(RowIndex).SQLText);
        DBMS_OUTPUT.PUT(chr(10));
    END LOOP;
END;
/
quit;
EOF
}
#
#########################################################################################################
# LOCKED OBJECTS
#########################################################################################################
#
# NON PDB
function Func_DB_031()
{
sqlplus -S  '/ as sysdba' <<EOF
SET ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 500 PAGESIZE 50000 TERMOUT ON TIMING OFF TRIMOUT ON TRIMSPOOL ON VERIFY OFF timing on
prompt ##############################################################
prompt # LOCKED OBJECTS
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
COLUMN instance_name                FORMAT a9           HEADING 'Instance'
COLUMN sid                          FORMAT 999999       HEADING 'SID'
COLUMN sid_serial                   FORMAT a20          HEADING 'SID / Serial#'
COLUMN session_status               FORMAT a9           HEADING 'Status'
COLUMN locking_oracle_user          FORMAT a20          HEADING 'Locking Oracle User'
COLUMN object_owner                 FORMAT a20          HEADING 'Object Owner'
COLUMN object_name                  FORMAT a30          HEADING 'Object Name'
COLUMN object_type                  FORMAT a25          HEADING 'Object Type'
COLUMN locked_mode                  FORMAT a35          HEADING 'Locked Mode'
CLEAR BREAKS
select i.instance_name                    instance_name
  , l.session_id || ' / ' || s.serial#    sid_serial
  , s.status                              session_status
  , l.oracle_username                     locking_oracle_user
  , o.owner                               object_owner
  , o.object_name                         object_name
  , o.object_type                         object_type
  , DECODE (   l.locked_mode
             , 0, 'None'                        /* Mon Lock equivalent */
             , 1, 'NoLock'                      /* N */
             , 2, 'Row-Share (SS)'              /* L */
             , 3, 'Row-Exclusive (SX)'          /* R */
             , 4, 'Share-Table'                 /* S */
             , 5, 'Share-Row-Exclusive (SSX)'   /* C */
             , 6, 'Exclusive'                   /* X */
             ,    '[Nothing]' )                 locked_mode
FROM dba_objects       o
  , gv\$session        s
  , gv\$locked_object  l
  , gv\$instance       i
WHERE i.inst_id     = l.inst_id
  AND s.inst_id     = l.inst_id
  AND s.sid         = l.session_id
  AND o.object_id   = l.object_id
ORDER BY i.instance_name, l.session_id;
quit;
EOF
}
#
#########################################################################################################
# BLOCKING LOCKS [ SUMARY ]
#########################################################################################################
#
# NON PDB
function Func_DB_032()
{
sqlplus -S  '/ as sysdba' <<EOF
SET TERMOUT OFF TERMOUT ON ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 256 PAGESIZE 50000 TERMOUT ON TIMING ON TRIMOUT ON TRIMSPOOL ON VERIFY OFF timing on
prompt ##############################################################
prompt # BLOCKING LOCKS [ SUMARY ]
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
COLUMN waiting_instance_sid_serial  FORMAT a24          HEADING '[WAITING]|Instance - SID / Serial#'
COLUMN waiting_oracle_username      FORMAT a20          HEADING '[WAITING]|Oracle User'
COLUMN waiting_pid                  FORMAT a11          HEADING '[WAITING]|PID'
COLUMN waiting_machine              FORMAT a15          HEADING '[WAITING]|Machine'   TRUNC
COLUMN waiting_os_username          FORMAT a15          HEADING '[WAITING]|O/S User'
COLUMN waiter_lock_type_mode_req    FORMAT a35          HEADING 'Waiter Lock Type / Mode Requested'
COLUMN waiting_lock_time_min        FORMAT a10          HEADING '[WAITING]|Lock Time'
COLUMN waiting_instance_sid         FORMAT a15          HEADING '[WAITING]|Instance - SID'
COLUMN waiting_sql_text             FORMAT a105         HEADING '[WAITING]|SQL Text'    WRAP
COLUMN locking_instance_sid_serial  FORMAT a24          HEADING '[LOCKING]|Instance - SID / Serial#'
COLUMN locking_oracle_username      FORMAT a20          HEADING '[LOCKING]|Oracle User'
COLUMN locking_oracle_program       FORMAT a25          HEADING '[LOCKING]|Oracle Program'
COLUMN locking_pid                  FORMAT a11          HEADING '[LOCKING]|PID'
COLUMN locking_machine              FORMAT a15          HEADING '[LOCKING]|Machine'   TRUNC
COLUMN locking_os_username          FORMAT a15          HEADING '[LOCKING]|O/S User'
COLUMN locking_lock_time_min        FORMAT a10          HEADING '[LOCKING]|Lock Time'
COLUMN instance_name                FORMAT a8           HEADING 'Instance'
COLUMN sid                          FORMAT 999999       HEADING 'SID'
COLUMN session_status               FORMAT a9           HEADING 'Status'
COLUMN locking_oracle_user          FORMAT a20          HEADING 'Locking Oracle User'
COLUMN locking_os_user              FORMAT a20          HEADING 'Locking O/S User'
COLUMN locking_os_pid               FORMAT a11          HEADING 'Locking PID'
COLUMN locking_machine              FORMAT a15          HEADING 'Locking Machine'   TRUNC
COLUMN object_owner                 FORMAT a15          HEADING 'Object Owner'
COLUMN object_name                  FORMAT a25          HEADING 'Object Name'
COLUMN object_type                  FORMAT a15          HEADING 'Object Type'
COLUMN locked_mode                                      HEADING 'Locked Mode'
CLEAR BREAKS
select iw.instance_name || ' - ' || lw.sid || ' / ' || sw.serial#  waiting_instance_sid_serial
  , sw.username                                               waiting_oracle_username
  , ROUND(lw.ctime/60) || ' min.'                             waiting_lock_time_min
  , DECODE (   lh.type
             , 'CF', 'Control File'
             , 'DX', 'Distributed Transaction'
             , 'FS', 'File Set'
             , 'IR', 'Instance Recovery'
             , 'IS', 'Instance State'
             , 'IV', 'Libcache Invalidation'
             , 'LS', 'Log Start or Log Switch'
             , 'MR', 'Media Recovery'
             , 'RT', 'Redo Thread'
             , 'RW', 'Row Wait'
             , 'SQ', 'Sequence Number'
             , 'ST', 'Diskspace Transaction'
             , 'TE', 'Extend Table'
             , 'TT', 'Temp Table'
             , 'TX', 'Transaction'
             , 'TM', 'DML'
             , 'UL', 'PLSQL User_lock'
             , 'UN', 'User Name'
             , 'Nothing-' ) || ' / ' || DECODE ( lw.request
             , 0, 'None'                        /* Mon Lock equivalent */
             , 1, 'NoLock'                      /* N */
             , 2, 'Row-Share (SS)'              /* L */
             , 3, 'Row-Exclusive (SX)'          /* R */
             , 4, 'Share-Table'                 /* S */
             , 5, 'Share-Row-Exclusive (SSX)'   /* C */
             , 6, 'Exclusive'                   /* X */
             ,    '[Nothing]' )                                         waiter_lock_type_mode_req
  , ih.instance_name || ' - ' || lh.sid || ' / ' || sh.serial#          locking_instance_sid_serial
  , sh.username                                                         locking_oracle_username
  , sh.program                                                          locking_oracle_program
  , ROUND(lh.ctime/60) || ' min.'                                       locking_lock_time_min
FROM gv\$lock     lw
  , gv\$lock     lh
  , gv\$instance iw
  , gv\$instance ih
  , gv\$session  sw
  , gv\$session  sh
WHERE iw.inst_id  = lw.inst_id
  AND ih.inst_id  = lh.inst_id
  AND sw.inst_id  = lw.inst_id
  AND sh.inst_id  = lh.inst_id
  AND sw.sid      = lw.sid
  AND sh.sid      = lh.sid
  AND lh.id1      = lw.id1
  AND lh.id2      = lw.id2
  AND lh.request  = 0
  AND lw.lmode    = 0
  AND (lh.id1, lh.id2) IN (select id1, id2 FROM gv\$lock WHERE request = 0 INTERSECT select id1, id2 FROM gv\$lock WHERE lmode = 0)
ORDER BY iw.instance_name, lw.sid;
quit;
EOF
}
#
#########################################################################################################
# BLOCKING LOCKS [ USER DETAILS ]
#########################################################################################################
#
# NON PDB
function Func_DB_033()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
prompt ##############################################################
prompt # BLOCKING LOCKS [ USER DETAILS ]
prompt ##############################################################
col waiting_instance_sid_serial for a30
col waiting_oracle_username for a15
col waiting_os_username for a15
col waiting_machine for a40
col waiting_pid for a10
col locking_instance_sid_serial for a30
col locking_oracle_username for a25
col locking_os_username for a20
col locking_machine for a20
col loocking_program for a20
col locking_pid for a10
select iw.instance_name || ' - ' || lw.sid || ' / ' || sw.serial#  waiting_instance_sid_serial
  , sw.username                                                    waiting_oracle_username
  , sw.osuser                                                      waiting_os_username
  , sw.machine                                                     waiting_machine
  , pw.spid                                                        waiting_pid
  , ih.instance_name || ' - ' || lh.sid || ' / ' || sh.serial#     locking_instance_sid_serial
  , sh.username                                                    locking_oracle_username
  , sh.osuser                                                      locking_os_username
  , sh.machine                                                     locking_machine
  , sh.program                                                     loocking_program
  , ph.spid                                                        locking_pid
FROM gv\$lock    lw
  , gv\$lock     lh
  , gv\$instance iw
  , gv\$instance ih
  , gv\$session  sw
  , gv\$session  sh
  , gv\$process  pw
  , gv\$process  ph
WHERE iw.inst_id  = lw.inst_id
  AND ih.inst_id  = lh.inst_id
  AND sw.inst_id  = lw.inst_id
  AND sh.inst_id  = lh.inst_id
  AND pw.inst_id  = lw.inst_id
  AND ph.inst_id  = lh.inst_id
  AND sw.sid      = lw.sid
  AND sh.sid      = lh.sid
  AND lh.id1      = lw.id1
  AND lh.id2      = lw.id2
  AND lh.request  = 0
  AND lw.lmode    = 0
  AND (lh.id1, lh.id2) IN (select id1, id2 FROM gv\$lock WHERE request = 0 INTERSECT select id1,id2 FROM gv\$lock WHERE lmode = 0)
  AND sw.paddr  = pw.addr (+)
  AND sh.paddr  = ph.addr (+)
ORDER BY iw.instance_name, lw.sid;
quit;
EOF
}
#
#########################################################################################################
# BLOCKING LOCKS [ WAITING SQL ]
#########################################################################################################
#
# NON PDB
function Func_DB_034()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
prompt ##############################################################
prompt # BLOCKING LOCKS [ WAITING SQL ]
prompt ##############################################################
select iw.instance_name || ' - ' || lw.sid || ' / ' || sw.serial#  waiting_instance_sid_serial
  , aw.sql_text                                                    waiting_sql_text
FROM gv\$lock     lw
  , gv\$lock     lh
  , gv\$instance iw
  , gv\$instance ih
  , gv\$session  sw
  , gv\$session  sh
  , gv\$sqlarea  aw
WHERE iw.inst_id  = lw.inst_id
  AND ih.inst_id  = lh.inst_id
  AND sw.inst_id  = lw.inst_id
  AND sh.inst_id  = lh.inst_id
  AND aw.inst_id  = lw.inst_id
  AND sw.sid      = lw.sid
  AND sh.sid      = lh.sid
  AND lh.id1      = lw.id1
  AND lh.id2      = lw.id2
  AND lh.request  = 0
  AND lw.lmode    = 0
  AND (lh.id1, lh.id2) IN (select id1, id2 FROM gv\$lock WHERE request = 0 INTERSECT select id1, id2 FROM gv\$lock WHERE lmode = 0)
  AND sw.sql_address  = aw.address
ORDER BY iw.instance_name, lw.sid;
quit;
EOF
}
#
#########################################################################################################
# LOCKED OBJECTS [ DETAILS ]
#########################################################################################################
#
# NON PDB
function Func_DB_035()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 1000 lines 1000 timing on
prompt ##############################################################
prompt # LOCKED OBJECTS [ DETAILS ]
prompt ##############################################################
col INSTANCE for a10
col status for a10
col OBJECT_NAME for a30
col MACHINE for a30
col oracle_user for a15
col OS_USER for a15
col PROGRAM for a25
col USER for a10
col OWNER for a15
col OS_PID for a8
col LOCKED_MODE for a20
col OBJECT_TYPE for a15
col OBJECT_OWNER for a15
col LOCKING_OS_PID for a8
col LOCKING_OS_USER for a20
select i.instance_name        instance
  , l.session_id              sid
  , s.status                  status
  , l.oracle_username         oracle_user
  , o.owner                   owner
  , s.osuser                  os_user
  , s.machine                 machine
  , p.spid                    os_pid
  , o.object_name             object_name
  , o.object_type             object_type
  , s.program                 program
  , DECODE (   l.locked_mode
             , 0, 'None'                        /* Mon Lock equivalent */
             , 1, 'NoLock'                      /* N */
             , 2, 'Row-Share (SS)'              /* L */
             , 3, 'Row-Exclusive (SX)'          /* R */
             , 4, 'Share-Table'                 /* S */
             , 5, 'Share-Row-Exclusive (SSX)'   /* C */
             , 6, 'Exclusive'                   /* X */
             ,    '[Nothing]')                  locked_mode
FROM dba_objects       o
  , gv\$session        s
  , gv\$process        p
  , gv\$locked_object  l
  , gv\$instance       i
WHERE i.inst_id     = l.inst_id
  AND s.inst_id     = l.inst_id
  AND s.inst_id     = p.inst_id
  AND s.sid         = l.session_id
  AND o.object_id   = l.object_id
  AND s.paddr       = p.addr
ORDER BY i.instance_name, l.session_id;
quit;
EOF
}
#
#########################################################################################################
# DML AND DDL LOCKS
#########################################################################################################
#
# NON PDB
function Func_DB_036()
{
sqlplus -S  '/ as sysdba' <<EOF
SET TERMOUT OFF TERMOUT ON ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 256 PAGESIZE 50000 TERMOUT ON TRIMOUT ON TRIMSPOOL ON VERIFY OFF timing on
prompt ##############################################################
prompt # DML AND DDL LOCKS
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
COLUMN instance_name         FORMAT a9        HEADING 'Instance'
COLUMN sid_serial            FORMAT a15       HEADING 'SID / Serial#'
COLUMN session_status        FORMAT a9        HEADING 'Status'
COLUMN locking_oracle_user   FORMAT a20       HEADING 'Locking Oracle User'
COLUMN lock_type             FORMAT a9        HEADING 'Lock Type'
COLUMN mode_held             FORMAT a10       HEADING 'Mode Held'
COLUMN object                FORMAT a42       HEADING 'Object'
COLUMN program               FORMAT a20       HEADING 'Program'
COLUMN wait_time_sec         FORMAT 999,999   HEADING 'Wait Time (sec)'
COLUMN wait_time_min         FORMAT 999,999   HEADING 'Wait Time (min)'
COLUMN wait_time_hour        FORMAT 999,999   HEADING 'Wait Time (hour)'
CLEAR BREAKS
select i.instance_name                   instance_name
  , l.session_id || ' / ' || s.serial#   sid_serial
  , s.status                             session_status
  , s.username                           locking_oracle_user
  , l.lock_type                          lock_type
  , l.mode_held                          mode_held
  , o.owner || '.' || o.object_name      object
  , SUBSTR(s.program, 0, 20)             program
  , ROUND(w.seconds_in_wait, 2)          wait_time_sec
  , ROUND(w.seconds_in_wait/60, 2)       wait_time_min
  , ROUND(w.seconds_in_wait/60/60, 2)       wait_time_hour
FROM v\$instance      i
   , v\$session       s
   , dba_locks        l
   , dba_objects      o
   , v\$session_wait  w
WHERE s.sid = l.session_id
AND l.lock_type IN ('DML','DDL')
AND l.lock_id1 = o.object_id
AND l.session_id = w.sid
ORDER BY i.instance_name, l.session_id;
quit;
EOF
}
#
#########################################################################################################
# DML TABLE LOCKS TIME
#########################################################################################################
#
# NON PDB
function Func_DB_037()
{
sqlplus -S  '/ as sysdba' <<EOF
SET TERMOUT ON TERMOUT ON ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 256 PAGESIZE 50000 TERMOUT ON TIMING ON TRIMOUT ON TRIMSPOOL ON VERIFY OFF timing on
prompt ##############################################################
prompt # DML TABLE LOCKS TIME
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
COLUMN instance_name                FORMAT a9           HEADING 'Instance'
COLUMN locking_oracle_user          FORMAT a20          HEADING 'Locking Oracle User'
COLUMN sid_serial                   FORMAT a15          HEADING 'SID / Serial#'
COLUMN mode_held                    FORMAT a15          HEADING 'Mode Held'
COLUMN mode_requested               FORMAT a15          HEADING 'Mode Requested'
COLUMN lock_type                    FORMAT a15          HEADING 'Lock Type'
COLUMN object                       FORMAT a42          HEADING 'Object'
COLUMN program                      FORMAT a20          HEADING 'Program'
COLUMN lock_time_min                FORMAT 999,999      HEADING 'Lock Time (min)'
COLUMN lock_time_hours              FORMAT 999,999      HEADING 'Lock Time (hours)'
COLUMN lock_time_days               FORMAT 999,999      HEADING 'Lock Time (days)'
CLEAR BREAKS
select i.instance_name instance_name
  , l.sid || ' / ' || s.serial# sid_serial
  , s.username locking_oracle_user
  , DECODE(   l.lmode
            , 1, NULL
            , 2, 'Row Share'
            , 3, 'Row Exclusive'
            , 4, 'Share'
            , 5, 'Share Row Exclusive'
            , 6, 'Exclusive'
            ,    'None') mode_held
  , DECODE(   l.request
            , 1, NULL
            , 2, 'Row Share'
            , 3, 'Row Exclusive'
            , 4, 'Share'
            , 5, 'Share Row Exclusive'
            , 6, 'Exclusive'
            ,    'None') mode_requested
  , DECODE (   l.type
             , 'CF', 'Control File'
             , 'DX', 'Distributed Transaction'
             , 'FS', 'File Set'
             , 'IR', 'Instance Recovery'
             , 'IS', 'Instance State'
             , 'IV', 'Libcache Invalidation'
             , 'LS', 'Log Start or Log Switch'
             , 'MR', 'Media Recovery'
             , 'RT', 'Redo Thread'
             , 'RW', 'Row Wait'
             , 'SQ', 'Sequence Number'
             , 'ST', 'Diskspace Transaction'
             , 'TE', 'Extend Table'
             , 'TT', 'Temp Table'
             , 'TX', 'Transaction'
             , 'TM', 'DML'
             , 'UL', 'PLSQL User_lock'
             , 'UN', 'User Name'
             ,       'Nothing'
           ) lock_type
  , o.owner || '.' || o.object_name object
  , ROUND(l.ctime/60, 2) lock_time_min
  , ROUND(l.ctime/60/60, 2) lock_time_hours
  , ROUND(l.ctime/60/60/24, 2) lock_time_days
FROM v\$instance    i
   , v\$session     s
   , v\$lock        l
   , dba_objects    o
   , dba_tables     t
WHERE l.id1            =  o.object_id
  AND s.sid            =  l.sid
  AND o.owner          =  t.owner
  AND o.object_name    =  t.table_name
  AND o.owner          <> 'SYS'
  AND l.type           =  'TM'
ORDER BY i.instance_name, l.sid;
quit;
EOF
}
#
#########################################################################################################
# VERIFY SESSIONS [ @ ]
#########################################################################################################
#
function Func_DB_038()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_038
else
  Func_DB_NON_PDB_038
fi
}
# PDB
function Func_DB_PDB_038()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # VERIFY SESSIONS [ @ ]
prompt ##############################################################
col MACHINE for a45
col OSUSER for a25
col EVENT for a30
col PROGRAM for a60
col username for a20
select SERIAL#
  , USERNAME
  , MACHINE
  , OSUSER
  , SID
  , event
  , PROGRAM
from v\$session
where osuser not in ('GRID','grid','ORACLE','oracle')
order by 1,2,5,6;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_038()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 2000 lines 700 timing on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY SESSIONS [ @ ]
prompt ##############################################################
col MACHINE for a45
col OSUSER for a25
col EVENT for a30
col PROGRAM for a60
col username for a20
select SERIAL#
  , USERNAME
  , MACHINE
  , OSUSER
  , SID
  , event
  , PROGRAM
from v\$session
where osuser not in ('GRID','grid','ORACLE','oracle')
order by 1,2,5,6;
quit;
EOF
}
#
#########################################################################################################
# TOP 20 DATABASE SESSIONS
#########################################################################################################
#
function Func_DB_039()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_039
else
  Func_DB_NON_PDB_039
fi
}
# PDB
function Func_DB_PDB_039()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # TOP 20 DATABASE SESSIONS
prompt ##############################################################
col rank form 99
col sql_id for a15
col MACHINE for a30
col event for a30
col username for a25
col OSUSER for a25
col PROGRAM for a40
select rownum as rank
  , a.sid
  , a.serial#
  , a.sql_id
  , a.username
  , a.osuser
  , a.machine
  , a.program
--  , a.event
  , a.CPUMins
  , a.CPUHours
  , a.CPUDays
from (select v.sid
        , serial#
	, sql_id
        , username
        , osuser
        , machine
        , program
--	, event
        , round(v.value/(100*60), 0) CPUMins
	, round(v.value/60/60)/100 CPUHours
	, round(v.value/60/60/24)/100 CPUDays
        FROM gv\$statname s, gv\$sesstat v, gv\$session sess
        WHERE s.name = 'CPU used by this session'
          and sess.sid = v.sid
          and v.statistic# = s.statistic#
          and v.value > 0
      ORDER BY v.value DESC) a
where rownum < 21
and osuser not in ('GRID','grid','ORACLE','oracle');
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_039()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # TOP 20 DATABASE SESSIONS
prompt ##############################################################
col rank form 99
col sql_id for a15
col MACHINE for a30
col event for a30
col username for a25
col OSUSER for a25
col PROGRAM for a40
select rownum as rank
  , a.sid
  , a.serial#
  , a.sql_id
  , a.username
  , a.osuser
  , a.machine
  , a.program
--  , a.event
  , a.CPUMins
  , a.CPUHours
  , a.CPUDays
from (select v.sid
        , serial#
	, sql_id
        , username
        , osuser
        , machine
        , program
--	, event
        , round(v.value/(100*60), 0) CPUMins
	, round(v.value/60/60)/100 CPUHours
	, round(v.value/60/60/24)/100 CPUDays
        FROM gv\$statname s, gv\$sesstat v, gv\$session sess
        WHERE s.name = 'CPU used by this session'
          and sess.sid = v.sid
          and v.statistic# = s.statistic#
          and v.value > 0
      ORDER BY v.value DESC) a
where rownum < 21
and osuser not in ('GRID','grid','ORACLE','oracle');
quit;
EOF
}
#
#########################################################################################################
# VERIFY TABLESPACES
#########################################################################################################
#
function Func_DB_040()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_040
else
  Func_DB_NON_PDB_040
fi
}
# PDB
function Func_DB_PDB_040()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off colsep '|'
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt
prompt ##############################################################
prompt # Tablespaces                                                #
prompt ##############################################################
col "USAGE (%)"          for a9
col "FREE (%)"           for a9
col Tablespace           for a30
col "Type"               for a12
col "USED USAGE"         for a12
col "FREE USAGE"         for a12
col "USED SIZE(MB)"      for a12
col "USED SIZE(GB)"      for a12
col "USED SIZE(TB)"      for a12
col "FREE SIZE(MB)"      for a12
col "FREE SIZE(GB)"      for a12
col "FREE SIZE(TB)"      for a12
col "MAX SIZE"           for a12
col "Status"             for a7
col "Status Size"        for a13
column "USED SIZE(MB)"   format 9g999g999g990 heading  'USED SIZE(MB)'
column "USED SIZE(GB)"   format 9g999g999g990 heading  'USED SIZE(GB)'
column "USED SIZE(TB)"   format 9g999g999g990 heading  'USED SIZE(TB)'
column "FREE SIZE(MB)"   format 9g999g999g990 heading  'FREE SIZE(MB)'
column "FREE SIZE(GB)"   format 9g999g999g990 heading  'FREE SIZE(GB)'
column "FREE SIZE(TB)"   format 9g999g999g990 heading  'FREE SIZE(TB)'
column "TOTAL SIZE(MB)"  format 9g999g999g990 heading  'TOTAL SIZE(MB)'
column "TOTAL SIZE(GB)"  format 9g999g999g990 heading  'TOTAL SIZE(GB)'
column "TOTAL SIZE(TB)"  format 9g999g999g990 heading  'TOTAL SIZE(TB)'
column "MAX SIZE(GB)"    format 9g999g999g990 heading  'MAX SIZE(GB)'
break on report
compute sum of "USED SIZE(MB)"   on report
compute sum of "USED SIZE(GB)"   on report
compute sum of "USED SIZE(TB)"   on report
compute sum of "FREE SIZE(MB)"   on report
compute sum of "FREE SIZE(GB)"   on report
compute sum of "FREE SIZE(TB)"   on report
compute sum of "TOTAL SIZE(MB)"  on report
compute sum of "TOTAL SIZE(GB)"  on report
compute sum of "TOTAL SIZE(TB)"  on report
compute sum of "MAX SIZE(GB)"    on report
select substr(A.tablespace_name,1,30) "Tablespace"
   , MAX(A.contents) "Type"
   , MAX(A.status) "Status"
-- , MAX(A.max_extents) "Max extents"
-- , MAX(A.pct_increase) "Pct_increase"
   , (SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024)-(ROUND(SUM(C.BYTES)/1024/1024/COUNT(DISTINCT B.FILE_ID))) "USED SIZE(MB)"
   , ROUND(SUM(C.BYTES)/1024/1024/COUNT(DISTINCT B.FILE_ID)) "FREE SIZE(MB)"
   , SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024 "TOTAL SIZE(MB)"
   , (SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024)-(ROUND(SUM(C.BYTES)/1024/1024/1024/COUNT(DISTINCT B.FILE_ID))) "USED SIZE(GB)"
   , ROUND(SUM(C.BYTES)/1024/1024/1024/COUNT(DISTINCT B.FILE_ID)) "FREE SIZE(GB)"
   , SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024 "TOTAL SIZE(GB)"
-- , (SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024/1024)-(ROUND(SUM(C.BYTES)/1024/1024/1024/1024/COUNT(DISTINCT B.FILE_ID))) "USED SIZE(TB)"
   , ROUND(SUM(C.BYTES)/1024/1024/1024/1024/COUNT(DISTINCT B.FILE_ID)) "FREE SIZE(TB)"
   , SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024/2014 "TOTAL SIZE(TB)"
-- , (SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID))-(SUM(C.BLOCKS)/COUNT(DISTINCT B.FILE_ID)) "USED BLOCKS"
-- , SUM(C.BLOCKS)/COUNT(DISTINCT B.FILE_ID) "FREE BLOCKS"
   , TO_CHAR(100-(SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID),'999.99') || '%' "USAGE (%)"
   , TO_CHAR((SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID),'999.99') || '%' "FREE (%)"
-- , SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID) "TOTAL BLOCKS"
   , SUM(B.MAXBYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024 "MAX SIZE(GB)"
   , case
       when TO_CHAR(100-(SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID)) < 80 then 'Size OK'
       when TO_CHAR(100-(SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID)) < 90 then 'Warning'
       else 'Critical' end as "Status Size"
from dba_tablespaces A, DBA_DATA_FILES B, DBA_FREE_SPACE C
WHERE A.TABLESPACE_NAME=B.TABLESPACE_NAME
AND A.TABLESPACE_NAME=C.TABLESPACE_NAME
GROUP BY A.TABLESPACE_NAME
order by 1;
prompt
prompt ##############################################################
prompt # Datafiles                                                  #
prompt ##############################################################
TTITLE OFF
BTITLE OFF
SET FEEDBACK ON
column "Size (M)" format 9g999g999g990     heading 'Size (M)'
column "Size (G)" format 9g999g999g990     heading 'Size (G)'
column "Used (M)" format 9g999g999g990     heading 'Used (M)'
column "Used (G)" format 9g999g999g990     heading 'Used (G)'
column "Free (M)" format 9g999g999g990     heading 'Free (M)'
column "Free (G)" format 9g999g999g990     heading 'Free (G)'
column "MAX (G)"  format 9g999g999g990     heading 'MAX (G)'
col "FILE NAME"          for a75
col "AUTOEXTENSIBLE"     for a15
col "Status"             for a10
col "Tablespace Name"    for a30
col "Used (%)"           for a11
-- col "Size (M)"        for a11
-- col "Size (g)"        for a11
-- col "Used (M)"        for a15
-- col "Used (G)"        for a15
-- col "Free (M)"        for a15
-- col "Free (G)"        for a15
-- col "Max (G)"         for a15
select Substr(df.tablespace_name,1,30)           "Tablespace Name"
  , Substr(df.file_name,1,75)                    "File Name"
--  , AUTOEXTENSIBLE as                          "AUTOEXTENSIBLE"
  , status as                                    "Status"
  , round(df.bytes/1024/1024, 2)                 "Size (M)"
  , round(e.used_bytes/1024/1024, 2)             "Used (M)"
  , round(f.free_bytes/1024/1024, 2)             "Free (M)"
--  , case when round(df.bytes/1024/1024, 2) = round(e.used_bytes/1024/1024, 2) then 'Full/100%' else to_char(round(f.free_bytes/1024/1024, 2)) end as "Free (M)"
  , round(df.bytes/1024/1024/1024, 2)            "Size (G)"
  , round(e.used_bytes/1024/1024/1024, 2)        "Used (G)"
  , round(f.free_bytes/1024/1024/1024, 2)        "Free (G)"
--  , case when Round(df.bytes/1024/1024/1024, 2) = Round(e.used_bytes/1024/1024/1024, 2) then 'Full/100%' else to_char(Round(f.free_bytes/1024/1024/1024, 2)) end as "Free (G)"
  , df.maxbytes/1024/1024/1024 as                "Max (G)"
  , rpad(' '|| Rpad ('X',Round(e.used_bytes*10/df.bytes,0), 'X'),11,'-') "Used (%)"
FROM DBA_DATA_FILES df,
   (select file_id, Sum(Decode(bytes,NULL,0,bytes)) used_bytes FROM dba_extents GROUP by file_id) E,
   (select Max(bytes) free_bytes, file_id FROM dba_free_space GROUP BY file_id) f
WHERE e.file_id (+) = df.file_id
AND df.file_id = f.file_id (+)
ORDER BY df.tablespace_name, df.file_name;
prompt
prompt ##############################################################
prompt # TempFiles                                                  #
prompt ##############################################################
column "Size (M)" format 9g999g999 heading 'Size (M)'
column "Used (M)" format 9g999g999 heading 'Used (M)'
column "Free (M)" format 9g999g999 heading 'Free (M)'
column "Size (G)" format 9g999g999 heading 'Size (G)'
column "Used (G)" format 9g999g999 heading 'Used (G)'
column "Free (G)" format 9g999g999 heading 'Free (G)'
column "MAX (G)"  format 9g999g999 heading 'MAX (G)'
col "FILE NAME"          for a90
col "AUTOEXTENSIBLE"     for a15
col "Status"             for a10
col "Tablespace Name"    for a20
col "Used (%)"           for a11
col "Free (M)"           for a9
col "Free (G)"           for a9
-- col "Max (G)"         for a15
select substr(df.tablespace_name,1,20) as    "Tablespace Name"
  , substr(df.file_name,1,90) as             "File Name"
  , AUTOEXTENSIBLE as                        "AUTOEXTENSIBLE"
  , status as                                "Status"
  , round(df.bytes/1024/1024, 2) as          "Size (M)"
  , round(e.used_bytes/1024/1024, 2) as      "Used (M)"
  , case when Round(df.bytes/1024/1024, 2) = Round(e.used_bytes/1024/1024, 2) then 'Full/100%' else to_char(Round(f.free_bytes/1024/1024, 2)) end as "Free (M)"
  , round(df.bytes/1024/1024/1024, 2) as     "Size (G)"
  , round(e.used_bytes/1024/1024/1024, 2) as "Used (G)"
  , case when Round(df.bytes/1024/1024/1024, 2) = Round(e.used_bytes/1024/1024/1024, 2) then 'Full/100%' else to_char(Round(f.free_bytes/1024/1024/1024, 2)) end as "Free (G)"
  , df.maxbytes/1024/1024/1024 as            "Max (G)"
  , rpad(' '|| Rpad ('X',Round(e.used_bytes*10/df.bytes,0), 'X'),11,'-') as "Used (%)"
FROM DBA_TEMP_FILES df,
   (select file_id, sum(Decode(bytes,NULL,0,bytes)) used_bytes FROM dba_extents GROUP by file_id) E,
   (select max(bytes) free_bytes, file_id FROM dba_free_space GROUP BY file_id) f
WHERE e.file_id (+) = df.file_id
AND df.file_id  = f.file_id (+)
ORDER BY df.tablespace_name, df.file_name;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_040()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # Tablespaces                                                #
prompt ##############################################################
col "USAGE (%)"          for a9
col "FREE (%)"           for a9
col Tablespace           for a20
col "Type"               for a12
col "USED USAGE"         for a12
col "FREE USAGE"         for a12
col "USED SIZE(MB)"      for a12
col "USED SIZE(GB)"      for a12
col "USED SIZE(TB)"      for a12
col "FREE SIZE(MB)"      for a12
col "FREE SIZE(GB)"      for a12
col "FREE SIZE(TB)"      for a12
col "MAX SIZE"           for a12
col "Status"             for a7
col "Status Size"        for a13
column "USED SIZE(MB)"   format 9g999g999g990 heading  'USED SIZE(MB)'
column "USED SIZE(GB)"   format 9g999g999g990 heading  'USED SIZE(GB)'
column "USED SIZE(TB)"   format 9g999g999g990 heading  'USED SIZE(TB)'
column "FREE SIZE(MB)"   format 9g999g999g990 heading  'FREE SIZE(MB)'
column "FREE SIZE(GB)"   format 9g999g999g990 heading  'FREE SIZE(GB)'
column "FREE SIZE(TB)"   format 9g999g999g990 heading  'FREE SIZE(TB)'
column "TOTAL SIZE(MB)"  format 9g999g999g990 heading  'TOTAL SIZE(MB)'
column "TOTAL SIZE(GB)"  format 9g999g999g990 heading  'TOTAL SIZE(GB)'
column "TOTAL SIZE(TB)"  format 9g999g999g990 heading  'TOTAL SIZE(TB)'
column "MAX SIZE(GB)"    format 9g999g999g990 heading  'MAX SIZE(GB)'
break on report
compute sum of "USED SIZE(MB)"   on report
compute sum of "USED SIZE(GB)"   on report
compute sum of "USED SIZE(TB)"   on report
compute sum of "FREE SIZE(MB)"   on report
compute sum of "FREE SIZE(GB)"   on report
compute sum of "FREE SIZE(TB)"   on report
compute sum of "TOTAL SIZE(MB)"  on report
compute sum of "TOTAL SIZE(GB)"  on report
compute sum of "TOTAL SIZE(TB)"  on report
compute sum of "MAX SIZE(GB)"    on report
select substr(A.tablespace_name,1,20) "Tablespace"
   , MAX(A.contents) "Type"
   , MAX(A.status) "Status"
-- , MAX(A.max_extents) "Max extents"
-- , MAX(A.pct_increase) "Pct_increase"
   , (SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024)-(ROUND(SUM(C.BYTES)/1024/1024/COUNT(DISTINCT B.FILE_ID))) "USED SIZE(MB)"
   , ROUND(SUM(C.BYTES)/1024/1024/COUNT(DISTINCT B.FILE_ID)) "FREE SIZE(MB)"
   , SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024 "TOTAL SIZE(MB)"
   , (SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024)-(ROUND(SUM(C.BYTES)/1024/1024/1024/COUNT(DISTINCT B.FILE_ID))) "USED SIZE(GB)"
   , ROUND(SUM(C.BYTES)/1024/1024/1024/COUNT(DISTINCT B.FILE_ID)) "FREE SIZE(GB)"
   , SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024 "TOTAL SIZE(GB)"
-- , (SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024/1024)-(ROUND(SUM(C.BYTES)/1024/1024/1024/1024/COUNT(DISTINCT B.FILE_ID))) "USED SIZE(TB)"
   , ROUND(SUM(C.BYTES)/1024/1024/1024/1024/COUNT(DISTINCT B.FILE_ID)) "FREE SIZE(TB)"
   , SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024/2014 "TOTAL SIZE(TB)"
-- , (SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID))-(SUM(C.BLOCKS)/COUNT(DISTINCT B.FILE_ID)) "USED BLOCKS"
-- , SUM(C.BLOCKS)/COUNT(DISTINCT B.FILE_ID) "FREE BLOCKS"
   , TO_CHAR(100-(SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID),'999.99') || '%' "USAGE (%)"
   , TO_CHAR((SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID),'999.99') || '%' "FREE (%)"
-- , SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID) "TOTAL BLOCKS"
   , SUM(B.MAXBYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024 "MAX SIZE(GB)"
   , case
       when TO_CHAR(100-(SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID)) < 80 then 'Size OK'
       when TO_CHAR(100-(SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID)) < 90 then 'Warning'
       else 'Critical' end as "Status Size"
from dba_tablespaces A, DBA_DATA_FILES B, DBA_FREE_SPACE C
WHERE A.TABLESPACE_NAME=B.TABLESPACE_NAME
AND A.TABLESPACE_NAME=C.TABLESPACE_NAME
GROUP BY A.TABLESPACE_NAME
order by 1;
prompt
prompt ##############################################################
prompt # Datafiles                                                  #
prompt ##############################################################
TTITLE OFF
BTITLE OFF
SET FEEDBACK ON
column "Size (M)" format 9g999g999g990     heading 'Size (M)'
column "Size (G)" format 9g999g999g990     heading 'Size (G)'
column "Used (M)" format 9g999g999g990     heading 'Used (M)'
column "Used (G)" format 9g999g999g990     heading 'Used (G)'
column "Free (M)" format 9g999g999g990     heading 'Free (M)'
column "Free (G)" format 9g999g999g990     heading 'Free (G)'
column "MAX (G)"  format 9g999g999g990     heading 'MAX (G)'
col "FILE NAME"          for a90
col "AUTOEXTENSIBLE"     for a15
col "Status"             for a10
col "Tablespace Name"    for a20
col "Used (%)"           for a11
-- col "Size (M)"        for a11
-- col "Size (g)"        for a11
-- col "Used (M)"        for a15
-- col "Used (G)"        for a15
-- col "Free (M)"        for a15
-- col "Free (G)"        for a15
-- col "Max (G)"         for a15
select Substr(df.tablespace_name,1,20)           "Tablespace Name"
  , Substr(df.file_name,1,90)                    "File Name"
--  , AUTOEXTENSIBLE as                          "AUTOEXTENSIBLE"
  , status as                                    "Status"
  , round(df.bytes/1024/1024, 2)                 "Size (M)"
  , round(e.used_bytes/1024/1024, 2)             "Used (M)"
  , round(f.free_bytes/1024/1024, 2)             "Free (M)"
--  , case when round(df.bytes/1024/1024, 2) = round(e.used_bytes/1024/1024, 2) then 'Full/100%' else to_char(round(f.free_bytes/1024/1024, 2)) end as "Free (M)"
  , round(df.bytes/1024/1024/1024, 2)            "Size (G)"
  , round(e.used_bytes/1024/1024/1024, 2)        "Used (G)"
  , round(f.free_bytes/1024/1024/1024, 2)        "Free (G)"
--  , case when Round(df.bytes/1024/1024/1024, 2) = Round(e.used_bytes/1024/1024/1024, 2) then 'Full/100%' else to_char(Round(f.free_bytes/1024/1024/1024, 2)) end as "Free (G)"
  , df.maxbytes/1024/1024/1024 as                "Max (G)"
  , rpad(' '|| Rpad ('X',Round(e.used_bytes*10/df.bytes,0), 'X'),11,'-') "Used (%)"
FROM DBA_DATA_FILES df,
   (select file_id, Sum(Decode(bytes,NULL,0,bytes)) used_bytes FROM dba_extents GROUP by file_id) E,
   (select Max(bytes) free_bytes, file_id FROM dba_free_space GROUP BY file_id) f
WHERE e.file_id (+) = df.file_id
AND df.file_id = f.file_id (+)
ORDER BY df.tablespace_name, df.file_name;
prompt
prompt ##############################################################
prompt # TempFiles                                                  #
prompt ##############################################################
column "Size (M)" format 9g999g999 heading 'Size (M)'
column "Used (M)" format 9g999g999 heading 'Used (M)'
column "Free (M)" format 9g999g999 heading 'Free (M)'
column "Size (G)" format 9g999g999 heading 'Size (G)'
column "Used (G)" format 9g999g999 heading 'Used (G)'
column "Free (G)" format 9g999g999 heading 'Free (G)'
column "MAX (G)"  format 9g999g999 heading 'MAX (G)'
col "FILE NAME"          for a90
col "AUTOEXTENSIBLE"     for a15
col "Status"             for a10
col "Tablespace Name"    for a20
col "Used (%)"           for a11
col "Free (M)"           for a9
col "Free (G)"           for a9
-- col "Max (G)"         for a15
select substr(df.tablespace_name,1,20) as    "Tablespace Name"
  , substr(df.file_name,1,90) as             "File Name"
  , AUTOEXTENSIBLE as                        "AUTOEXTENSIBLE"
  , status as                                "Status"
  , round(df.bytes/1024/1024, 2) as          "Size (M)"
  , round(e.used_bytes/1024/1024, 2) as      "Used (M)"
  , case when Round(df.bytes/1024/1024, 2) = Round(e.used_bytes/1024/1024, 2) then 'Full/100%' else to_char(Round(f.free_bytes/1024/1024, 2)) end as "Free (M)"
  , round(df.bytes/1024/1024/1024, 2) as     "Size (G)"
  , round(e.used_bytes/1024/1024/1024, 2) as "Used (G)"
  , case when Round(df.bytes/1024/1024/1024, 2) = Round(e.used_bytes/1024/1024/1024, 2) then 'Full/100%' else to_char(Round(f.free_bytes/1024/1024/1024, 2)) end as "Free (G)"
  , df.maxbytes/1024/1024/1024 as            "Max (G)"
  , rpad(' '|| Rpad ('X',Round(e.used_bytes*10/df.bytes,0), 'X'),11,'-') as "Used (%)"
FROM DBA_TEMP_FILES df,
   (select file_id, sum(Decode(bytes,NULL,0,bytes)) used_bytes FROM dba_extents GROUP by file_id) E,
   (select max(bytes) free_bytes, file_id FROM dba_free_space GROUP BY file_id) f
WHERE e.file_id (+) = df.file_id
AND df.file_id  = f.file_id (+)
ORDER BY df.tablespace_name, df.file_name;
quit;
EOF
}
#
#########################################################################################################
# VERIFY STATISTICS - TABLES [ @ ]
#########################################################################################################
#
function Func_DB_041()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_041
else
  Func_DB_NON_PDB_041
fi
}
# PDB
function Func_DB_PDB_041()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
prompt
prompt ##############################################################
prompt # VERIFY STATISTICS - TABLES [ @ ]
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
col schema for a20
col object for a50
select S.Owner as                                        "Schema"
  , S.Table_Name as                                      "Object"
  , S.Object_Type as                                     "Object Type"
  , S.Num_Rows as                                        "Qtd. of Lines"
  , To_Char(S.Last_Analyzed, 'dd/mm/yyyy HH24:mm:ss') as "Last Analyzed"
  , case when S.Last_Analyzed > sysdate - 7
    then 'Status OK' when S.Last_Analyzed > sysdate - 30 then 'Warning' else 'Critical' end as "Status of Statistics"
FROM sys.dba_tab_statistics S
ORDER BY S.Owner, S.Table_Name, S.Num_Rows, S.Last_Analyzed;
prompt
prompt ##############################################################
prompt # Quantity of Objects with Status OK - (Collected on the lasts 7 days)
prompt ##############################################################
col owner for a30
select a.owner, count(*)
from sys.dba_tab_statistics a
where a.last_analyzed > sysdate - 7
group by a.owner
order by a.owner;
prompt
prompt ##############################################################
prompt # Quantity of Objects with Warning - (Collected between 7 and 30 days)
prompt ##############################################################
col owner for a30
select a.owner, count(*)
from sys.dba_tab_statistics a
where a.last_analyzed < sysdate - 7
and a.last_analyzed < sysdate - 30
group by a.owner
order by a.owner;
prompt
prompt ##############################################################
prompt # Quantity of Objects with Critical - (Collected more them 30 days)
prompt ##############################################################
col owner for a30
select a.owner, count(*)
from sys.dba_tab_statistics a
where a.last_analyzed > sysdate - 30
and a.last_analyzed < sysdate - 90
group by a.owner
order by a.owner;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_041()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # VERIFY STATISTICS - TABLES [ @ ]
prompt ##############################################################
col schema for a20
col object for a50
select S.Owner as                                        "Schema"
  , S.Table_Name as                                      "Object"
  , S.Object_Type as                                     "Object Type"
  , S.Num_Rows as                                        "Qtd. of Lines"
  , To_Char(S.Last_Analyzed, 'dd/mm/yyyy HH24:mm:ss') as "Last Analyzed"
  , case when S.Last_Analyzed > sysdate - 7
    then 'Status OK' when S.Last_Analyzed > sysdate - 30 then 'Warning' else 'Critical' end as "Status of Statistics"
FROM sys.dba_tab_statistics S
ORDER BY S.Owner, S.Table_Name, S.Num_Rows, S.Last_Analyzed;
prompt
prompt ##############################################################
prompt # Quantity of Objects with Status OK - (Collected on the lasts 7 days)
prompt ##############################################################
col owner for a30
select a.owner, count(*)
from sys.dba_tab_statistics a
where a.last_analyzed > sysdate - 7
group by a.owner
order by a.owner;
prompt
prompt ##############################################################
prompt # Quantity of Objects with Warning - (Collected between 7 and 30 days)
prompt ##############################################################
col owner for a30
select a.owner, count(*)
from sys.dba_tab_statistics a
where a.last_analyzed < sysdate - 7
and a.last_analyzed < sysdate - 30
group by a.owner
order by a.owner;
prompt
prompt ##############################################################
prompt # Quantity of Objects with Critical - (Collected more them 30 days)
prompt ##############################################################
col owner for a30
select a.owner, count(*)
from sys.dba_tab_statistics a
where a.last_analyzed > sysdate - 30
and a.last_analyzed < sysdate - 90
group by a.owner
order by a.owner;
quit;
EOF
}
#
#########################################################################################################
# VERIFY STATISTICS - INDEXES [ @ ]
#########################################################################################################
#
function Func_DB_042()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_042
else
  Func_DB_NON_PDB_042
fi
}
# PDB
function Func_DB_PDB_042()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # VERIFY STATISTICS - INDEXES [ @ ]
prompt ##############################################################
col schema for a20
col object for a50
select S.Owner as                                        "Schema"
  , S.Table_Name as                                      "Object"
  , S.Object_Type as                                     "Object Type"
  , S.Num_Rows as                                        "Qtd. of Lines"
  , To_Char(S.Last_Analyzed, 'dd/mm/yyyy HH24:mm:ss') as "Last Analyzed"
  , case when S.Last_Analyzed > sysdate - 7 then 'Status OK' when S.Last_Analyzed > sysdate -30 then 'Warning' else 'Critical' end as "Status of Statistics"
FROM sys.dba_ind_statistics S
ORDER BY S.Owner, S.Table_Name, S.Num_Rows, S.Last_Analyzed;
prompt ##############################################################
prompt # Quantity of Objects with Status OK - (Collected on the lasts 7 days)
prompt ##############################################################
prompt
col owner for a30
select a.owner, count(*)
from sys.dba_ind_statistics a
where a.last_analyzed > sysdate - 7
group by a.owner
order by a.owner;
prompt ##############################################################
prompt # Quantity of Objects with Warning - (Collected between 7 and 30 days)
prompt ##############################################################
prompt
col owner for a30
select a.owner, count(*)
from sys.dba_ind_statistics a
where a.last_analyzed < sysdate - 7
group by a.owner
order by a.owner;
prompt ##############################################################
prompt # Quantity of Objects with Critical - (Collected more them 30 days)
prompt ##############################################################
prompt
col owner for a30
select a.owner, count(*)
from sys.dba_ind_statistics a
where a.last_analyzed > sysdate - 30
group by a.owner
order by a.owner;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_042()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # VERIFY STATISTICS - INDEXES [ @ ]
prompt ##############################################################
col schema for a20
col object for a50
select S.Owner as                                        "Schema"
  , S.Table_Name as                                      "Object"
  , S.Object_Type as                                     "Object Type"
  , S.Num_Rows as                                        "Qtd. of Lines"
  , To_Char(S.Last_Analyzed, 'dd/mm/yyyy HH24:mm:ss') as "Last Analyzed"
  , case when S.Last_Analyzed > sysdate - 7 then 'Status OK' when S.Last_Analyzed > sysdate -30 then 'Warning' else 'Critical' end as "Status of Statistics"
FROM sys.dba_ind_statistics S
ORDER BY S.Owner, S.Table_Name, S.Num_Rows, S.Last_Analyzed;
prompt ##############################################################
prompt # Quantity of Objects with Status OK - (Collected on the lasts 7 days)
prompt ##############################################################
prompt
col owner for a30
select a.owner, count(*)
from sys.dba_ind_statistics a
where a.last_analyzed > sysdate - 7
group by a.owner
order by a.owner;
prompt ##############################################################
prompt # Quantity of Objects with Warning - (Collected between 7 and 30 days)
prompt ##############################################################
prompt
col owner for a30
select a.owner, count(*)
from sys.dba_ind_statistics a
where a.last_analyzed < sysdate - 7
group by a.owner
order by a.owner;
prompt ##############################################################
prompt # Quantity of Objects with Critical - (Collected more them 30 days)
prompt ##############################################################
prompt
col owner for a30
select a.owner, count(*)
from sys.dba_ind_statistics a
where a.last_analyzed > sysdate - 30
group by a.owner
order by a.owner;
quit;
EOF
}
#
#########################################################################################################
# CAPTURE STATISTICS - OWNER [ @ ]
#########################################################################################################
#
# NON PDB
function Func_DB_043()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 colsep '|'
prompt ##############################################################
prompt # CAPTURE STATISTICS - OWNER [ @ ]
prompt ##############################################################
col username for a30
col account_status for a25
col profile for a25
col default_tablespace for a25
col temporary_tablespace for a25
select username
   , account_status
   , profile
   , default_tablespace
   , temporary_tablespace
from dba_users
order by 1;
quit;
EOF
Func_DB_Owner_Collect_Statistics
}
#
#
#########################################################################################################
# CAPTURE STATISTICS - OWNER [ @ ]
#########################################################################################################
#
# Owner Collect Statustics
function Func_DB_Owner_Collect_Statistics()
{
varDB_OWNER=""
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- ENTER THE NAME OF THE OWNER or ENTER TO FINISH --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
read varDB_OWNER
if [[ "${varDB_OWNER}" = "" ]]; then
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- NO OWNER SELECTED --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
else
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- WAIT A MOMENT PLEASE, THE STATISTICS COLLECT IS RUNNING --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
varDB_OWNER=$(echo ${varDB_OWNER} | tr [a-z] [A-Z])
typeset -u varDB_OWNER
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
begin
  dbms_stats.gather_schema_stats('${varDB_OWNER}', estimate_percent => dbms_stats.auto_sample_size, cascade => true);
end;
/
quit;
EOF
fi
}
#
#########################################################################################################
# VALIDATE OBJECTS FROM ONE OWNER [ @ ]
#########################################################################################################
#
# NON PDB
function Func_DB_044()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 colsep '|'
prompt ##############################################################
prompt # VALIDATE OBJECTS FROM ONE OWNER [ @ ]
prompt ##############################################################
col username for a30
col account_status for a25
col profile for a25
col default_tablespace for a25
col temporary_tablespace for a25
select username
   , account_status
   , profile
   , default_tablespace
   , temporary_tablespace
from dba_users
order by 1;
quit;
EOF
Func_DB_Owner_Validate_Objects
}
#
#########################################################################################################
# VALIDATE OBJECTS FROM ONE OWNER [ @ ]
#########################################################################################################
#
# Validation Owner Objects
function Func_DB_Owner_Validate_Objects()
{
varDB_OWNER=""
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- ENTER THE NAME OF THE OWNER or ENTER TO FINISH --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
read varDB_OWNER
if [[ "${varDB_OWNER}" = "" ]]; then
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- NO OWNER SELECTED --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
else
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- WAIT A MOMENT PLEASE, THE VALIDATE OBJECTS IS RUNNING --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
varDB_OWNER=$(echo ${varDB_OWNER} | tr [a-z] [A-Z])
typeset -u varDB_OWNER
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 1000 timing on numwidth 20 SERVEROUTPUT ON FEEDBACK OFF colsep '|'
begin
  dbms_utility.compile_schema('${varDB_OWNER}',false);
end;
/
quit;
EOF
fi
}
#
#########################################################################################################
# VERIFY TABLES SIZE, VALIDATE OBJ - OWNERS [ @ ]
#########################################################################################################
#
function Func_DB_045()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_045
else
  Func_DB_NON_PDB_045
fi
}
# PDB
function Func_DB_PDB_045()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 5000 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # VERIFY TABLES SIZE, VALIDATE OBJ - OWNERS [ @ ]
prompt ##############################################################
col "OWNER" for a25
col "Table Name" for a35
col "Table Space" for a25
col "Last Analyzed" for a30
col "Status of Statistics" for a20
select t.owner as                                        "OWNER"
  , t.table_name as                                      "Table Name"
  , t.TABLESPACE_NAME as                                 "Table Space"
  , t.num_rows as                                        "Rows"
  , t.avg_row_len as                                     "Avg Row Len"
  , trunc((t.blocks * p.value)/1024/1024) as             "Size MB" -- numero de blocos X o seu tamanho em KBs
  , to_Char(t.Last_Analyzed, 'DD/MM/YYYY HH24:mm:ss') as "Last Analyzed"
  , case when t.Last_Analyzed > sysdate - 7 then 'Status OK' when t.Last_Analyzed > sysdate - 30 then 'Warning' else 'Critical' end as "Status of Statistics"
FROM dba_tables t, v\$parameter p
WHERE p.name = 'db_block_size'
ORDER BY 1,2;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_045()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 5000 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # VERIFY TABLES SIZE, VALIDATE OBJ - OWNERS [ @ ]
prompt ##############################################################
col "OWNER" for a25
col "Table Name" for a35
col "Table Space" for a25
col "Last Analyzed" for a30
col "Status of Statistics" for a20
select t.owner as                                        "OWNER"
  , t.table_name as                                      "Table Name"
  , t.TABLESPACE_NAME as                                 "Table Space"
  , t.num_rows as                                        "Rows"
  , t.avg_row_len as                                     "Avg Row Len"
  , trunc((t.blocks * p.value)/1024/1024) as             "Size MB" -- numero de blocos X o seu tamanho em KBs
  , to_Char(t.Last_Analyzed, 'DD/MM/YYYY HH24:mm:ss') as "Last Analyzed"
  , case when t.Last_Analyzed > sysdate - 7 then 'Status OK' when t.Last_Analyzed > sysdate - 30 then 'Warning' else 'Critical' end as "Status of Statistics"
FROM dba_tables t, v\$parameter p
WHERE p.name = 'db_block_size'
ORDER BY 1,2;
quit;
EOF
}
#
#########################################################################################################
# OWNER X OBJECTS X TYPE X QTD
#########################################################################################################
#
function Func_DB_046()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_046
else
  Func_DB_NON_PDB_046
fi
}
# PDB
function Func_DB_PDB_046()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
prompt
prompt ##############################################################
prompt # OWNER X OBJECTS X TYPE X QTD
prompt ##############################################################
set pages 2000 lines 700 timing on feedback on echo on heading on verify on colsep '|'
col owner for a30
col object_type for a20
Clear Breaks
Break on owner Skip 1
Compute Sum LABEL 'TOTAL' Of Qtde On owner
select owner, object_type, count(*) Qtde from dba_objects where owner not in ('SYS','SYSTEM','SYSMAN','DBSNMP') group by owner,object_type
union
select owner, 'CONSTRAINT ' || constraint_type, count(*) from dba_constraints where owner not in ('SYS','SYSTEM','SYSMAN','DBSNMP') group by owner, 'CONSTRAINT ' || constraint_type
/
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_046()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 2000 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # OWNER X OBJECTS X TYPE X QTD
prompt ##############################################################
col owner for a30
col object_type for a20
Clear Breaks
Break on owner Skip 1
Compute Sum LABEL 'TOTAL' Of Qtde On owner
select owner, object_type, count(*) Qtde from dba_objects where owner not in ('SYS','SYSTEM','SYSMAN','DBSNMP') group by owner,object_type
union
select owner, 'CONSTRAINT ' || constraint_type, count(*) from dba_constraints where owner not in ('SYS','SYSTEM','SYSMAN','DBSNMP') group by owner, 'CONSTRAINT ' || constraint_type
/
quit;
EOF
}
#
#########################################################################################################
# VERIFY INSTANCE CHARACTERSET
#########################################################################################################
#
# NON PDB
function Func_DB_047()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # VERIFY INSTANCE CHARACTERSET
prompt ##############################################################
col parameter for a50
col value for a50
select * from nls_database_parameters;
quit;
EOF
}
#
#########################################################################################################
# CACHE HIT RATIO [ GOOD: > 90% ]
#########################################################################################################
#
# NON PDB
function Func_DB_048()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # CACHE HIT RATIO [ GOOD: > 90% ]
prompt ##############################################################
select sum(gets) "Data Dict Gets"
   , sum(getmisses) "Data Dict Cache Misses"
   , round((1-(sum(getmisses)/sum(gets)))*100) "DATA DICT CACHE HIT RATIO"
   , round(sum(getmisses)*100/sum(gets)) "% MISSED"
   , case when round((1-(sum(getmisses)/sum(gets)))*100) < 90 then 'Critical' else 'Status OK' end as status
from v\$rowcache;
quit;
EOF
}
#
#########################################################################################################
# VERIFY INSTANCE INSTALLED PRODUCTS
#########################################################################################################
#
# NON PDB
function Func_DB_049()
{
sqlplus -S  '/ as sysdba' <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # VERIFY INSTANCE INSTALLED PRODUCTS
prompt ##############################################################
col version_full for a15
col status for a10
col schema for a12
col comp_name for a40
select comp_name
  , version_full
  , status
  , modified
--  , to_char(modified, 'DD/MM/YYYY HH24:MM:SS') as modified
  , schema
  , status
FROM dba_registry
order by 1, 2, 3;
quit;
EOF
}
#
#########################################################################################################
# INSTANCE PROPERTIES
#########################################################################################################
#
# NON PDB
function Func_DB_050()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # INSTANCE PROPERTIES
prompt ##############################################################
COLUMN PROPERTY_NAME FORMAT A70
COLUMN PROPERTY_VALUE FORMAT A70
select PROPERTY_NAME
  , PROPERTY_VALUE
FROM database_properties
ORDER BY PROPERTY_NAME;
quit;
EOF
}
#
#########################################################################################################
# INSTANCE OPTIONS
#########################################################################################################
#
# NON PDB
function Func_DB_051()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # INSTANCE OPTIONS
prompt ##############################################################
col value for A10
col parameter for A50
select * FROM v\$option
ORDER BY parameter;
quit;
EOF
}
#
#########################################################################################################
# INSTANCE DIFFERENTS PARAMETERS
#########################################################################################################
#
# NON PDB
function Func_DB_052()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # INSTANCE DIFFERENTS PARAMETERS
prompt ##############################################################
COLUMN name          FORMAT A30
COLUMN current_value FORMAT A110
COLUMN sid           FORMAT A10
COLUMN spfile_value  FORMAT A70
select p.name
  , i.instance_name as sid
  , upper(p.value) as current_value
  , sp.sid
  , upper(sp.value) as spfile_value
FROM v\$spparameter sp
  , v\$parameter p
  , v\$instance i
WHERE sp.name = p.name
AND upper(sp.value) != upper(p.value);
quit;
EOF
}
# select name, VALUE, ISSYS_MODIFIABLE from SYS.V$PARAMETER
#
#########################################################################################################
# INSTANCE MODIFICABLES PARAMETERS
#########################################################################################################
#
# NON PDB
function Func_DB_053()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # INSTANCE MODIFICABLES PARAMETERS
prompt ##############################################################
COLUMN name  FORMAT A50
COLUMN value FORMAT A110
select p.name
  , p.type
  , p.value
  , p.isses_modifiable
  , p.issys_modifiable
  , p.isinstance_modifiable
FROM v\$parameter p
ORDER BY p.name;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DEAD LOCKS
#########################################################################################################
#
function Func_DB_054()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_054
else
  Func_DB_NON_PDB_054
fi
}
# PDB
function Func_DB_PDB_054()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # WHICH SESSION IS BLOCKING OTHER SESSION                    #
prompt ##############################################################
select (select username FROM gv\$session WHERE sid=a.sid) blocker
  , a.sid
  , ' is blocking ' as BLOCKING
  , (select username FROM gv\$session WHERE sid=b.sid) blockee
  , b.sid
FROM gv\$lock a, gv\$lock b
WHERE a.block = 1
AND b.request > 0
AND a.id1 = b.id1
AND a.id2 = b.id2;
prompt
prompt ##############################################################
prompt # VERIFY DEAD LOCKS
prompt ##############################################################
col username form A15
col sid form 9999999
col type form A4
col lmode form 9999999
col request form 9999999
col id1 form 9999990
col id2 form 9999990
col lmode for a20
col request for a20
break on id1 skip 1 dup
select sn.username
  , m.sid
  , m.type
  , DECODE(m.lmode, 0, 'None', 1, 'Null', 2, 'Row Share', 3, 'Row Excl.', 4, 'Share', 6, 'Exclusive', 5, 'S/Row Excl.', lmode, ltrim(to_char(lmode,'990'))) lmode
  , DECODE(m.request, 0, 'None', 1, 'Null', 2, 'Row Share', 3, 'Row Excl.', 4, 'Share', 5, 'S/Row Excl.', 6, 'Exclusive', request, ltrim(to_char(request,'990'))) request
  , m.id1
  , m.id2
FROM gv\$session sn, gv\$lock m
WHERE (sn.sid = m.sid AND m.request != 0) OR (sn.sid = m.sid AND m.request = 0 AND lmode != 4 AND (id1, id2)
IN (select s.id1, s.id2 FROM gv\$lock s WHERE request != 0 AND s.id1 = m.id1 AND s.id2 = m.id2))
ORDER BY id1,id2, m.request;
clear breaks
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_054()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # WHICH SESSION IS BLOCKING OTHER SESSION                    #
prompt ##############################################################
select (select username FROM gv\$session WHERE sid=a.sid) blocker
  , a.sid
  , ' is blocking ' as BLOCKING
  , (select username FROM gv\$session WHERE sid=b.sid) blockee
  , b.sid
FROM gv\$lock a, gv\$lock b
WHERE a.block = 1
AND b.request > 0
AND a.id1 = b.id1
AND a.id2 = b.id2;
prompt
prompt ##############################################################
prompt # VERIFY DEAD LOCKS
prompt ##############################################################
col username form A15
col sid form 9999999
col type form A4
col lmode form 9999999
col request form 9999999
col id1 form 9999990
col id2 form 9999990
col lmode for a20
col request for a20
break on id1 skip 1 dup
select sn.username
  , m.sid
  , m.type
  , DECODE(m.lmode, 0, 'None', 1, 'Null', 2, 'Row Share', 3, 'Row Excl.', 4, 'Share', 6, 'Exclusive', 5, 'S/Row Excl.', lmode, ltrim(to_char(lmode,'990'))) lmode
  , DECODE(m.request, 0, 'None', 1, 'Null', 2, 'Row Share', 3, 'Row Excl.', 4, 'Share', 5, 'S/Row Excl.', 6, 'Exclusive', request, ltrim(to_char(request,'990'))) request
  , m.id1
  , m.id2
FROM gv\$session sn, gv\$lock m
WHERE (sn.sid = m.sid AND m.request != 0) OR (sn.sid = m.sid AND m.request = 0 AND lmode != 4 AND (id1, id2)
IN (select s.id1, s.id2 FROM gv\$lock s WHERE request != 0 AND s.id1 = m.id1 AND s.id2 = m.id2))
ORDER BY id1,id2, m.request;
clear breaks
quit;
EOF
}
#
#########################################################################################################
# select (select username FROM gv$session WHERE sid=a.sid) blocker
#   , a.sid || ',' || (select serial# from gv$session c where sid=a.sid) sess1
#   , ' is blocking ' as BLOCKING
#   , (select username FROM gv$session WHERE sid=b.sid) blockee
#   , b.sid || ',' || (select serial# from gv$session c where sid=b.sid) sess2
# FROM gv$lock a, gv$lock b
# WHERE a.block = 1
# AND b.request > 0
# AND a.id1 = b.id1
# AND a.id2 = b.id2;
#########################################################################################################
#
#########################################################################################################
# VERIFY SESSIONS PER I/O CONSUME
#########################################################################################################
#
function Func_DB_055()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_055
else
  Func_DB_NON_PDB_055
fi
}
# PDB
function Func_DB_PDB_055()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
prompt
prompt ##############################################################
prompt # VERIFY SESSIONS PER I/O CONSUME
prompt ##############################################################
clear breaks compute
set feedback 6 feedback off linesize 300 pagesize 10000 verify off echo on heading on timing on colsep '|'
undefine topN topStat topUser
define topN=3
define topStat=%
define pctMinimo=1
column sid for a15
column top_stat_name format a35 heading 'STATISTIC_NAME' trunc
column sess_status format a10 heading 'STATUS' truncate
column username_osuser format a30 heading 'USERNAME/OSUSER'
column minutos format 9999 heading 'MIN'
column statistic_value format 9g999g999g999g990 heading 'STATISTIC_VAL'
column conn_time format a20 heading 'CONNECTED ON'
col "CONNECTED ON" for a20
column rank format 99
break on top_stat_name skip 1
compute sum of pct on statistic_name
select statistic_name as top_stat_name
   , rank
   , pct
   , sid || '/' || serial# as sid
   , decode( username, null, '(' || bg_name || ')', username) || decode(osuser, null, null, '/') || substr(osuser, 1+instr(osuser, '\')) as username_osuser
   , lpad(decode(trunc(sysdate - logon_time), 0, null, trunc(sysdate - logon_time) || 'd, ') || to_char(to_date(trunc(86400 * ((sysdate-logon_time) - trunc(sysdate - logon_time))), 'SSSSS'), 'hh24"h "mi"m"'), 10) as conn_time
   , round(last_call_et/60, 1) as minutos
   , decode(status, 'ACTIVE', 'ACTIVE', 'INACTIVE', 'INACTIVE', status) as sess_status
   , statistic_value
from (select sn.name as statistic_name
    , row_number() over (partition by sn.name order by sn.name, sv.value desc) as rank
    , 100 * ratio_to_report(sv.value) over (partition by sn.name) as pct
    , sv.value as statistic_value
    , bg.name as bg_name
    , ss.*
from v\$sesstat sv
    , v\$statname sn
    , v\$session ss
    , v\$bgprocess bg
where sn.statistic# = sv.statistic#
and ss.sid = sv.sid
and ss.paddr = bg.paddr(+)
and ss.type != 'BACKGROUND'
and ((status = 'INACTIVE' and last_call_et/60 < 5) or status = 'ACTIVE') and sv.value > 0
and sn.name
in ( 'consistent gets'
   , 'db block gets'
   , 'physical reads'
   , 'physical writes'
-- , 'physical reads direct'
-- , 'physical writes direct'
-- , 'bytes sent via SQL*Net to client'
-- , 'bytes received via SQL*Net from dblink'
-- , 'bytes sent via SQL*Net to dblink'
-- , 'enqueue releases'
-- , 'enqueue requests'
   , 'enqueue waits'
-- , 'recursive cpu usage'
-- , 'session logical reads'
-- , 'session pga memory'
-- , 'session uga memory'
   , 'session pga memory max'
   , 'session uga memory max'
   , 'execute count'
   , 'parse count (hard)'
-- , 'parse time cpu'
-- , 'parse time elapsed'
-- , 'parse count (total)'
-- , 'sorts (disk)'
-- , 'sorts (memory)'
   , 'sorts (rows)'
   , 'table scans (long tables)'
   , 'table fetch continued row'))
where trunc(pct) > &pctMinimo    -- percentuais maiores que pctMinimo
and rank < 1+&topN               -- "N" maiores sessoes que consomem aquele recurso
and upper(statistic_name) like upper('%&topStat.%') ;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_055()
{
sqlplus -S  '/ as sysdba' <<EOF
prompt ##############################################################
prompt # VERIFY SESSIONS PER I/O CONSUME
prompt ##############################################################
clear breaks compute
set feedback 6 feedback off linesize 300 pagesize 10000 verify off echo on heading on timing on colsep '|'
undefine topN topStat topUser
define topN=3
define topStat=%
define pctMinimo=1
column sid for a15
column top_stat_name format a35 heading 'STATISTIC_NAME' trunc
column sess_status format a10 heading 'STATUS' truncate
column username_osuser format a30 heading 'USERNAME/OSUSER'
column minutos format 9999 heading 'MIN'
column statistic_value format 9g999g999g999g990 heading 'STATISTIC_VAL'
column conn_time format a20 heading 'CONNECTED ON'
col "CONNECTED ON" for a20
column rank format 99
break on top_stat_name skip 1
compute sum of pct on statistic_name
select statistic_name as top_stat_name
   , rank
   , pct
   , sid || '/' || serial# as sid
   , decode( username, null, '(' || bg_name || ')', username) || decode(osuser, null, null, '/') || substr(osuser, 1+instr(osuser, '\')) as username_osuser
   , lpad(decode(trunc(sysdate - logon_time), 0, null, trunc(sysdate - logon_time) || 'd, ') || to_char(to_date(trunc(86400 * ((sysdate-logon_time) - trunc(sysdate - logon_time))), 'SSSSS'), 'hh24"h "mi"m"'), 10) as conn_time
   , round(last_call_et/60, 1) as minutos
   , decode(status, 'ACTIVE', 'ACTIVE', 'INACTIVE', 'INACTIVE', status) as sess_status
   , statistic_value
from (select sn.name as statistic_name
    , row_number() over (partition by sn.name order by sn.name, sv.value desc) as rank
    , 100 * ratio_to_report(sv.value) over (partition by sn.name) as pct
    , sv.value as statistic_value
    , bg.name as bg_name
    , ss.*
from v\$sesstat sv
    , v\$statname sn
    , v\$session ss
    , v\$bgprocess bg
where sn.statistic# = sv.statistic#
and ss.sid = sv.sid
and ss.paddr = bg.paddr(+)
and ss.type != 'BACKGROUND'
and ((status = 'INACTIVE' and last_call_et/60 < 5) or status = 'ACTIVE') and sv.value > 0
and sn.name
in ( 'consistent gets'
   , 'db block gets'
   , 'physical reads'
   , 'physical writes'
-- , 'physical reads direct'
-- , 'physical writes direct'
-- , 'bytes sent via SQL*Net to client'
-- , 'bytes received via SQL*Net from dblink'
-- , 'bytes sent via SQL*Net to dblink'
-- , 'enqueue releases'
-- , 'enqueue requests'
   , 'enqueue waits'
-- , 'recursive cpu usage'
-- , 'session logical reads'
-- , 'session pga memory'
-- , 'session uga memory'
   , 'session pga memory max'
   , 'session uga memory max'
   , 'execute count'
   , 'parse count (hard)'
-- , 'parse time cpu'
-- , 'parse time elapsed'
-- , 'parse count (total)'
-- , 'sorts (disk)'
-- , 'sorts (memory)'
   , 'sorts (rows)'
   , 'table scans (long tables)'
   , 'table fetch continued row'))
where trunc(pct) > &pctMinimo    -- percentuais maiores que pctMinimo
and rank < 1+&topN               -- "N" maiores sessoes que consomem aquele recurso
and upper(statistic_name) like upper('%&topStat.%') ;
quit;
EOF
}
#
#########################################################################################################
# VERIFY FREE SEGMENTS ON DATAFILES ??? VERIFY WHERE
#########################################################################################################
#
# NON PDB
function Func_DB_056()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 5000 lines 5000 timing on colsep '|'
prompt ##############################################################
prompt # VERIFY FREE SEGMENTS ON DATAFILES
prompt ##############################################################
col "Name" for a50
select file_id
  , block_id
  , blocks*8192/1024 MB
  , owner || '.' || segment_name "Name"
  , block_id*8192/1024 "Position MB"
from  dba_Extents
where file_id = 21
union
select file_id
  , block_id
  , blocks*8192/1024, 'Free' "Name"
  , block_id*8192/1024 "Position MB"
from dba_free_space
order by 1,2,3;
quit;
EOF
}
#
#########################################################################################################
# VERIFY WHICH DATAFILE CAN BE RESIZED [ @ ]
#########################################################################################################
#
function Func_DB_057()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_057
else
  Func_DB_NON_PDB_057
fi
}
# PDB
function Func_DB_PDB_057()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
prompt
prompt ##############################################################
prompt # VERIFY WHICH DATAFILE CAN BE RESIZED [ @ ]
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify off colsep '|'
column file_name format a120 word_wrapped
column smallest format 999,999,990 heading "Smallest|Size|Poss."
column currsize format 999,999,990 heading "Current|Size"
column savings format 999,999,990 heading "Poss.|Savings"
break on report
compute sum of smallest on report
compute sum of currsize on report
compute sum of savings on report
column value new_val blksize for a10
prompt ##############################################################
PROMPT # DB BLOCK SIZE                                              #
prompt ##############################################################
select value from v\$parameter where name = 'db_block_size';
prompt
prompt ##############################################################
prompt # INFORMATIONS ABOUT DATAFILES                               #
prompt ##############################################################
select 'DATAFILE ' as DATAFILE
  , file_name
  , ceil((nvl(hwm,1)*&&blksize)/1024/1024 ) smallest
  , ceil(blocks*&&blksize/1024/1024) currsize
  , ceil(blocks*&&blksize/1024/1024) - ceil((nvl(hwm,1)*&&blksize)/1024/1024) savings
  , case when ceil(blocks*&&blksize/1024/1024) - ceil((nvl(hwm,1)*&&blksize)/1024/1024) > 100 then 'Recomended' else 'Not Recomended' end as "Recomendation"
from dba_data_files a, (select file_id, max(block_id+blocks-1) hwm from dba_extents group by file_id) b
where a.file_id = b.file_id(+);
prompt
prompt ##############################################################
prompt # COMMANDS TO RESIZE THE DATAFILES                           #
prompt ##############################################################
column "SQL Command" for a175 word_wrapped
select 'alter database datafile ''' || file_name || ''' resize ' || ceil((nvl(hwm,1)*&&blksize)/1024/1024) || 'M;' as "SQL Command"
from dba_data_files a, (select file_id, max(block_id+blocks-1) hwm from dba_extents group by file_id) b
where a.file_id = b.file_id(+)
and ceil(blocks*&&blksize/1024/1024) - ceil((nvl(hwm,1)*&&blksize)/1024/1024) > 0;
quit;
EOF
Func_DB_Resize_Datafile
}
# NON PDB
function Func_DB_NON_PDB_057()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify off colsep '|'
prompt ##############################################################
prompt # VERIFY WHICH DATAFILE CAN BE RESIZED [ @ ]
prompt ##############################################################
column file_name format a120 word_wrapped
column smallest format 999,999,990 heading "Smallest|Size|Poss."
column currsize format 999,999,990 heading "Current|Size"
column savings format 999,999,990 heading "Poss.|Savings"
break on report
compute sum of smallest on report
compute sum of currsize on report
compute sum of savings on report
column value new_val blksize for a10
prompt ##############################################################
PROMPT # DB BLOCK SIZE                                              #
prompt ##############################################################
select value from v\$parameter where name = 'db_block_size';
prompt
prompt ##############################################################
prompt # INFORMATIONS ABOUT DATAFILES                               #
prompt ##############################################################
select 'DATAFILE ' as DATAFILE
  , file_name
  , ceil((nvl(hwm,1)*&&blksize)/1024/1024 ) smallest
  , ceil(blocks*&&blksize/1024/1024) currsize
  , ceil(blocks*&&blksize/1024/1024) - ceil((nvl(hwm,1)*&&blksize)/1024/1024) savings
  , case when ceil(blocks*&&blksize/1024/1024) - ceil((nvl(hwm,1)*&&blksize)/1024/1024) > 100 then 'Recomended' else 'Not Recomended' end as "Recomendation"
from dba_data_files a, (select file_id, max(block_id+blocks-1) hwm from dba_extents group by file_id) b
where a.file_id = b.file_id(+);
prompt
prompt ##############################################################
prompt # COMMANDS TO RESIZE THE DATAFILES                           #
prompt ##############################################################
column "SQL Command" for a175 word_wrapped
select 'alter database datafile ''' || file_name || ''' resize ' || ceil((nvl(hwm,1)*&&blksize)/1024/1024) || 'M;' as "SQL Command"
from dba_data_files a, (select file_id, max(block_id+blocks-1) hwm from dba_extents group by file_id) b
where a.file_id = b.file_id(+)
and ceil(blocks*&&blksize/1024/1024) - ceil((nvl(hwm,1)*&&blksize)/1024/1024) > 0;
quit;
EOF
Func_DB_Resize_Datafile
}
#
#########################################################################################################
# VERIFY WHICH DATAFILE CAN BE RESIZED [ @ ]
#########################################################################################################
#
# Resize Datafile
function Func_DB_Resize_Datafile()
{
var_DB_DATAFILE=""
read var_DB_DATAFILE
if [[ "${var_DB_DATAFILE}" = "" ]]; then
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- NO DATAFILE SELECTED --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
else
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- WAIT A MOMENT PLEASE, THE RESIZING IS RUNNING --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
${var_DB_DATAFILE}
quit;
EOF
fi
}
#
#########################################################################################################
# VERIFY RECYCLEBIN
#########################################################################################################
#
# NON PDB
function Func_DB_058()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
prompt ##############################################################
prompt # VERIFY RECYCLEBIN                                          #
prompt ##############################################################
col OBJECT_NAME for a25
col ORIGINAL_NAME for a25
col OPERATION for a10
select * from recyclebin;
quit;
EOF
}
#
#########################################################################################################
# CLEAR REYICLEBIN
#########################################################################################################
#
# NON PDB
function Func_DB_059()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 200 lines 200 timing on colsep '|'
prompt ##############################################################
prompt # VERIFY RECYCLEBIN                                          #
Prompt # WAIT A MOMENT PLEASE, THE CLEARING IS RUNNING              #
prompt ##############################################################
purge recyclebin;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DATABASE SESSIONS
#########################################################################################################
#
function Func_DB_060()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_060
else
  Func_DB_NON_PDB_060
fi
}
# PDB
function Func_DB_PDB_060()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
prompt
prompt ##############################################################
prompt # VERIFY DATABASE SESSIONS
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
select total_sessions
  , active_sessions
  , (total_sessions - active_sessions) inactive_sessions
  , round( 100 * active_sessions / total_sessions, 2) pct_active
  , round( 100 * (total_sessions - active_sessions) / total_sessions, 2) pct_inactive
from (select count(*) total_sessions from v\$session where type <> 'BACKGROUND') st,
     (select count(*) active_sessions from v\$session where  status = 'ACTIVE' and type <> 'BACKGROUND') sa;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_060()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # VERIFY DATABASE SESSIONS
prompt ##############################################################
select total_sessions
  , active_sessions
  , (total_sessions - active_sessions) inactive_sessions
  , round( 100 * active_sessions / total_sessions, 2) pct_active
  , round( 100 * (total_sessions - active_sessions) / total_sessions, 2) pct_inactive
from (select count(*) total_sessions from v\$session where type <> 'BACKGROUND') st,
     (select count(*) active_sessions from v\$session where  status = 'ACTIVE' and type <> 'BACKGROUND') sa;
quit;
EOF
}
#
#########################################################################################################
# VERIFY ACTIVES SESSIONS PER OWNER
#########################################################################################################
#
function Func_DB_061()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_061
else
  Func_DB_NON_PDB_061
fi
}
# PDB
function Func_DB_PDB_061()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt
prompt ##############################################################
prompt # VERIFY ACTIVES SESSIONS PER OWNER
prompt ##############################################################
select total_sessions
  , active_sessions
  , (total_sessions - active_sessions) inactive_sessions
  , round( 100 * active_sessions / total_sessions, 2) pct_active
  , round( 100 * (total_sessions - active_sessions) / total_sessions, 2) pct_inactive
from (select count(*) total_sessions from v\$session where type <> 'BACKGROUND') st,
     (select count(*) active_sessions from v\$session where  status = 'ACTIVE' and type <> 'BACKGROUND') sa;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_061()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # VERIFY ACTIVES SESSIONS PER OWNER
prompt ##############################################################
select total_sessions
  , active_sessions
  , (total_sessions - active_sessions) inactive_sessions
  , round( 100 * active_sessions / total_sessions, 2) pct_active
  , round( 100 * (total_sessions - active_sessions) / total_sessions, 2) pct_inactive
from (select count(*) total_sessions from v\$session where type <> 'BACKGROUND') st,
     (select count(*) active_sessions from v\$session where  status = 'ACTIVE' and type <> 'BACKGROUND') sa;
quit;
EOF
}
#
#########################################################################################################
# UNLOCKING A USER [ @ ]
#########################################################################################################
#
# NON PDB
function Func_DB_062()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
prompt ##############################################################
prompt # UNLOCKING A USER [ @ ]
prompt ##############################################################
col username for a30
col profile for a30
select user_id
  , username
  , account_status
  , default_tablespace
  , profile 
from dba_users
where account_status <> 'OPEN'
order by 2;
quit;
EOF
Func_DB_Owner_Unlock
}
#
#########################################################################################################
# UNLOCKING A USER [ @ ]
#########################################################################################################
#
# Unlock Owner
function Func_DB_Owner_Unlock()
{
varDB_OWNER=""
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- ENTER THE NAME OF THE OWNER or ENTER TO FINISH --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
read varDB_OWNER
if [[ "${varDB_OWNER}" = "" ]]; then
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- NO OWNER SELECTED --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
else
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- WAIT A MOMENT PLEASE, THE OWNER UNLOCK IS RUNNING --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
varDB_OWNER=$(echo ${varDB_OWNER} | tr [a-z] [A-Z])
typeset -u varDB_OWNER
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
alter user ${varDB_OWNER} account unlock;
quit;
EOF
fi
}
#
#########################################################################################################
# LOCKING A USER [ @ ]
#########################################################################################################
#
# NON PDB
function Func_DB_063()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
prompt ##############################################################
prompt # LOCKING A USER [ @ ]
prompt ##############################################################
col username for a30
col profile for a30
select user_id
  , username
  , account_status
  , default_tablespace
  , profile 
from dba_users
where account_status = 'OPEN'
order by 2;
quit;
EOF
Func_DB_Owner_Lock
}
#
#########################################################################################################
# LOCKING A USER [ @ ]
#########################################################################################################
#
# Lock Owner
function Func_DB_Owner_Lock()
{
varDB_OWNER=""
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- ENTER THE NAME OF THE OWNER or ENTER TO FINISH --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
read varDB_OWNER
if [[ "${varDB_OWNER}" = "" ]]; then
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- NO OWNER SELECTED --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
else
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- WAIT A MOMENT PLEASE, THE OWNER UNLOCK IS RUNNING --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
varDB_OWNER=$(echo ${varDB_OWNER} | tr [a-z] [A-Z])
typeset -u varDB_OWNER
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
alter user ${varDB_OWNER} account lock;
quit;
EOF
fi
}
#########################################################################################################
# REDO GROUPS INFORMATIONS
#########################################################################################################
#
# NON PDB
function Func_DB_064()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
col member FORMAT A90
col group# format 999
col status for a15
col TOTAL_MB format 999,999,999,999
col TOTAL_GB format 999,999,999,999
col TOTAL_MB for a20
col TOTAL_GB for a20
break on report
break on top_stat_name skip 1
compute sum of TOTAL_MB on report
compute sum of TOTAL_GB on report
cl break
prompt ##############################################################
prompt # OnLine RedoLogs                                            #
prompt ##############################################################
select t1.GROUP#
   , t1.TYPE
   , t2.status
   , t1.MEMBER
   , t1.IS_RECOVERY_DEST_FILE
   , to_char(t2.bytes/1024/1024, '9G999G999D999') TOTAL_MB
   , to_char(t2.bytes/1024/1024/1024, '999D999') TOTAL_GB
from v\$logfile t1, v\$log t2
where t1.group# = t2.group#
order by 1,2,3,4;
prompt
prompt ##############################################################
prompt # Standby RedoLogs                                           #
prompt ##############################################################
select s1.group#
  , s2.THREAD#
  , s1.type
  , s2.status
  , s1.member
  , 'N/A' as "N/A"
  , to_char(s2.bytes/1024/1024, '9G999G999D999') TOTAL_MB
  , to_char(s2.bytes/1024/1024/1024, '999D999') TOTAL_GB
from v\$logfile s1, v\$standby_log s2
where s1.group# = s2.group#
and s1.type = 'STANDBY'
order by 1,2,3,4;
prompt
prompt ##############################################################
prompt # Archiving Details                                          #
prompt ##############################################################
select PROCESS
  , STATUS
  , THREAD#
  , SEQUENCE#
  , BLOCK#
  , BLOCKS
FROM V\$MANAGED_STANDBY;
prompt
prompt ##############################################################
prompt # Utilization of Current Redo Log ( in % )                   #
prompt ##############################################################
select le.leseq "Current log sequence No"
  , 100*cp.cpodr_bno/le.lesiz "Percent Full"
  , cp.cpodr_bno "Current Block No"
  , le.lesiz "Size of Log in Blocks" 
from x\$kcccp cp, x\$kccle le 
where le.leseq =CP.cpodr_seq 
and bitand(le.leflg,24) = 8 
/
quit;
EOF
}
#
#########################################################################################################
# Show All Corrupted Objects
#########################################################################################################
#
# NON PDB
function Func_DB_065()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
prompt ##############################################################
prompt # Show All Corrupted Objects
prompt ##############################################################
select e.owner
  , e.segment_type
  , e.segment_name
  , e.partition_name
  , c.file#
  , greatest(e.block_id, c.block#) corr_start_block#
  , least(e.block_id+e.blocks-1
  , c.block#+c.blocks-1) corr_end_block#
  , least(e.block_id+e.blocks-1, c.block#+c.blocks-1)- greatest(e.block_id, c.block#) + 1 blocks_corrupted
  , null description
FROM dba_extents e, v\$database_block_corruption c
WHERE e.file_id = c.file#
AND e.block_id <= c.block# + c.blocks - 1
AND e.block_id + e.blocks - 1 >= c.block#
UNION
select s.owner
  , s.segment_type
  , s.segment_name
  , s.partition_name
  , c.file#
  , header_block corr_start_block#
  , header_block corr_end_block#
  , 1 blocks_corrupted
  , 'Segment Header' description
FROM dba_segments s, v\$database_block_corruption c
WHERE s.header_file = c.file#
AND s.header_block between c.block#
and c.block# + c.blocks - 1
UNION
select null owner
  , null segment_type
  , null segment_name
  , null partition_name
  , c.file#
  , greatest(f.block_id, c.block#) corr_start_block#
  , least(f.block_id+f.blocks-1, c.block#+c.blocks-1) corr_end_block#
  , least(f.block_id+f.blocks-1, c.block#+c.blocks-1) - greatest(f.block_id, c.block#) + 1 blocks_corrupted
  , 'Free Block' description
FROM dba_free_space f, v\$database_block_corruption c
WHERE f.file_id = c.file#
AND f.block_id <= c.block# + c.blocks - 1
AND block_id + f.blocks - 1 >= c.block#
order by file#, corr_start_block#;
quit;
EOF
}
#
#########################################################################################################
# VERIFY SPACE OF FLASH RECOVERY AREA
#########################################################################################################
#
# NON PDB
function Func_DB_066()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY SPACE OF FLASH RECOVERY AREA
prompt ##############################################################
col name for a75
col size_m for 999,999,999
col used_m for 999,999,999
col "% USED" for a30
select name
   , ceil(space_limit/1024/1024) SIZE_M
   , ceil(space_used/1024/1024) USED_M
   , case when ceil((space_used/space_limit)*100) < 80 then ceil((space_used/space_limit)*100) || '% - Status OK' when ceil((space_used/space_limit)*100) < 90 then ceil((space_used/space_limit)*100) || '% - Warning' else ceil((space_used/space_limit)*100) || '% - Critical' end as "% USED"
-- , decode(nvl(space_used, 2), 0, 0) as "#"
FROM v\$recovery_file_dest
ORDER BY name;
prompt
prompt ##############################################################
prompt # VERIFY SPACE OF FLASH RECOVERY AREA - DETAILS
prompt ##############################################################
col "Status Space" for a20
select FILE_TYPE
   , PERCENT_SPACE_USED
   , PERCENT_SPACE_RECLAIMABLE
   , NUMBER_OF_FILES
-- , CON_ID
   , case when PERCENT_SPACE_USED < 80 then 'Space OK' when PERCENT_SPACE_USED < 90 then 'Warning' else 'Critical' end as "Status Space"
FROM V\$RECOVERY_AREA_USAGE;
quit;
EOF
}
#
#########################################################################################################
# VERIFY PLUGGABLE DATABASES
#########################################################################################################
#
function Func_DB_067()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_067
else
  Func_DB_PDB_067
fi
}
# PDB
function Func_DB_PDB_067()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on colsep '|'
prompt ##############################################################
prompt # PLUGGABLE DATABASES                                        #
prompt ##############################################################
select CON_ID
  , NAME
  , OPEN_MODE
  , DBID
  , CON_UID
  , GUID 
FROM V\$CONTAINERS 
ORDER BY CON_ID;
Prompt
prompt ##############################################################
prompt # Verify Violations on PDBs Database                         #
prompt ##############################################################
col time for a20
col message for a150
select to_char(time, 'dd/mm/yyyy hh24:mi:ss') as time
  , message 
from pdb_plug_in_violations;
Prompt
prompt ##############################################################
prompt # Verify Snapshots on PDBs Database                          #
prompt ##############################################################
col pdb_name for a10
col snapshot_mode for a15
select p.con_id
  , p.pdb_name
  , p.snapshot_mode
  , p.snapshot_interval
FROM cdb_pdbs p
ORDER BY 1;
Prompt
prompt ##############################################################
prompt # Verify Properties of Snapshots on PDBs Database            #
prompt ##############################################################
col property_name for a20
col pdb_name for a10
col property_value for a15
col description for a50
select pr.con_id
  , p.pdb_name
  , pr.property_name
  , pr.property_value
  , pr.description 
FROM cdb_properties pr
JOIN cdb_pdbs p ON pr.con_id = p.con_id 
WHERE pr.property_name = 'MAX_PDB_SNAPSHOTS' 
ORDER BY pr.property_name;
Prompt
prompt ##############################################################
prompt # Verify Availabilitt of Snapshots on PDBs Database          #
prompt ##############################################################
col con_name for a10
col snapshot_name for a30
col snapshot_scn for 9999999
col full_snapshot_path for a50
select con_id
  , con_name
  , snapshot_name
  , snapshot_scn
  , full_snapshot_path 
FROM cdb_pdb_snapshots
ORDER BY con_id, snapshot_scn;
Prompt
prompt ##############################################################
prompt # Verify Snapshots JOBS on PDBs Database                     #
prompt ##############################################################
col owner for a10
col job_name for a30
col repeat_interval for a50
select owner
  , job_name
  , repeat_interval
FROM dba_scheduler_jobs
WHERE job_name LIKE '%SNAPSHOT'
ORDER BY owner, job_name;
prompt
prompt ##############################################################
prompt # Verify Snapshots Refresh on PDBs Database                  #
prompt ##############################################################
select status
  , refresh_mode
from dba_pdbs;
prompt
prompt ##############################################################
prompt # Verify The History of PDBs Database                        #
prompt ##############################################################
col db_name for a10 
col CLONED_FROM_PDB_NAME for a25 
col pdb_name for a18 
select DB_NAME
  , CON_ID
  , PDB_NAME
  , OPERATION
  , to_char(OP_TIMESTAMP, 'dd/mm/yyyy hh24:mi:ss') as time
  , CLONED_FROM_PDB_NAME
FROM CDB_PDB_HISTORY;
prompt
prompt ##############################################################
prompt # Check Undo Mode in Multitenant DB                          #
prompt ##############################################################
select * from database_properties 
where property_name = 'LOCAL_UNDO_ENABLED';
prompt
quit;
EOF
}
#
#########################################################################################################
# Multitenant : PDB Snapshot Carousel in Oracle Database 18c
# ONLY FOR 18c
# alter system set "_exadata_feature_on"=true scope=spfile;
# ALTER SESSION SET CONTAINER = pdb2;
# ALTER PLUGGABLE DATABASE SNAPSHOT MODE EVERY 2999 MINUTES;
# ALTER PLUGGABLE DATABASE SNAPSHOT MODE EVERY 1999 HOURS;
# ALTER PLUGGABLE DATABASE SNAPSHOT MODE MANUAL;
# ALTER PLUGGABLE DATABASE SNAPSHOT MODE NONE;
# ALTER PLUGGABLE DATABASE SNAPSHOT MODE EVERY 24 HOURS;
# ALTER PLUGGABLE DATABASE SET MAX_PDB_SNAPSHOTS=0;
# ALTER PLUGGABLE DATABASE SET MAX_PDB_SNAPSHOTS=8;
# ALTER PLUGGABLE DATABASE SNAPSHOT;
# ALTER PLUGGABLE DATABASE SNAPSHOT my_snapshot;
# ALTER PLUGGABLE DATABASE DROP SNAPSHOT SNAP_688979926_996491289;
# ALTER PLUGGABLE DATABASE DROP SNAPSHOT my_snapshot;
# ALTER SYSTEM SET DB_CREATE_FILE_DEST = '/u02/oradata';
# CREATE PLUGGABLE DATABASE pdb2_copy FROM pdb2 USING SNAPSHOT SNAP_688979926_996491631 SNAPSHOT MODE EVERY 24 HOURS;
# ALTER PLUGGABLE DATABASE pdb2_copy OPEN;
#
# BEGIN
#  DBMS_SCHEDULER.set_attribute (
#    name      => 'PDB2_688979926_SNAPSHOT',
#    attribute => 'REPEAT_INTERVAL',
#    value     => 'FREQ=HOURLY; INTERVAL=24; BYMINUTE=15;');
# END;
# /
#
# ALTER PLUGGABLE DATABASE REFRESH MODE MANUAL FROM pdb5@clone_link SWITCHOVER;
# ALTER PLUGGABLE DATABASE OPEN READ ONLY;
# CREATE PLUGGABLE DATABASE pdb5_ro FROM pdb5@clone_link REFRESH MODE MANUAL;
# 
# ALTER PLUGGABLE DATABASE CLOSE IMMEDIATE;
# ALTER PLUGGABLE DATABASE REFRESH;
# ALTER PLUGGABLE DATABASE OPEN READ ONLY;
#########################################################################################################
#
#########################################################################################################
# VERIFY CONTROLFILES
#########################################################################################################
#
# NON PDB
function Func_DB_068()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY CONTROLFILES
prompt ##############################################################
col name for a120
select name
  , status
  , IS_RECOVERY_DEST_FILE
  , BLOCK_SIZE/1024 as BLOCK_SIZE_MB
from v\$controlfile;
quit;
EOF
}
#
#########################################################################################################
# VERIFY CONSUME PER CPU
#########################################################################################################
#
# NON PDB
function Func_DB_069()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|' feedback off trimspool on
prompt ##############################################################
prompt # VERIFY CONSUME PER CPU
prompt ##############################################################
COLUMN wait_class format a20
COLUMN name       format a55
COLUMN time_sec   format 999,999,999,999.99
COLUMN time_min   format 999,999,999,999,999.99
COLUMN time_hou   format 999,999,999,999,999,999.99
COLUMN time_day   format 999,999,999,999,999,999,999.99
COLUMN pct        format 999,99
COLUMN "% Used"   format a8 JUSTIFY RIGHT
select wait_class
   , NAME
   , ROUND(time_secs, 2) time_sec
   , ROUND(time_secs/60, 2) time_min
   , ROUND(time_secs/60/60, 2) time_hou
   , ROUND(time_secs/60/60/24, 2) time_day
   , ' ' || ROUND(time_secs * 100 / SUM (time_secs) OVER (), 2) || '%' as "% Used"
FROM (select n.wait_class, e.event NAME, e.time_waited / 100 time_secs FROM v\$system_event e, v\$event_name n WHERE n.NAME = e.event AND n.wait_class <> 'Idle' AND time_waited > 0
      UNION
      select 'CPU', 'server CPU', SUM (VALUE / 1000000) time_secs FROM v\$sys_time_model WHERE stat_name IN ('background cpu time', 'DB CPU'))
-- where ROUND(time_secs*100/SUM(time_secs) OVER (), 2) > 0
-- where "% Used" > 0
ORDER BY time_sec DESC;
quit;
EOF
}
#
#########################################################################################################
# QUICK TUNE
#########################################################################################################
#
# NON PDB
function Func_DB_070()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|' feedback off trimspool on echo off wrap off
prompt ##############################################################
prompt # QUICK TUNE
prompt ##############################################################
COL "MEMORY TYPE" FOR A16
--HEAD "SGA + RATIOS"
--COL "Total_Mem(Ko)" FOR A12
--COL "Free(Ko)" FOR A8
COL "###" FOR A3
COL "MEMORY RATIOS" FOR A28
COL "RATIO %" FOR A7
COL IDEAL FOR A8 ;
compute sum of "Total_Mem K" on report
compute sum of "Free K" on report
break on report ;
select pool as "MEMORY TYPE"
  , Total_Mem as "ALLOCATION K"
  , Free_Mem as "FREE K"
  , '###' "###"
  , RUBRIQUE "MEMORY RATIOS"
  , to_char(round(RATIO*100,1),'999.9') "RATIO %"
  , IDEAL
from (select rownum0, A.pool, A.Total_Mem, B.Free_Mem from (select (rownum) rownum0, A.* from (select pool, round(sum(bytes)/1024,0) Total_Mem from v\$sgastat where pool is not null group by pool
UNION
select name, round(bytes/1024) from v\$sgastat where pool is null and name !='fixed_sga') A
UNION ALL
select 6,'Sort Area Size' ,round(value/1024,0) from v\$parameter where name in ('sort_area_size')
UNION ALL
select 7,'Hash Area Size' ,round(value/1024,0) from v\$parameter where name in ('hash_area_size')) A, (select pool, round(bytes/1024,0) Free_Mem from v\$sgastat where name = 'free memory'
UNION ALL
select 'db_block_buffers', (select count(*) from v\$bh where status='free')*(select (round(value/1024,0)) from v\$parameter where name = 'db_block_size') from dual ) B where A.pool=B.pool(+)) SGA, (select 6 rownum0, 'DATA DICTIONARY CACHE' "RUBRIQUE", sum(getmisses)/sum(gets) "RATIO", ' < 15 %' "IDEAL" from v\$rowcache
UNION ALL
select 3,'SHARED POOL HIT RATIO',sum(pinhits-reloads)/sum(pins),' > 85 %' from v\$librarycache
UNION ALL
select 4 ,'SHARED POOL RELOAD %',sum (reloads)/sum(pins), ' <  2 %' from v\$librarycache
UNION ALL
select 2,'BUFFER CACHE Hit Ratio', (1-(sum(decode(name, 'physical reads', value, 0))/(sum(decode(name, 'db block gets',value,0)) + (sum(decode(name,'consistent gets', value, 0)))))), ' > 95 %' from v\$sysstat
UNION ALL
select 1,'BUFFER CACHE MISS RATIO', ((G-F)/(G-F+C+E)),' < 15 %' from (select sum(value) C  from v\$sysstat where name like '%- consistent read gets') c, (select value E from v\$sysstat where name = 'db block gets') e, (select value F from v\$sysstat where name = 'physical reads direct') f, (select value G from v\$sysstat where name = 'physical reads') g
UNION ALL
select 5, 'LOG BUFFER REQUESTS Ratio', -- '#Redo Space requests/#redo entries'
((req.value * 50)/entries.value), ' < 0.02%' from v\$sysstat req, v\$sysstat entries where req.name='redo log space requests' and entries.name = 'redo entries'
UNION ALL
select 7,'MEM SORTS/TOTAL SORTS', mem.value/(mem.value+disk.value),' > 95 %' from v\$sysstat mem, v\$sysstat disk where mem.name = 'sorts (memory)' and disk.name = 'sorts (disk)') RATIOS where SGA.rownum0(+) = RATIOS.ROWNUM0 order by SGA.rownum0 asc;
quit;
EOF
}
#
#########################################################################################################
# VERIFY RECOMENDATIONS TUNING TOP 20 [ @ ]
#########################################################################################################
#
# NON PDB
function Func_DB_071()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|' feedback on trimspool on echo off wrap off
DEF days_of_history_accessed = '31';
DEF captured_at_least_x_times = '10';
DEF captured_at_least_x_days_apart = '5';
DEF med_elap_microsecs_threshold = '1e4';
DEF min_slope_threshold = '0.1';
DEF max_num_rows = '20';
SET lin 200 ver OFF;
COL SLOPE for a15
COL row_n FOR A2 HEA '#';
COL med_secs_per_exec HEA 'Median Secs|Per Exec' for a20;
COL std_secs_per_exec HEA 'Std Dev Secs|Per Exec';
COL avg_secs_per_exec HEA 'Avg Secs|Per Exec';
COL min_secs_per_exec HEA 'Min Secs|Per Exec';
COL max_secs_per_exec HEA 'Max Secs|Per Exec';
COL plans FOR 9999;
COL sql_text_80 FOR A75;
prompt
prompt ##############################################################
prompt # SQL Statements with "Elapsed Time per Execution" changing over time
prompt ##############################################################
WITH
per_time AS (
select h.dbid
   , h.sql_id
   , SYSDATE - CAST(s.end_interval_time AS DATE) days_ago
   , SUM(h.elapsed_time_total) / SUM(h.executions_total) time_per_exec
FROM  dba_hist_sqlstat h, dba_hist_snapshot s
WHERE h.executions_total > 0
AND s.snap_id = h.snap_id
AND s.dbid = h.dbid
AND s.instance_number = h.instance_number
AND CAST(s.end_interval_time AS DATE) > SYSDATE - &&days_of_history_accessed
GROUP BY h.dbid, h.sql_id, SYSDATE - CAST(s.end_interval_time AS DATE)),
avg_time AS (
select dbid
   , sql_id
   , MEDIAN(time_per_exec) med_time_per_exec
   , STDDEV(time_per_exec) std_time_per_exec
   , AVG(time_per_exec)    avg_time_per_exec
   , MIN(time_per_exec)    min_time_per_exec
   , MAX(time_per_exec)    max_time_per_exec
FROM per_time
GROUP BY dbid, sql_id
HAVING COUNT(*) >= &&captured_at_least_x_times
AND MAX(days_ago) - MIN(days_ago) >= &&captured_at_least_x_days_apart
AND MEDIAN(time_per_exec) > &&med_elap_microsecs_threshold),
time_over_median AS (
select h.dbid
   ,  h.sql_id
   ,  h.days_ago
   ,  (h.time_per_exec / a.med_time_per_exec) time_per_exec_over_med
   ,  a.med_time_per_exec
   ,  a.std_time_per_exec
   ,  a.avg_time_per_exec
   ,  a.min_time_per_exec
   ,  a.max_time_per_exec
FROM per_time h, avg_time a WHERE a.sql_id = h.sql_id),
ranked AS (
select RANK () OVER (ORDER BY ABS(REGR_SLOPE(t.time_per_exec_over_med, t.days_ago)) DESC) rank_num
   ,  t.dbid
   ,  t.sql_id
   ,  CASE WHEN REGR_SLOPE(t.time_per_exec_over_med, t.days_ago) > 0 THEN 'IMPROVING' ELSE 'REGRESSING' END change
   ,  ROUND(REGR_SLOPE(t.time_per_exec_over_med, t.days_ago), 3) slope
   ,  ROUND(AVG(t.med_time_per_exec)/1e6, 3) med_secs_per_exec
   ,  ROUND(AVG(t.std_time_per_exec)/1e6, 3) std_secs_per_exec
   ,  ROUND(AVG(t.avg_time_per_exec)/1e6, 3) avg_secs_per_exec
   ,  ROUND(MIN(t.min_time_per_exec)/1e6, 3) min_secs_per_exec
   ,  ROUND(MAX(t.max_time_per_exec)/1e6, 3) max_secs_per_exec
FROM time_over_median t
GROUP BY t.dbid, t.sql_id
HAVING ABS(REGR_SLOPE(t.time_per_exec_over_med, t.days_ago)) > &&min_slope_threshold)
select LPAD(ROWNUM, 2) row_n
   ,  r.sql_id
   ,  r.change
   ,  TO_CHAR(r.slope, '990.000MI') slope
   ,  TO_CHAR(r.med_secs_per_exec, '999,990.000') med_secs_per_exec
   ,  TO_CHAR(r.std_secs_per_exec, '999,990.000') std_secs_per_exec
   ,  TO_CHAR(r.avg_secs_per_exec, '999,990.000') avg_secs_per_exec
   ,  TO_CHAR(r.min_secs_per_exec, '999,990.000') min_secs_per_exec
   ,  TO_CHAR(r.max_secs_per_exec, '999,990.000') max_secs_per_exec
   ,  (select COUNT(DISTINCT p.plan_hash_value) FROM dba_hist_sql_plan p WHERE p.dbid = r.dbid AND p.sql_id = r.sql_id) plans
--  ,  REPLACE((select DBMS_LOB.SUBSTR(s.sql_text, 80) FROM dba_hist_sqltext s WHERE s.dbid = r.dbid AND s.sql_id = r.sql_id), CHR(10)) sql_text_80
FROM ranked r
WHERE r.rank_num <= &&max_num_rows
ORDER BY r.rank_num
/
quit;
EOF
}
#
#########################################################################################################
# VERIFY TOP 20 TUNING HISTORY [ @ ]
#########################################################################################################
#
function Func_DB_072()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_072
else
  Func_DB_NON_PDB_072
fi
}
# PDB
function Func_DB_PDB_072()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 700 lines 700 timing on colsep '|' feedback off trimspool on echo off heading on wrap off
prompt
prompt ##############################################################
prompt # VERIFY TOP 20 TUNING HISTORY [ @ ]
prompt ##############################################################
select * from (select SQL_ID ,
sum(decode(session_state,'ON CPU',1,0)) as CPU,
sum(decode(session_state,'WAITING',1,0)) - sum(decode(session_state, 'WAITING', decode(wait_class, 'User I/O',1,0),0)) as WAIT,
sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as IO,
sum(decode(session_state,'ON CPU',1,1)) as TOTAL
from v\$active_session_history
where SQL_ID is not NULL
group by sql_id
order by sum(decode(session_state,'ON CPU',1,1)) desc)
where rownum < 21;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_072()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|' feedback off trimspool on echo off heading on wrap off
prompt ##############################################################
prompt # VERIFY TOP 20 TUNING HISTORY [ @ ]
prompt ##############################################################
select * from (select SQL_ID ,
sum(decode(session_state,'ON CPU',1,0)) as CPU,
sum(decode(session_state,'WAITING',1,0)) - sum(decode(session_state, 'WAITING', decode(wait_class, 'User I/O',1,0),0)) as WAIT,
sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as IO,
sum(decode(session_state,'ON CPU',1,1)) as TOTAL
from v\$active_session_history
where SQL_ID is not NULL
group by sql_id
order by sum(decode(session_state,'ON CPU',1,1)) desc)
where rownum < 21;
quit;
EOF
}
#
#########################################################################################################
# VERIFY BACKGROUND PROCESSESS
#########################################################################################################
#
# NON PDB
function Func_DB_073()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|' feedback off trimspool on echo off wrap off
prompt ##############################################################
prompt # VERIFY BACKGROUND PROCESSESS
prompt ##############################################################
select min(name || ': '|| description) process_description
FROM v\$bgprocess group by substr(name,1,3)
ORDER BY 1;
quit;
EOF
}
#
#########################################################################################################
# TOP 100 QUERY RECOMMENDATIONS
#########################################################################################################
#
# NON PDB
function Func_DB_074()
{
read
${ORACLE_HOME}/perl/bin/perl <<EOF
#!/usr/bin/perl
# -------------------------------------------------------------------------------------
# Performance Script
# -------------------------------------------------------------------------------------
local Hostname=${1};
local Database=${2};
local Port=${3};
local Username=${3};
local Password=${4};
local Schema=${5};
local AutoImplement=${6};
local Top=${7};
# -------------------------------------------------------------------------------------
# perl AutoDBMS_SQLTUNE.pl HOSTNAME SERVICE PORT USERNAME PASSWORD SCHEMA AUTOIMPLEMENT TOPSQL
# perl AutoDBMS_SQLTUNE.pl nerv01 prod 1521 PORTILHO Nerv2008 SOE N 10
# -------------------------------------------------------------------------------------
use strict;
use warnings;
use DBD::Oracle qw(:ora_session_modes);
# -------------------------------------------------------------------------------------
# Versão 2.00.
# -------------------------------------------------------------------------------------
# Oracle Variable Connections
# -------------------------------------------------------------------------------------
my $Hostname = $ARGV[0];
my $Database = $ARGV[1];
my $Port = $ARGV[2];
my $Username = $ARGV[3];
my $Password = $ARGV[4];
my $Schema = $ARGV[5];
my $AutoImplement = $ARGV[6];
my $Top = $ARGV[7];
# -------------------------------------------------------------------------------------
# Which is the creterie of SQLs to be analyze and in which order?
# -------------------------------------------------------------------------------------
my @Order = ('ELAPSED_TIME', 'CPU_TIME', 'DISK_READS', 'BUFFER_GETS', 'DIRECT_WRITES', 'SORTS');
# -------------------------------------------------------------------------------------
my $oracle_dbh = DBI->connect("dbi:Oracle:host=$Hostname;service_name=$Database;port=$Port", $Username, $Password, {RaiseError => 1, AutoCommit => 0, ora_session_mode => ORA_SYSDBA});
$oracle_dbh->{LongReadLen} = 20*1024*1024; # 20MB
# -------------------------------------------------------------------------------------
open(LOG, '>AutoDBMS_SQLTUNE.log') || die ("Could not open file!");
# -------------------------------------------------------------------------------------
# Remove the Tuning Task Pack if it exists already.
# -------------------------------------------------------------------------------------
my $task_exist = 0;
my $oracle_sql_01 = "select TASK_ID FROM DBA_ADVISOR_TASKS WHERE OWNER = 'SYS' AND TASK_NAME = 'Auto DBMS_SQLTUNE Tuning Task'";
my $oracle_sth_01 = $oracle_dbh->prepare($oracle_sql_01);
$oracle_sth_01->execute();
while (my $oracle_ref_01 = $oracle_sth_01->fetchrow_hashref())
{
  $task_exist++;
}
$oracle_sth_01->finish();
if ($task_exist > 0)
{
  my $oracle_sql_02 = "BEGIN DBMS_SQLTUNE.DROP_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task'); END;";
  my $oracle_sth_02 = $oracle_dbh->prepare($oracle_sql_02);
  $oracle_sth_02->execute();
  $oracle_sth_02->finish();
}

foreach (@Order)
{
  my $Order = $_;
  print "\nAnalisando os TOP $Top SQLs ordenados por $Order...\n\n";
  print LOG "\nAnalisando os $Top 100 SQLs ordenados por $Order...\n\n";
# -------------------------------------------------------------------------------------
# Search for the Top SQLs.
# -------------------------------------------------------------------------------------
my $oracle_sql_03 = "select SQL_ID, SQL_TEXT FROM (select SQL_ID, SQL_TEXT FROM GV\$SQL WHERE PARSING_SCHEMA_NAME = '$Schema' ORDER BY $Order) WHERE ROWNUM < $Top";
my $oracle_sth_03 = $oracle_dbh->prepare($oracle_sql_03);
$oracle_sth_03->execute();
while (my $oracle_ref_03 = $oracle_sth_03->fetchrow_hashref())
{
  my $sql_id = $oracle_ref_03->{SQL_ID};
  my $sql_text = $oracle_ref_03->{SQL_TEXT};
# -------------------------------------------------------------------------------------
# Verify if the SQL stil exists.
# -------------------------------------------------------------------------------------
  my $sql_exist = 0;
  my $oracle_sql_04 = "select SQL_TEXT FROM V\$SQL WHERE SQL_ID= '$sql_id'";
  my $oracle_sth_04 = $oracle_dbh->prepare($oracle_sql_04);
  $oracle_sth_04->execute();
  while (my $oracle_ref_04 = $oracle_sth_04->fetchrow_hashref())
  {
    $sql_exist++;
  }
  $oracle_sth_04->finish();
# -------------------------------------------------------------------------------------
# Execute the Tuning Task
# -------------------------------------------------------------------------------------
  if ($sql_exist > 0)
  {
  my $oracle_sql_05 = "DECLARE RET_VAL VARCHAR2(4000); BEGIN RET_VAL := DBMS_SQLTUNE.CREATE_TUNING_TASK(SQL_ID => '$sql_id', SCOPE => DBMS_SQLTUNE.SCOPE_COMPREHENSIVE, TIME_LIMIT => 600, TASK_NAME => 'Auto DBMS_SQLTUNE Tuning Task', DESCRIPTION => 'Auto DBMS_SQLTUNE Tuning Task'); END;";
  my $oracle_sth_05 = $oracle_dbh->prepare($oracle_sql_05);
  $oracle_sth_05->execute();
  $oracle_sth_05->finish();

  my $oracle_sql_06 = "BEGIN DBMS_SQLTUNE.EXECUTE_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task'); END;";
  my $oracle_sth_06 = $oracle_dbh->prepare($oracle_sql_06);
  $oracle_sth_06->execute();
  $oracle_sth_06->finish();
# -------------------------------------------------------------------------------------
# Show the Recomendations.
# -------------------------------------------------------------------------------------
  my $oracle_sql_07 = "select DBMS_SQLTUNE.REPORT_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task') RECOMMENTATION FROM DUAL";
  my $oracle_sth_07 = $oracle_dbh->prepare($oracle_sql_07);
  $oracle_sth_07->execute();
  while (my $oracle_ref_07 = $oracle_sth_07->fetchrow_hashref())
  {
    my $recommendation = $oracle_ref_07->{RECOMMENTATION};
    print "$recommendation\n\n";
    print LOG "$recommendation\n\n";
  }
# -------------------------------------------------------------------------------------
# Execute the Recomendations.
# -------------------------------------------------------------------------------------
  my $oracle_sql_08 = "select DBMS_SQLTUNE.SCRIPT_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task') RECOMMENTATION FROM DUAL";
  my $oracle_sth_08 = $oracle_dbh->prepare($oracle_sql_08);
  $oracle_sth_08->execute();
  while (my $oracle_ref_08 = $oracle_sth_08->fetchrow_hashref())
  {
    my $recommendation = $oracle_ref_08->{RECOMMENTATION};
    if ($recommendation !~ m/There are no recommended actions for this task under the given filters./)
    {
      my @CompleteRecommendation =  split /\n/, $recommendation;
      foreach (@CompleteRecommendation)
      {
        my $RecommendationLine = $_;
        unless ($RecommendationLine =~ /;/gm) {next;}

        if ($RecommendationLine =~ /^create index /) {$RecommendationLine =~ s/;//;}
        if ($RecommendationLine =~ /^execute /) {$RecommendationLine =~ s/execute //; $RecommendationLine = "BEGIN $RecommendationLine END;";}
        my $oracle_sql_09 = "$RecommendationLine";
        my $oracle_sth_09 = $oracle_dbh->prepare($oracle_sql_09);
        print "Recommendation to implement: $RecommendationLine\n\n";
        print LOG "Recommendation to implement:: $RecommendationLine\n\n";

        my $YesOrNo;
        print "Do you wish to implement it? (Y/N)";
        if ($AutoImplement eq 'Y')
        {
          $YesOrNo = 'Y';
        }
        else
        {
          $YesOrNo = <STDIN>;
          chomp $YesOrNo;
        }
							
        if ($YesOrNo eq 'Y')
        {
          $oracle_sth_09->execute();
          $oracle_sth_09->finish();
          print "Recommendation IMPLEMENTED.\n\n";
          print LOG "Recommendation IMPLEMENTED.\n\n";
          last;
        }
        elsif ($YesOrNo eq 'N')
        {
          print "Recommendation NOT IMPLEMENTED.\n\n";
          print LOG "Recommendation NOT IMPLEMENTED.\n\n";
          last;
        }
        else
        {
          print "\nWell, I don´t know what to do...\n";
          print LOG "\nWell, I don´t know what to do...\n";
        }
        }
    }
      print "\n\n\n\n\n";
    }
    $oracle_sth_08->finish();

    my $oracle_sql_10 = "BEGIN DBMS_SQLTUNE.DROP_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task'); END;";
    my $oracle_sth_10 = $oracle_dbh->prepare($oracle_sql_10);
    $oracle_sth_10->execute();
    $oracle_sth_10->finish();
    }
  }
  $oracle_sth_03->finish();
}
$oracle_dbh->disconnect;
exit;
EOF
}
#
#########################################################################################################
# VERIFY DYNAMICS PARAMETERS [ SPFILE ]
#########################################################################################################
#
# NON PDB
function Func_DB_075()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|' feedback off trimspool on echo off wrap off
prompt ##############################################################
prompt # VERIFY DYNAMICS PARAMETERS [ SPFILE ]
prompt ##############################################################
col sid for a10
col name for a45
col type for a15
col display_value for a100
select sid
  , name
  , type
  , display_value
from v\$spparameter
order by name;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DBA FEATURES USAGE STATISTICS
#########################################################################################################
#
# NON PDB
function Func_DB_076()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|' feedback off trimspool on echo off wrap off
prompt ##############################################################
prompt # VERIFY DBA FEATURES USAGE STATISTICS
prompt ##############################################################
alter session set nls_date_format='dd/mm/yyyy';
col "NAME" for a70
col "DETECTED USAGES" for a20
col "USING NOW Y/N" for a15
select name
  , case when DETECTED_USAGES = 0 then 'Never Used' else to_char(DETECTED_USAGES) || ' Time(s) Used' end as "DETECTED USAGES"
  , case when CURRENTLY_USED = 'FALSE' then 'Not Using' when CURRENTLY_USED = 'TRUE' then 'Using' else 'UNKNOWN' end as "USING NOW Y/N"
  , FIRST_USAGE_DATE
  , LAST_USAGE_DATE
from dba_feature_usage_statistics a, v\$instance b
where a.version = b.version
order by 1;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DBA HIGH WATER MARK STATISTICS
#########################################################################################################
#
# NON PDB
function Func_DB_077()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
prompt ##############################################################
prompt # VERIFY DBA HIGH WATER MARK STATISTICS
prompt ##############################################################
col NAME for a30
col VERSION for a15
col HIGHWATER for a20
col LAST_VALUE for a20
col DESCRIPTION for a70
select distinct a.NAME
  , a.VERSION
  , to_char(HIGHWATER) as HIGHWATER
  , to_char(LAST_VALUE) as LAST_VALUE
  , DESCRIPTION
from DBA_HIGH_WATER_MARK_STATISTICS a, v\$instance b
where a.version = b.version
order by 1,2;
quit;
EOF
}
#
#########################################################################################################
# GLOBAL INFORMATION ABOUT I/O
#########################################################################################################
#
# NON PDB
function Func_DB_078()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|' feedback off trimspool on echo off wrap off;
prompt ##############################################################
prompt # REPORT SQL MONITOR                                         #
prompt ##############################################################
select dbms_sqltune.report_sql_monitor from dual;
prompt
prompt ##############################################################
prompt # GLOBAL INFORMATION ABOUT I/O                               #
prompt ##############################################################
set pages 700 lines 700 timing on long 10000000 longchunksize 10000000 colsep '|'
set lin 200 ver off;
COL instance_number FOR 9999 HEA 'Inst';
COL end_time HEA 'End Time';
COL plan_hash_value HEA 'Plan|Hash Value';
COL executions_total FOR 999,999 HEA 'Execs|Total';
COL rows_per_exec HEA 'Rows Per Exec';
COL et_secs_per_exec HEA 'Elap Secs|Per Exec';
COL cpu_secs_per_exec HEA 'CPU Secs|Per Exec';
COL io_secs_per_exec HEA 'IO Secs|Per Exec';
COL cl_secs_per_exec HEA 'Clus Secs|Per Exec';
COL ap_secs_per_exec HEA 'App Secs|Per Exec';
COL cc_secs_per_exec HEA 'Conc Secs|Per Exec';
COL pl_secs_per_exec HEA 'PLSQL Secs|Per Exec';
COL ja_secs_per_exec HEA 'Java Secs|Per Exec';
select h.instance_number
   , TO_CHAR(CAST(s.end_interval_time AS DATE), 'DD/MM/YYYY HH24:MI:SS') end_time
   , h.plan_hash_value
   , h.executions_total
   , TO_CHAR(ROUND(h.rows_processed_total / h.executions_total), '999,999,999,999') rows_per_exec
   , TO_CHAR(ROUND(h.elapsed_time_total / h.executions_total / 1e6, 3), '999,990.000') et_secs_per_exec
   , TO_CHAR(ROUND(h.cpu_time_total / h.executions_total / 1e6, 3), '999,990.000') cpu_secs_per_exec
   , TO_CHAR(ROUND(h.iowait_total / h.executions_total / 1e6, 3), '999,990.000') io_secs_per_exec
   , TO_CHAR(ROUND(h.clwait_total / h.executions_total / 1e6, 3), '999,990.000') cl_secs_per_exec
   , TO_CHAR(ROUND(h.apwait_total / h.executions_total / 1e6, 3), '999,990.000') ap_secs_per_exec
   , TO_CHAR(ROUND(h.ccwait_total / h.executions_total / 1e6, 3), '999,990.000') cc_secs_per_exec
   , TO_CHAR(ROUND(h.plsexec_time_total / h.executions_total / 1e6, 3), '999,990.000') pl_secs_per_exec
   , TO_CHAR(ROUND(h.javexec_time_total / h.executions_total / 1e6, 3), '999,990.000') ja_secs_per_exec
FROM dba_hist_sqlstat h, dba_hist_snapshot s
WHERE h.sql_id = '${SQL_ID}'
AND h.executions_total > 0
AND s.snap_id = h.snap_id
AND s.dbid = h.dbid
AND s.instance_number = h.instance_number
ORDER BY h.sql_id, h.instance_number, s.end_interval_time, h.plan_hash_value;
quit;
EOF
}
#
#########################################################################################################
# WHICH SEG. HAVE TOP LOGICAL I/O - PHYSICAL I/O
#########################################################################################################
#
# NON PDB
function Func_DB_079()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|'
prompt ##############################################################
prompt # WHICH SEG. HAVE TOP LOGICAL I/O - PHYSICAL I/O
prompt ##############################################################
col owner for a30
col OBJECT_NAME for a40
select ROWNUM AS Rank
  , Seg_Lio.*
FROM (select St.Owner
  , St.Obj#
  , St.Object_Type
  , St.Object_Name
  , to_char(St.VALUE) as VALUE
  , 'LIO' AS Unit
FROM V\$segment_Statistics St
WHERE St.Statistic_Name = 'logical reads'
ORDER BY St.VALUE DESC) Seg_Lio WHERE ROWNUM <= 15
UNION ALL
select ROWNUM AS Rank
  , Seq_Pio_r.*
FROM (select St.Owner
  , St.Obj#
  , St.Object_Type
  , St.Object_Name
  , to_char(St.VALUE) as VALUE
  , 'PIO Reads' AS Unit
FROM V\$segment_Statistics St
WHERE St.Statistic_Name = 'physical reads'
ORDER BY St.VALUE DESC) Seq_Pio_r
WHERE ROWNUM <= 15
UNION ALL
select ROWNUM AS Rank
  , Seq_Pio_w.*
FROM (select St.Owner
  , St.Obj#
  , St.Object_Type
  , St.Object_Name
  , to_char(St.VALUE) as VALUE
  , 'PIO Writes' AS Unit
FROM V\$segment_Statistics St
WHERE St.Statistic_Name = 'physical writes'
ORDER BY St.VALUE DESC) Seq_Pio_w
WHERE ROWNUM <= 15;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DBLINKS & FOLDERS INFO
#########################################################################################################
#
# NON PDB
function Func_DB_080()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 500 lines 500 timing on colsep '|'
prompt ##############################################################
prompt # DATABASE LINKS                                             #
prompt ##############################################################
SET long 1000
SET serveroutput on
SET verify off lines 132
DECLARE
   v_output CLOB := NULL;
BEGIN
   DBMS_OUTPUT.put_line ('DDL For Database Links');
   FOR tt IN (select owner, db_link FROM dba_db_links)
   LOOP
      select DBMS_METADATA.get_ddl ('DB_LINK', tt.db_link, tt.owner) INTO v_output FROM DUAL;
      DBMS_OUTPUT.put_line (v_output);
   END LOOP;
END;
/
prompt
prompt ##############################################################
prompt # Verify Wich DB LINK are Opened                             #
prompt ##############################################################
COL DB_LINK FORMAT A25 
COL OWNER_ID FORMAT 99999 HEADING "OWNID" 
COL LOGGED_ON FORMAT A5 HEADING "LOGON" 
COL HETEROGENEOUS FORMAT A5 HEADING "HETER" 
COL PROTOCOL FORMAT A8 
COL OPEN_CURSORS FORMAT 999 HEADING "OPN_CUR" 
COL IN_TRANSACTION FORMAT A3 HEADING "TXN" 
COL UPDATE_SENT FORMAT A6 HEADING "UPDATE" 
COL COMMIT_POINT_STRENGTH FORMAT 99999 HEADING "C_P_S" 
select * FROM V\$DBLINK;
prompt
prompt ##############################################################
prompt # FOLDERS                                                    #
prompt ##############################################################
col folders for a200
select 'create or replace directory ' || directory_name || ' as ' || '''' || directory_path || ''';' as folders from all_directories;
quit;
EOF
}
#
#########################################################################################################
# IDENTIFYING WHEN A PASSWORD WAS LAST CHANGED
#########################################################################################################
#
function Func_DB_081()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_081
else
  Func_DB_NON_PDB_081
fi
}
# PDB
function Func_DB_PDB_081()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set nls_date_format='dd/mm/yyyy';
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
prompt
prompt ##############################################################
prompt # IDENTIFYING WHEN A PASSWORD WAS LAST CHANGED
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
col name form a30
col "Created" for a20
col "Last_Changed" for a20
select name
  , ctime as "Created"
  , ptime as "Last_Changed"
  , case when ptime = ctime then 'Never Changed' when ptime < sysdate - 30 and ctime < sysdate - 30 then 'Change Recomended' else 'Recently Changed' end as "Result"
FROM sys.user\$ a, dba_users b
where a.name = b.username
order by 1;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_081()
{
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # IDENTIFYING WHEN A PASSWORD WAS LAST CHANGED
prompt ##############################################################
col name form a30
col "Created" for a20
col "Last_Changed" for a20
select name
  , ctime as "Created"
  , ptime as "Last_Changed"
  , case when ptime = ctime then 'Never Changed' when ptime < sysdate - 30 and ctime < sysdate - 30 then 'Change Recomended' else 'Recently Changed' end as "Result"
FROM sys.user\$ a, dba_users b
where a.name = b.username
order by 1;
quit;
EOF
}
#
#########################################################################################################
# VERIFY UNDO SEGMENTS
#########################################################################################################
#
# NON PDB
function Func_DB_082()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY UNDO SEGMENTS
prompt ##############################################################
select to_char(begin_time, 'DD/MM/YYYY HH24:MI') begin_time
  , to_char(end_time, 'DD/MM/YYYY HH24:MI') end_time
  , tuned_undoretention
from v\$undostat
order by end_time;
prompt
prompt ##############################################################
prompt # VERIFY UNDO SEGMENTS - DETAILS
prompt ##############################################################
select TO_CHAR(BEGIN_TIME, 'DD/MM/YYYY HH24:MI') BEGIN_TIME
  , TO_CHAR(END_TIME, 'DD/MM/YYYY HH24:MI') END_TIME
  , UNDOTSN
  , UNDOBLKS
  , TXNCOUNT
  , MAXCONCURRENCY AS "MAXCON"
FROM v\$UNDOSTAT
WHERE rownum <= 144;
prompt
prompt ##############################################################
prompt # VERIFY UNDO SEGMENTS - STATUS
prompt ##############################################################
select segment_name
  , status
FROM dba_rollback_segs;
prompt
prompt ##############################################################
prompt # VERIFY UNDO SEGMENTS - ROLLBACK
prompt ##############################################################
select rn.Name "Rollback Segment"
  , rs.RSSize/1024 "Size (KB)"
  , rs.Gets "Gets"
  , rs.waits "Waits"
  , (rs.Waits/rs.Gets)*100 "% Waits"
  , rs.Shrinks "# Shrinks"
  , rs.Extends "# Extends"
FROM sys.v_\$rollName rn, sys.v_\$rollStat rs
WHERE rn.usn = rs.usn
order by "Size (KB)", "Waits", "% Waits";
quit;
EOF
}
#
#########################################################################################################
# VERIFY ALL SQL STATEMENTS
#########################################################################################################
#
function Func_DB_083()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_083
else
  Func_DB_NON_PDB_083
fi
}
# PDB
function Func_DB_PDB_083()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 5000 timing on head off verify off feedback on echo off colsep '|'
prompt
prompt ##############################################################
prompt # VERIFY ALL SQL STATEMENTS
prompt ##############################################################
select /*+ CHOOSE*/
'Session Id...........................: ' || s.sid,
'Serial Num...........................: ' || s.serial#,
'User Name............................: ' || s.username,
'SQL ID...............................: ' || s.sql_id,
'Session Status.......................: ' || s.status,
'Client Process Id on Client Machine..: ' || '*' || s.process || '*' Client,
'Server Process ID....................: ' || p.spid Server,
'Sql_Address..........................: ' || s.sql_address,
'Sql_hash_value.......................: ' || s.sql_hash_value,
'Schema Name..........................: ' || s.SCHEMANAME,
'Program..............................: ' || s.program,
'Module...............................: ' || s.module,
'Action...............................: ' || s.action,
'Terminal.............................: ' || s.terminal,
'Client Machine.......................: ' || s.machine,
'LAST_CALL_ET.........................: ' || s.last_call_et,
'S.LAST_CALL_ET/3600..................: ' || s.last_call_et/3600
from v\$session s, v\$process p
where p.addr = s.paddr;
-- and s.sid = nvl('${ORACLE_SID}', s.sid);
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_083()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 5000 timing on head off verify off feedback on echo off colsep '|'
prompt ##############################################################
prompt # VERIFY ALL SQL STATEMENTS
prompt ##############################################################
select /*+ CHOOSE*/
'Session Id...........................: ' || s.sid,
'Serial Num...........................: ' || s.serial#,
'User Name............................: ' || s.username,
'SQL ID...............................: ' || s.sql_id,
'Session Status.......................: ' || s.status,
'Client Process Id on Client Machine..: ' || '*' || s.process || '*' Client,
'Server Process ID....................: ' || p.spid Server,
'Sql_Address..........................: ' || s.sql_address,
'Sql_hash_value.......................: ' || s.sql_hash_value,
'Schema Name..........................: ' || s.SCHEMANAME,
'Program..............................: ' || s.program,
'Module...............................: ' || s.module,
'Action...............................: ' || s.action,
'Terminal.............................: ' || s.terminal,
'Client Machine.......................: ' || s.machine,
'LAST_CALL_ET.........................: ' || s.last_call_et,
'S.LAST_CALL_ET/3600..................: ' || s.last_call_et/3600
from v\$session s, v\$process p
where p.addr = s.paddr;
-- and s.sid = nvl('${ORACLE_SID}', s.sid);
quit;
EOF
}
#
#########################################################################################################
# CLONE USER COMMANDS [ @ ]
#########################################################################################################
#
function Func_DB_083()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_083
else
  Func_DB_NON_PDB_083
fi
}
# PDB
function Func_DB_PDB_084()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # CLONE USER COMMANDS [ @ ]
prompt ##############################################################
col username for a30
col profile for a20
select username
  , account_status
  , default_tablespace
  , temporary_tablespace
  , profile
from dba_users
where username not in ('SYS','SYSTEM','XDB','XS$NULL','ANONYMOUS')
order by 1,2;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_083()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # CLONE USER COMMANDS [ @ ]
prompt ##############################################################
col username for a30
col profile for a20
select username
  , account_status
  , default_tablespace
  , temporary_tablespace
  , profile
from dba_users
where username not in ('SYS','SYSTEM','XDB','XS$NULL','ANONYMOUS')
order by 1,2;
quit;
EOF
}
#
#########################################################################################################
# VERIFY ALL INFOS ABOUT SYSAUX
#########################################################################################################
#
# NON PDB
function Func_DB_085()
{
sqlplus -S  '/ as sysdba' <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on colsep '|' trim on trims on numformat 999999999999999 heading on feedback on
prompt ##############################################################
prompt # AWR Retention Time                                         #
prompt ##############################################################
select a.dbid
  , c.name
  , b.instance_name
  , a.retention
from DBA_HIST_WR_CONTROL a, v\$instance b, v\$database c
where a.dbid = c.dbid (+);
prompt
prompt ##############################################################
prompt # Statistics Retention History                               #
prompt ##############################################################
select dbms_stats.get_stats_history_retention from dual;
prompt
prompt ##############################################################
prompt # Statistics Availability History                            #
prompt ##############################################################
select dbms_stats.get_stats_history_availability from dual;
prompt
prompt ##############################################################
prompt # Duration Time of SnapShots                                 #
prompt ##############################################################
col "Start Time" for a25
col "End Time" for a25
select min(snap_id) as "First Snap ID"
  , max(snap_id) as "Last Snap ID"
  , min(to_char(begin_interval_time,'DD/MM/YYYY HH24:MI:SS')) as "Start Time"
  , max(to_char(end_interval_time,'DD/MM/YYYY HH24:MI:SS')) as "End Time"
from dba_hist_snapshot;
prompt
prompt ##############################################################
prompt # Infos About SYSAUX TBS                                     #
prompt ##############################################################
COLUMN "Item" FORMAT A25
COLUMN "Space Used (GB)" FORMAT 999.999
COLUMN "Schema" FORMAT A25
COLUMN "Move Procedure" FORMAT A50
select occupant_name "Item"
  , space_usage_kbytes/1048576 "Space Used (GB)"
  , schema_name "Schema"
  , move_procedure "Move Procedure"
FROM gv_\$sysaux_occupants
ORDER BY 1;
prompt
prompt ##############################################################
prompt # Controlling the Size and Age of the OS Audit Trail         #
prompt ##############################################################
COLUMN parameter_name FORMAT A30
COLUMN parameter_value FORMAT A20
COLUMN audit_trail FORMAT A20
select * FROM dba_audit_mgmt_config_params
WHERE parameter_name LIKE 'AUDIT FILE MAX%';
quit;
EOF
}
#
#########################################################################################################
# VERIFY ALL INFOS ABOUT I/O + LATENCY
#########################################################################################################
#
# NON PDB
function Func_DB_086()
{
sqlplus -S  '/ as sysdba' <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on numwidth 20 colsep '|' trim on trims on numformat 999999999999999 heading on feedback on
prompt ##############################################################
prompt # VERIFY ALL INFOS ABOUT I/O & LATENCY
prompt ##############################################################
col name for a70
select to_char(sn.END_INTERVAL_TIME,'dd/mm/YYYY HH24:MI:SS') "End snapshot time"
  , sum(after.PHYRDS+after.PHYWRTS-before.PHYWRTS-before.PHYRDS) "number of IOs"
  , trunc(10*sum(after.READTIM+after.WRITETIM-before.WRITETIM-before.READTIM)/sum(1+after.PHYRDS+after.PHYWRTS-before.PHYWRTS-before.PHYRDS)) "ave IO time (ms)"
  , trunc((select value from v\$parameter where name='db_block_size')*sum(after.PHYBLKRD+after.PHYBLKWRT-before.PHYBLKRD-before.PHYBLKWRT)/sum(1+after.PHYRDS+after.PHYWRTS-before.PHYWRTS-before.PHYRDS)) "ave IO size (bytes)"
from DBA_HIST_FILESTATXS before
  , DBA_HIST_FILESTATXS after
  , DBA_HIST_SNAPSHOT sn
where after.file# = before.file#
and after.snap_id = before.snap_id+1
and before.instance_number = after.instance_number
and after.snap_id = sn.snap_id
and after.instance_number = sn.instance_number
group by to_char(sn.END_INTERVAL_TIME,'dd/mm/YYYY HH24:MI:SS')
order by to_char(sn.END_INTERVAL_TIME,'dd/mm/YYYY HH24:MI:SS');
prompt
prompt ##############################################################
prompt # Physical Reads and Writes                                  #
prompt ##############################################################
col name for a100
select NAME
  , PHYRDS "Physical Reads"
  , round((PHYRDS / PD.PHYS_READS)*100,2) "Read %"
  , PHYWRTS "Physical Writes"
  , round(PHYWRTS * 100 / PD.PHYS_WRTS,2) "Write %"
  , fs.PHYBLKRD+FS.PHYBLKWRT "Total Block I/O's"
from (select sum(PHYRDS) PHYS_READS, sum(PHYWRTS) PHYS_WRTS from v\$filestat) pd
  , v\$datafile df
  , v\$datafile df
  , v\$filestat fs
where df.FILE# = fs.FILE#
order by fs.PHYBLKRD+fs.PHYBLKWRT desc;
prompt
prompt ##############################################################
prompt # ??? #
prompt ##############################################################
col event for a70
col total_waits for a15
col total_timeouts for a15
col time_waited for a15
select EVENT
  , to_char(TOTAL_WAITS) as TOTAL_WAITS
  , to_char(TOTAL_TIMEOUTS) as TOTAL_TIMEOUTS
  , to_char(TIME_WAITED) as TIME_WAITED
  , round(AVERAGE_WAIT,2) "Average Wait"
from v\$system_event
order by event, to_char(TOTAL_WAITS);
prompt
prompt ##############################################################
prompt # Datafiles Sync Status                                      #
prompt ##############################################################
col name format a100
select distinct name
  , asynch_io
from v\$datafile d
inner join v\$iostat_file f on d.file# = f.file_no;
prompt
-- SET SERVEROUTPUT ON
-- DECLARE
  -- lat  INTEGER;
  -- iops INTEGER;
  -- mbps INTEGER;
-- BEGIN
  -- DBMS_RESOURCE_MANAGER.CALIBRATE_IO(
    -- 1    /* # of disks */
    -- , 10   /* maximum tolerable latency in milliseconds */
    -- , iops /* I/O rate per second */
    -- , mbps /* throughput, MB per second */
    -- , lat  /* actual latency in milliseconds */
   -- );
  -- DBMS_OUTPUT.PUT_LINE('max_iops = ' || iops);
  -- DBMS_OUTPUT.PUT_LINE('latency  = ' || lat);
  -- DBMS_OUTPUT.PUT_LINE('max_mbps = ' || mbps);
-- END;
-- /
prompt ##############################################################
prompt # Datafiles Size Reads                                       #
prompt ##############################################################
col name for a100
select d.name
  , f.file_no
  , f.small_read_megabytes
  , f.small_read_reqs
  , f.large_read_megabytes
--  , f.large_read_reqs
from v\$iostat_file f
inner join v\$datafile d on f.file_no = d.file#;
quit;
EOF
}
#
#########################################################################################################
# VERIFY MAIN TOP WAIT EVENTS PER WEEK
#########################################################################################################
#
# NON PDB
function Func_DB_087()
{
sqlplus -S  '/ as sysdba' <<EOF
-- Auslesen Event Historie (cursor: mutex S) - je Report
set pages 700 lines 700 timing on numwidth 20 colsep '|' trim on trims on numformat 999999999999999 heading on feedback on
prompt ##############################################################
prompt # VERIFY MAIN TOP WAIT EVENTS PER WEEK
prompt ##############################################################
col begin_interval_time format a20
col end_interval_time format a20
col AVG_WAIT_TIME_MSEC for a30
col EVENT_NAME for a40
col total_waits for a15
col total_waited_sec for a15
col KW for a5
col AVG_WAIT_TIME_MSEC for 999999999,99
select dhs.snap_id
  , to_char(dhs.begin_interval_time,'iw') kw
  , to_char(dhs.begin_interval_time,'dd/mm/yyyy hh24:mi:ss') begin_interval_time
  , to_char(dhs.end_interval_time,'dd/mm/yyyy hh24:mi:ss') end_interval_time
  , to_char(event_name) event_name
  , to_char(total_waits) total_waits
  , to_char(round(total_waited_micro/1000000)) as total_waited_sec
  , decode(total_waits,0,0,round(total_waited_micro/total_waits/1000,2)) avg_wait_time_msec
FROM (select snap_id
        , event_name
        , total_waits - lag( total_waits) OVER(ORDER BY snap_id) AS total_waits
        , time_waited_micro - lag (time_waited_micro) over (ORDER BY snap_id) as total_waited_micro
      FROM dba_hist_system_event
      WHERE event_name in ('db file sequential read','direct path read','direct path read temp','direct path sync','direct path write','direct path write temp','log file sync','db file scattered read','cursor: mutex S')
      ORDER BY snap_id) details,
dba_hist_snapshot dhs
WHERE dhs.snap_id = details.snap_id
and total_waits > 0
-- and begin_interval_time > sysdate - 12/24
ORDER BY dhs.snap_id;
quit;
EOF
}
#
#########################################################################################################
# VERIFY OBJECTS SIZE
#########################################################################################################
#
function Func_DB_088()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_088
else
  Func_DB_NON_PDB_088
fi
}
# PDB
function Func_DB_PDB_088()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
prompt
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # SIZE BY OWNER                                              #
prompt ##############################################################
col size_mb for a20
col size_gb for a20
col size_tb for a20
col owner for a30
select owner
  , to_char(sum(bytes)/1024/1024,'999G999G999D999') as SIZE_MB
  , to_char(sum(bytes)/1024/1024/1024,'999G999G999D999') as SIZE_GB
  , to_char(sum(bytes)/1024/1024/1024/1024,'999G999G999D999') as SIZE_TB
From dba_segments
group by owner
order by owner;
prompt
prompt ##############################################################
prompt # VERIFY LARGESTS OBJECTS
prompt ##############################################################
col owner format a30
col segment_name format a50
col segment_type format a20
col tablespace_name format a20
col mb format 999,999,999,999
col gb format 999,999,999,999
col tb format 999,999,999,999
select owner
  , segment_name
  , segment_type
  , tablespace_name
  , mb
  , gb
  , tb
from (select owner
        , segment_name
        , segment_type
        , tablespace_name
        , bytes/1024/1024 "MB"
        , bytes/1024/1024/1024 "GB"
        , bytes/1024/1024/1024/1024 "TB"
      from dba_segments
      order by bytes desc)
where rownum < 26;
quit;
EOF
}
# NON PDB
function Func_DB_NON_PDB_088()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # SIZE BY OWNER                                              #
prompt ##############################################################
col size_mb for a20
col size_gb for a20
col size_tb for a20
col owner for a30
select owner
  , to_char(sum(bytes)/1024/1024,'999G999G999D999') as SIZE_MB
  , to_char(sum(bytes)/1024/1024/1024,'999G999G999D999') as SIZE_GB
  , to_char(sum(bytes)/1024/1024/1024/1024,'999G999G999D999') as SIZE_TB
From dba_segments
group by owner
order by owner;
prompt
prompt ##############################################################
prompt # VERIFY LARGESTS OBJECTS
prompt ##############################################################
col owner format a30
col segment_name format a50
col segment_type format a20
col tablespace_name format a20
col mb format 999,999,999,999
col gb format 999,999,999,999
col tb format 999,999,999,999
select owner
  , segment_name
  , segment_type
  , tablespace_name
  , mb
  , gb
  , tb
from (select owner
        , segment_name
        , segment_type
        , tablespace_name
        , bytes/1024/1024 "MB"
        , bytes/1024/1024/1024 "GB"
        , bytes/1024/1024/1024/1024 "TB"
      from dba_segments
      order by bytes desc)
where rownum < 26;
quit;
EOF
}
#
#########################################################################################################
# GENERAL DATABASE OVERVIEW
#########################################################################################################
#
# NON PDB
function Func_DB_089()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 1000 linesize 5000 head off feedback off echo off timing off TRIMSPOOL ON NEWPAGE NONE
prompt ##############################################################
prompt # GENERAL DATABASE OVERVIEW
prompt ##############################################################
col PROPERTY_NAME for a25
col PROPERTY_VALUE for a15
col DESCRIPTION for a35
col DIRECTORY_PATH for a70
col directory_name for a25
col OWNER for a10
col DB_LINK for a40
col HOST for a20
col "User_Concurrent_Queue_Name" format a50 heading 'Manager'
col "Running_Processes" for 9999 heading 'Running'
break on utl_file_dir
select '------------------------ Getting Database Information ------------------------' from dual;
select 'Database Name.....................: ' || name from v\$database;
select 'Database Status...................: ' || open_mode from v\$database;
select 'Archiving Status..................: ' || log_mode from v\$database;
select 'Global Name.......................: ' || global_name from global_name;
select 'Service Name......................: ' || value from v\$parameter where name = 'service names';
select 'Creation Date.....................: ' || to_char(created,'DD/MM/YYYY HH24:MI:SS') from v\$database;
select 'Checking For Missing File.........: ' || count(*) from v\$recover_file;
select 'Checking Missing File Name .......: ' || count(*) from v\$datafile where name like '%MISS%';
select 'Total SGA MB......................: ' || round(sum(value)/(1024*1024)) || ' MB' from v\$sga ;
select 'Total SGA GB......................: ' || round(sum(value)/(1024*1024*1024)) || ' GB' from v\$sga ;
select 'Total SGA TB......................: ' || round(sum(value)/(1024*1024*1024*1024)) || ' TB' from v\$sga ;
select 'Database Version..................: ' || version from v\$instance;
select 'Database Size MB..................: ' || trim(to_char(sum(bytes)/1024/1024,'9G999G999D99')) || ' MB' from (select sum(bytes) bytes from dba_data_files
union all
select sum(bytes) bytes from dba_temp_files
union all
select sum(bytes * members) from v\$log
union all
select sum(block_size * file_size_blks) from v\$controlfile);
select 'Database Size GB..................: ' || trim(to_char(sum(bytes)/1024/1024/1024,'9G999G999D99')) || ' GB' from (select sum(bytes) bytes from dba_data_files
union all
select sum(bytes) bytes from dba_temp_files
union all
select sum(bytes * members) from v\$log
union all
select sum(block_size * file_size_blks) from v\$controlfile);
select 'Database Size TB..................: ' || trim(to_char(sum(bytes)/1024/1024/1024/1024,'9G999G999D99')) || ' TB' from (select sum(bytes) bytes from dba_data_files
union all
select sum(bytes) bytes from dba_temp_files
union all
select sum(bytes * members) from v\$log
union all
select sum(block_size * file_size_blks) from v\$controlfile);
select 'Temporary Tablespace..............: ' || property_value from database_properties where property_name like 'default_temp_tablespace';
select 'Apps Temp Tablespace..............: ' || temporary_tablespace from dba_users where username like '%APPS%';
select 'Temp Tablespace Size..............: ' || sum(maxbytes/1024/1024/1024) || ' GB' from dba_temp_files group by tablespace_name;
select 'No of Invalid Object .............: ' || count(*) from dba_objects where status = 'INVALID' ;
select 'plsql Code Type...................: ' || value from v\$parameter2 where name = 'plsql_code_type';
select 'plsql Subdir Count................: ' || value from v\$parameter2 where name = 'plsql_native_library_subdir_count';
select 'plsql Native Library Dir..........: ' || value from v\$parameter2 where name = 'plsql_native_library_dir';
select 'Shared Pool Size.........,........: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'shared_pool_size';
select 'Log Buffer........................: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'log_buffer';
select 'Buffer Cache MB...................: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'db_cache_size';
select 'Buffer Cache GB...................: ' || (value/1024/1024/1024) || ' GB' from v\$parameter where name = 'db_cache_size';
select 'Buffer Cache TB...................: ' || (value/1024/1024/1024/1024) || ' TB' from v\$parameter where name = 'db_cache_size';
select 'Large Pool Size MB................: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'large_pool_size';
select 'Large Pool Size GB................: ' || (value/1024/1024/1024) || ' GB' from v\$parameter where name = 'large_pool_size';
select 'Java Pool Size MB.................: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'java_pool_size';
select 'Java Pool Size GB.................: ' || (value/1024/1024/1024) || ' GB' from v\$parameter where name = 'java_pool_size';
select 'utl_file_dir......................: ' || value from v\$parameter2 where name = 'utl_file_dir';
select directory_name || '................: ' || directory_path from all_directories where rownum < 15;
quit;
EOF
}
#
#
#########################################################################################################
# DATABASE DASHBOARD
#########################################################################################################
#
# NON PDB
function Func_DB_090()
{
varDB_JSS=$(sqlplus -S  '/ as sysdba' <<EOF
set define off trims on newp none heads off echo off feed off pagesize 0 null null verify off wrap off timing off serveroutput off termout off heading off
alter session set current_schema = system;
var varDB_JSS varchar2(50);
begin
  select count(*) into :varDB_JSS from all_objects where owner = 'SYSTEM' and object_name like 'JSS%';
end;
/
print varDB_JSS
quit;
EOF
)
#
if [[ ${varDB_JSS} = 0 ]]; then
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on colsep '|' numwidth 20 feedback on
prompt ##############################################################
prompt # INSTALLING THE DATABASE DASHBOARD
prompt ##############################################################
grant create type to system;
grant create procedure to system;
grant execute on dbms_lock to system;
grant select on gv_\$sql to system;
grant select on gv_\$sql_monitor to system;
grant select on gv_\$active_session_history to system;
grant select on gv_\$osstat to system;
grant select on gv_\$instance to system;
grant select on gv_\$statname to system;
grant select on gv_\$sysstat to system;
grant select on gv_\$segment_statistics to system;
grant select on gv_\$dlm_misc to system;
grant select on gv_\$sysmetric to system;
grant select on v_\$parameter to system;
alter session set current_schema=system;
drop type ta_obj;
drop type ta_ginst;
drop type ta_gash;
drop type ta_gc;
drop type ta_gsqlm;
drop type ty_obj;
drop type ty_ginst;
drop type ty_gash;
drop type ty_gsqlm;
drop type ty_gc;
drop package body JSS;
drop package jss;
create or replace type ty_obj as object (output varchar2(2500));
/
create or replace type ty_ginst as object
  (
    inst_id       number(2),
    inst_name     varchar2(16),
    statname      varchar2(64),
    value         number,
    Times         date
   );
/
create or replace type ty_gash as object
  (
    inst_id       number,
    sid           number,
    sql_id        varchar2(13),
    sql_child     number,
    sql_text      varchar2(100),
    planhash      varchar2(64),
    offloadpct    number,
    plancntrl     varchar2(10),
    pgamb         number,
    tmpmb         number,
    event         varchar2(64),
    wait_class    varchar2(64),
    time_Waited   number,
    obj#          number
   );
/
create or replace type ty_gsqlm as object
  (
    inst_id                    number,
    sql_id                     varchar2(13),
    sql_text                   varchar2(100),
    elapsed_time               number,
    cpu_time                   number,
    concurrency_Wait_time      number,
    cluster_Wait_time          number,
    user_io_wait_time          number,
    physical_read_bytes        number,
    px_server#                 number
  );
 /
create or replace type ty_gc as object
 (
   inst_id    number(2),
   GCBCS      number,
   GCBRS      number,
   GMSR       number
  );
/
create or replace type ta_gc as table of ty_gc;
/
create or replace type ta_gsqlm is table of ty_gsqlm;
/
create or replace type ta_obj as table of ty_obj;
/
create or replace type ta_ginst as table of ty_ginst;
/
create or replace type ta_gash as table of ty_gash;
/
CREATE OR REPLACE PACKAGE JSS
AS
FUNCTION GTOP
  (
     PV_ARR_SIZE     INT DEFAULT 50,
     PV_SAMPLE       INT DEFAULT 6,
     PV_COLORS       INT DEFAULT 1,
     PV_SYSMETRC_ID1 INT DEFAULT NULL,
     PV_SYSMETRC_ID2 INT DEFAULT NULL,
     PV_SYSMETRC_ID3 INT DEFAULT NULL
  )
RETURN ta_obj pipelined;
FUNCTION GTOPHELP
RETURN TA_OBJ PIPELINED;
end;
/
CREATE OR REPLACE PACKAGE body jss
AS
---##############
-- Global Variables
---##############
pv_first_ginst        ta_ginst := ta_ginst();   -- variables to store global instance info by using gv\$sysstat, first sample
pv_last_ginst         ta_ginst := ta_ginst();   -- second sample, In order to get delta data
pv_only_gash          ta_gash  := ta_gash();    -- to store gv\$active_session_history data for given sample
pv_version            number;
pv_tmp_obj            ta_obj   := ta_obj() ;    -- temporary variable
pv_only_gsqlm         ta_gsqlm := ta_gsqlm();   -- to store gv\$sql_monitor info, no delta
pv_num_cpus           int;                      -- no. of cores from gv\$iostat
pv_maxcpuprint        varchar2(100);            -- array no. to get maxcpu print in active session graph
p_sample              int;                      -- Input parameter for delay in sample\/sleep time
pv_st_sample          date;                     -- sample start time from sysdate
pv_et_sample          date;                     -- sample end time from sysdate
pv_top_sql            ta_obj := ta_obj();       -- to store top sqls from pv_only_gash collection
pv_only_gc            ta_gc  :=  ta_gc();       -- Global Cache info from gv\$sysstat
pv_block_size         number;                   -- Block size from v\$parameter to calculate interconnect traffic
pv_tmp_gcinfo         ta_obj := ta_obj();       -- temporary global variable
PV_SYSMETRIC_STRING1  VARCHAR2(200);
PV_SYSMETRIC_STRING2  VARCHAR2(200);
pv_sysmetric_string3  varchar2(200);
V_PGAMB               VARCHAR2(20);
v_tmpmb               varchar2(20);
pv_maxcpu_string      varchar2(50);
----##################################################
-- Variables to draw active sessions Graph, 80 samples are shown in graph.
-- 4 arrays are used to show session range.
----##################################################
pa_stet  ta_obj := ta_obj();  pa1       ta_obj := ta_obj(); pa2       ta_obj := ta_obj();
pa3      ta_obj := ta_obj();  pa4       ta_obj := ta_obj(); pa5       ta_obj := ta_obj();
pa6      ta_obj := ta_obj();  pa7       ta_obj := ta_obj(); pa8       ta_obj := ta_obj();
pa9      ta_obj := ta_obj();  pa10      ta_obj := ta_obj(); pa11      ta_obj := ta_obj();
pa12     ta_obj := ta_obj();  pa13      ta_obj := ta_obj(); pa14      ta_obj := ta_obj();
pa15      ta_obj := ta_obj(); pa16      ta_obj := ta_obj(); pa17      ta_obj := ta_obj();
pa18      ta_obj := ta_obj(); pa19      ta_obj := ta_obj(); pa20      ta_obj := ta_obj();
pa21      ta_obj := ta_obj(); pa22      ta_obj := ta_obj(); pa23      ta_obj := ta_obj();
pa24      ta_obj := ta_obj(); pa25      ta_obj := ta_obj(); pa26      ta_obj := ta_obj();
pa27      ta_obj := ta_obj(); pa28      ta_obj := ta_obj(); pa29      ta_obj := ta_obj();
pa30      ta_obj := ta_obj(); pa31      ta_obj := ta_obj(); pa32      ta_obj := ta_obj();
pa33      ta_obj := ta_obj(); pa34      ta_obj := ta_obj(); pa35      ta_obj := ta_obj();
pa36      ta_obj := ta_obj(); pa37      ta_obj := ta_obj(); pa38      ta_obj := ta_obj();
pa39      ta_obj := ta_obj(); pa40      ta_obj := ta_obj(); pa41      ta_obj := ta_obj();
pa42      ta_obj := ta_obj(); pa43      ta_obj := ta_obj(); pa44      ta_obj := ta_obj();
pa45      ta_obj := ta_obj(); pa46      ta_obj := ta_obj(); pa47      ta_obj := ta_obj();
pa48      ta_obj := ta_obj(); pa49      ta_obj := ta_obj(); pa50      ta_obj := ta_obj();
pa51      ta_obj := ta_obj(); pa52      ta_obj := ta_obj(); pa53      ta_obj := ta_obj();
pa54      ta_obj := ta_obj(); pa55      ta_obj := ta_obj(); pa56      ta_obj := ta_obj();
pa57      ta_obj := ta_obj(); pa58      ta_obj := ta_obj(); pa59      ta_obj := ta_obj();
pa60      ta_obj := ta_obj(); pa61      ta_obj := ta_obj(); pa62      ta_obj := ta_obj();
pa63      ta_obj := ta_obj(); pa64      ta_obj := ta_obj(); pa65      ta_obj := ta_obj();
pa66      ta_obj := ta_obj(); pa67      ta_obj := ta_obj(); pa68      ta_obj := ta_obj();
pa69      ta_obj := ta_obj(); pa70      ta_obj := ta_obj(); pa71      ta_obj := ta_obj();
pa72      ta_obj := ta_obj(); pa73      ta_obj := ta_obj(); pa74      ta_obj := ta_obj();
pa75      ta_obj := ta_obj(); pa76      ta_obj := ta_obj(); pa77      ta_obj := ta_obj();
pa78      ta_obj := ta_obj(); pa79      ta_obj := ta_obj(); pa80      ta_obj := ta_obj();
pa81      ta_obj := ta_obj(); pa82      ta_obj := ta_obj(); pa83      ta_obj := ta_obj();
pa84      ta_obj := ta_obj();
pv_maxval    int ;    --- info regarding maxval of Active Session Graph array
pv_tmp_maxval int;    --- for reshuffling the maxval based on current active sessions
pv_maxsess   int ;    --- max sessions reached in last 80 samples
 ------------------ to store waits
pv_cpuwaitpct int;
pv_iowaitpct  int;
pv_cluwaitpct int;
pv_othwaitpct int;
PV_CPU_DIG     VARCHAR2(11) ;
PV_IO_DIG      VARCHAR2(11) ;
PV_CLU_DIG     VARCHAR2(11) ;
pv_oth_dig     varchar2(11) ;
p_localarray   int := 0;
pva int;
pvb int;
pvc int;
pvd int;
pve int;
JS_MAXSESS    INT := 0;
js_arr        int := 0 ;
pv_work_done  int := 0;
----##################################################
-- Fbyt function format bytes in K,M,G,T
----##################################################
FUNCTION fbyt(V_SIZE_K   NUMBER)
RETURN varchar2
AS
BEGIN
if v_size_k > 0  then
    IF      V_SIZE_K/1024                  <= 1023 THEN RETURN ROUND(V_SIZE_K/1024,1)||'K';
    ELSIF   V_SIZE_K/1024/1024             <= 1023 THEN RETURN ROUND(V_SIZE_K/1024/1024,1)||'M';
    ELSIF   V_SIZE_K/1024/1024/1024        <= 1023 THEN RETURN ROUND(V_SIZE_K/1024/1024/1024,1)||'G';
    ELSIF   V_SIZE_K/1024/1024/1024/1024   <= 1023 THEN RETURN ROUND(V_SIZE_K/1024/1024/1024/1024,1)||'T';
    END IF;
ELSE   RETURN ' '; -- instead of null so that lpad function should work
end if;
end;
------##################
--Initial Procedure to extend all the arrays to ASG [Active Sessions Graph]
------##################
procedure initactarr
as
begin
 ---extending arrays
    pa1.extend(21);   pa2.extend(21); pa3.extend(21);  pa4.extend(21);   pa5.extend(21);
    pa6.extend(21);   pa7.extend(21); pa8.extend(21);  pa9.extend(21);  pa10.extend(21);
    pa11.extend(21); pa12.extend(21); pa13.extend(21); pa14.extend(21); pa15.extend(21);
    pa16.extend(21); pa17.extend(21); pa18.extend(21); pa19.extend(21); pa20.extend(21);
    pa21.extend(21); pa22.extend(21); pa23.extend(21); pa24.extend(21); pa25.extend(21);
    pa26.extend(21); pa27.extend(21); pa28.extend(21); pa29.extend(21); pa30.extend(21);
    pa31.extend(21); pa32.extend(21); pa33.extend(21); pa34.extend(21); pa35.extend(21);
    pa36.extend(21); pa37.extend(21); pa38.extend(21); pa39.extend(21); pa40.extend(21);
    pa41.extend(21); pa42.extend(21); pa43.extend(21); pa44.extend(21); pa45.extend(21);
    pa46.extend(21); pa47.extend(21); pa48.extend(21); pa49.extend(21); pa50.extend(21);
    pa51.extend(21); pa52.extend(21); pa53.extend(21); pa54.extend(21); pa55.extend(21);
    pa56.extend(21); pa57.extend(21); pa58.extend(21); pa59.extend(21); pa60.extend(21);
    pa61.extend(21); pa62.extend(21); pa63.extend(21); pa64.extend(21); pa65.extend(21);
    pa66.extend(21); pa67.extend(21); pa68.extend(21); pa69.extend(21); pa70.extend(21);
    pa71.extend(21); pa72.extend(21); pa73.extend(21); pa74.extend(21); pa75.extend(21);
    pa76.extend(21); pa77.extend(21); pa78.extend(21); pa79.extend(21); pa80.extend(21);
exception
when others then
raise_application_Error(-20001,'INITACTARR : '||sqlerrm );
end;
-------------------
------##################
-- ginsteff build data set from gv\$sysstat, gv\$osstat, gv\$dlm_misc
-- and load data collection name pv_last_ginst
-- only every loop, pv_last_ginst will be assigned to pv_first_ginst to get the delta
------##################
function ginsteff return ta_ginst
is
fv_ginst  ta_ginst := ta_ginst();
fv_sql    varchar2(3000) := q'[select ty_ginst(a.instance_number, a.instance_name, b.name, c.value, sysdate) from gv\$instance a, gv\$statname b, gv\$sysstat c where a.inst_id = b.inst_id and b.inst_id = c.inst_id and b.statistic# = c.statistic# and b.name in ('execute count','parse count (hard)','parse count (total)','physical read total IO requests','physical read total bytes','physical write total IO requests','physical write total bytes','redo size','session logical reads','user commits','cell physical IO interconnect bytes returned by smart scan','cell physical IO bytes saved by storage index','cell flash cache read hits','gc cr blocks served','gc current blocks served','gc cr blocks received','gc current blocks received','gcs messages sent','ges messages sent')
union all
select ty_ginst(d.inst_id, e.instance_name, d.stat_name, d.value, sysdate) from gv\$osstat d, gv\$instance e where d.inst_id = e.inst_id and d.stat_name in ('IDLE_TIME','USER_TIME','SYS_TIME','IOWAIT_TIME','BUSY_TIME','NICE_TIME','NUM_CPU_CORES')
union all
select ty_ginst(i.inst_id, i.instance_name, d.name, d.value, sysdate) from gv\$instance i, gv\$dlm_misc d where i.inst_id = d.inst_id and d.name in ('gcs msgs received','ges msgs received')]';
begin
  execute immediate fv_sql bulk collect into fv_ginst;
return fv_ginst;
exception
  when others then
raise_application_Error(-20001,'GINSTEFF : ' || sqlerrm);
end;
-------------------
------##################
-- ginstbuilddata - once data set is ready by calling ginsteff [ above function ], ginstbuilddata
-- format the data by query both samples [ pv_first_ginst and pv_last_ginst ]
------##################
function ginstbuilddata (fv_firstsample ta_ginst, fv_lastsample  ta_ginst) return ta_obj
is
fv_ta_obj      ta_obj := ta_obj();
v_sampl_time   int;
v_total_time   int;
-- Variables to store sum values for cluster
vt_tprse       int := 0;
vt_hprse       int := 0;
vt_phwio       int := 0;
vt_phwmb       int := 0;
vt_phrio       int := 0;
vt_phrmb       int := 0;
vt_slio        int := 0;
vt_exec        int := 0;
vt_redo        int := 0;
vt_comt        int := 0;
vt_exSS        int := 0;
vt_exSI        int := 0;
vt_exFC        int := 0;
begin
pv_only_gc.delete;
fv_ta_obj.extend;
fv_ta_obj(fv_ta_obj.count) := ty_obj( '+Inst-------+CPUIDL%--IO%-USR%--SYS%+--Tprse/s--+Hprse/s+--PhyWIO/s-+-PhyWMB/s-+--PhyRIO/s--+-PhyRMB/s-+-SessLIO/s--+---Exec/s-+RedoMB/s+Commit/s+-ExSSMB/s-+-ExSIMB/s+-ExFCRh/s+') ;
    --- updating CPU info -- updating with every sample in case new node join/leave the cluser
        select sum(first.value) into pv_num_cpus from table (fv_firstsample) first where first.statname = 'NUM_CPU_CORES';
    --- Initializing package variables with sample time for later use.
        select first.times,last.times  into pv_st_sample, pv_et_sample from table (fv_firstsample) first, table( fv_lastsample ) last where rownum = 1;
    ---# Not using pv_sample as selecting across multiple instances may take more time, so would be wise to calculate sample based on timestamps
        v_sampl_time := (pv_et_sample - pv_st_sample ) *24*60*60 ;
    -------
   for i in (select distinct inst_id from table(fv_lastsample ) order by inst_id ) loop -- processing order by inst_id. Pls. note : no restriction on no. of instances
            -------------
            for ii in (select b.inst_id,b.inst_name,
                        max(decode(b.statname,'DB time', round((b.value-a.value)/v_sampl_time)))                                                               dbtime,
                        max(decode(b.statname,'parse count (total)', round((b.value-a.value)/v_sampl_time)))                                                   Tparse,
                        max(decode(b.statname,'parse count (hard)', round((b.value-a.value)/v_sampl_time)))                                                    Hparse,
                        max(decode(b.statname,'physical write total IO requests', round((b.value-a.value)/v_sampl_time)))                                      PhyWIO,
                        max(decode(b.statname,'physical write total bytes', round(((b.value-a.value)/1048576)/v_sampl_time)))                                  PhyWMB,
                        max(decode(b.statname,'physical read total IO requests', round((b.value-a.value)/v_sampl_time)))                                       PhyRIO,
                        max(decode(b.statname,'physical read total bytes', round(((b.value-a.value)/1048576)/v_sampl_time)))                                   PhyRMB,
                        max(decode(b.statname,'session logical reads', round((b.value-a.value)/v_sampl_time)))                                                 SessLIO,
                        max(decode(b.statname,'execute count', round((b.value-a.value)/v_sampl_time)))                                                         TotExec,
                        max(decode(b.statname,'redo size', round(((b.value-a.value)/1048576)/v_sampl_time)))                                                   RedoMB,
                        max(decode(b.statname,'user commits', round((b.value-a.value)/v_sampl_time)))                                                          Ccommit,
                        sum(decode(b.statname,'IDLE_TIME', round((b.value-a.value)/v_sampl_time)))                                                             idle_time,
                        sum(decode(b.statname,'USER_TIME', round((b.value-a.value)/v_sampl_time)))                                                             user_time,
                        sum(decode(b.statname,'SYS_TIME',  round((b.value-a.value)/v_sampl_time)))                                                             sys_time,
                        sum(decode(b.statname,'IOWAIT_TIME', round((b.value-a.value)/v_sampl_time)))                                                           iowait_time,
                        sum(decode(b.statname,'BUSY_TIME', round((b.value-a.value)/v_sampl_time)))                                                             busy_time,
                        sum(decode(b.statname,'NICE_TIME', round((b.value-a.value)/v_sampl_time)))                                                             nice_time,
                        sum(decode(b.statname,'cell physical IO interconnect bytes returned by smart scan', round(((b.value-a.value)/1048576)/v_sampl_time)))  ExSSMB,
                        sum(decode(b.statname,'cell physical IO bytes saved by storage index', round(((b.value-a.value)/1048576)/v_sampl_time)))               ExSIMB,
                        sum(decode(b.statname,'cell flash cache read hits', round(((b.value-a.value))/v_sampl_time)))                                          ExFCRh,
                        sum(decode(b.statname,'gc cr blocks served', round(((b.value-a.value))/v_sampl_time)))                                                 GCCRBS,
                        sum(decode(b.statname,'gc current blocks served', round(((b.value-a.value))/v_sampl_time)))                                            GCCUBS,
                        sum(decode(b.statname,'gc cr blocks received', round(((b.value-a.value))/v_sampl_time)))                                               GCCRBR,
                        sum(decode(b.statname,'gc current blocks received', round(((b.value-a.value))/v_sampl_time)))                                          GCCUBR,
                        sum(decode(b.statname,'gcs msgs received', round(((b.value-a.value))/v_sampl_time)))                                                   GCSMR,
                        sum(decode(b.statname,'ges msgs received', round(((b.value-a.value))/v_sampl_time)))                                                   GESMR,
                        sum(decode(b.statname,'gcs messages sent', round(((b.value-a.value))/v_sampl_time)))                                                   GCSMS,
                        sum(decode(b.statname,'ges messages sent', round(((b.value-a.value))/v_sampl_time)))                                                   GESMS
                        from table(fv_lastsample) b, table(fv_firstsample) a
                        where a.inst_id = b.inst_id and a.statname = b.statname and a.inst_id = i.inst_id group by b.inst_id,b.inst_name) loop
            v_total_time :=  ii.idle_time+ii.busy_time;
            fv_ta_obj.extend;
            fv_ta_obj(fv_ta_obj.count) := ty_obj( '|' ||
              rpad(substr(ii.inst_name,1,11),11,' ') || '|' ||
              lpad(trunc(100-((ii.iowait_time+ii.user_time+ii.sys_time+ii.nice_time)/v_total_time*100),1) || ' ',6,' ') ||
              lpad(trunc(ii.iowait_time/v_total_time*100,1),5,' ') || ' ' ||
              lpad(trunc(ii.user_time/v_total_time*100,1),5,' ') || ' ' ||
              lpad(trunc(ii.sys_time/v_total_time*100,1),5,' ') || '|' ||
              lpad(ii.Tparse,11,' ') || '|' ||
              lpad(ii.Hparse,7,' ') || '|' ||
              lpad(ii.Phywio,11,' ') || '|' ||
              lpad(ii.phywmb,10,' ') || '|' ||
              lpad(ii.phyrio,12,' ') || '|' ||
              lpad(ii.phyrmb,10,' ') || '|' ||
              lpad(ii.sesslio,12,' ') || '|' ||
              lpad(ii.totexec,10,' ') || '|' ||
              lpad(ii.redomb,8,' ') || '|' ||
              lpad(ii.ccommit,8,' ') || '|' ||
              lpad(ii.ExSSMB,10,' ') || '|' ||
              lpad(ii.ExSIMB,9,' ') || '|' ||
              lpad(ii.ExFCRh,9,' ') || '|'
              ) ;
      -- Filling GC data into global array for later use., info for columns related to gc* waits
            pv_only_gc.extend;
            pv_only_gc(pv_only_gc.count) := ty_gc(ii.inst_id,ii.GCCRBS+ii.GCCUBS,ii.GCCRBR+ii.GCCRBR,ii.GCSMR+ii.GESMR+ii.GCSMS+ii.GESMS);
          -------------- Getting Total/sum
            vt_tprse   :=  vt_tprse + ii.tparse;
            vt_hprse   :=  vt_hprse + ii.hparse;
            vt_phwio   :=  vt_phwio + ii.phywio;
            vt_phwmb   :=  vt_phwmb + ii.phywmb;
            vt_phrio   :=  vt_phrio + ii.phyrio;
            vt_phrmb   :=  vt_phrmb + ii.phyrmb;
            vt_slio    :=  vt_slio  + ii.sesslio;
            vt_exec    :=  vt_exec  + ii.totexec;
            vt_redo    :=  vt_redo  + ii.redomb;
            vt_comt    :=  vt_comt  + ii.ccommit;
            vt_exSS    :=  vt_exSS  + ii.ExSSMB;
            vt_exSI    :=  vt_exSI  + ii.ExSIMB;
            vt_exFC    :=  vt_exFC  + ii.ExFCRh;
         --------------
          end loop;
   end loop;
  -------
     fv_ta_obj.extend;
     fv_ta_obj(fv_ta_obj.count) := ty_obj( '+-----------+-----------------------+-----------+-------+-----------+----------+------------+----------+------------+----------+--------+--------+----------+---------+---------+'  )  ;
     fv_ta_obj.extend;
     fv_ta_obj(fv_ta_obj.count) := ty_obj( '                              TOTAL :' || lpad(vt_tprse,11,' ')||','||lpad(vt_hprse,7,' ')||','||lpad(vt_phwio,11,' ')||','||lpad(vt_phwmb,10,' ')||','||lpad(vt_phrio,12,' ')||','||lpad(vt_phrmb,10,' ')||','||lpad(vt_slio,12,' ')||','||lpad(vt_exec,10,' ')||','||lpad(vt_redo,8,' ')||','||lpad(vt_comt,8,' ')||','||lpad(vt_ExSS,10,' ')||','||lpad(vt_ExSI,9,' ')||','||lpad(vt_ExFC,9,' ')||',' );
return fv_ta_obj;
exception
when others then
raise_application_Error(-20001,'GINSTBUILDDATA: '||sqlerrm );
end;
-------------------
------##################
-- gash - build dataset from gv\$active_Session_history for the given sample time,
-- added logic to eliminate the own session info
------##################
FUNCTION GASH (FV_ST_SMPLTIME DATE,FV_ET_SMPLTIME DATE) RETURN TA_GASH
is
FV_GASH    TA_GASH := TA_GASH();
FV_SQL     VARCHAR2(2000);
BEGIN
IF PV_VERSION = 12 THEN
-- In below cursor, I am using IS_RESOLVED_ADAPTIVE_PLAN for 12c.
-- Using Min function for SQL Plan Control to pick the plan with sql patch/profile/adaptive info in case when we have both plans
FV_SQL  := q'[select ty_gash(gash.Inst_id, gash.session_id, gash.sql_id, gash.sql_child_number, substr(sql_Text,1,100), decode(sql_plan_hash_value,0,null,sql_plan_hash_value), round(decode(IO_CELL_OFFLOAD_ELIGIBLE_BYTES,0,0,100*(IO_CELL_OFFLOAD_ELIGIBLE_BYTES-IO_INTERCONNECT_BYTES)/decode(IO_CELL_OFFLOAD_ELIGIBLE_BYTES,0,1,IO_CELL_OFFLOAD_ELIGIBLE_BYTES))), substr(nvl2(sql_profile,'SProf',null)||nvl2(sql_plan_baseline,'SBase',null)||nvl2(sql_patch,'SPatc',null)||nvl2( decode(IS_RESOLVED_ADAPTIVE_PLAN,'Y','Y'),'ADapt',null),1,9), pga_allocated, temp_space_allocated, case when session_state = 'WAITING' then gash.event else 'ON CPU' end, case when session_state = 'WAITING' then gash.wait_class else 'ON CPU' end, gash.delta_Time, gash.current_obj#)
from gv\$active_Session_history gash, gv\$sql gsql
where gash.sample_time between :fv_st_smpltime and :fv_et_smpltime
and  gash.program not like '%(PZ%'
and  gash.delta_time > 0
and (gash.wait_class != 'Idle' or gash.session_state != 'WAITING')
and  gash.inst_id || ':' || gash.session_id != sys_context('userenv','INSTANCE') || ':' || sys_context('userenv','SID')
and gash.inst_id = gsql.inst_id and gash.sql_id=gsql.sql_id]';
else    -- For 11gR2 Version
FV_SQL  := q'[select ty_gash(gash.Inst_id, gash.session_id, gash.sql_id, gash.sql_child_number, substr(sql_Text,1,100), decode(sql_plan_hash_value,0,null,sql_plan_hash_value), round(decode(IO_CELL_OFFLOAD_ELIGIBLE_BYTES,0,0,100*(IO_CELL_OFFLOAD_ELIGIBLE_BYTES-IO_INTERCONNECT_BYTES)/decode(IO_CELL_OFFLOAD_ELIGIBLE_BYTES,0,1,IO_CELL_OFFLOAD_ELIGIBLE_BYTES))), substr(nvl2(sql_profile,'SProf',null)||nvl2(sql_plan_baseline,'SBase',null)||nvl2(sql_patch,'SPatc',null),1,9), pga_allocated, temp_space_allocated, case when session_state = 'WAITING' then gash.event else 'ON CPU' end, case when session_state = 'WAITING' then gash.wait_class else 'ON CPU' end, gash.delta_Time, gash.current_obj#)
from gv\$active_Session_history gash, gv\$sql gsql
where gash.sample_time between :fv_st_smpltime and :fv_et_smpltime
and gash.program not like '%(PZ%'
and gash.delta_time > 0
and (gash.wait_class != 'Idle' or gash.session_state != 'WAITING')
and gash.inst_id || ':' || gash.session_id != sys_context('userenv','INSTANCE') || ':' || sys_context('userenv','SID')
and gash.inst_id = gsql.inst_id and gash.sql_id = gsql.sql_id]';
END IF;
execute immediate fv_sql bulk collect into fv_gash using fv_st_smpltime,fv_et_smpltime;
return fv_gash;
end;
-------------------
------##################
-- gashbuilddata - it access data from collection pv_only_gash built in gash function for given sample
------##################
function gashbuilddata (fv_only_gash ta_gash ) return ta_obj
is
fv_ta_obj      ta_obj := ta_obj();
fv_wait_obj    ta_obj := ta_obj();
fv_sql_obj     ta_obj := ta_obj();
fv_output      varchar2(200);
fv_sid_string  varchar2(66);
begin
--js resetting graph wait variables
pv_cpuwaitpct := 0;
pv_iowaitpct  := 0;
pv_cluwaitpct := 0;
pv_othwaitpct := 0;
------------
pv_top_sql.delete;
--- getting top 5 events based on time spent event wise
for i in (select pct,event,wait_class from (select wait_class,event, round(evnttime/tottime * 100,1) pct from
(select wait_class,event, sum(time_waited) evnttime from table(fv_only_gash) where event is not null group by wait_class, event ) evnt,
(select sum(time_Waited) tottime from table(fv_only_gash )) tot order by pct desc) where rownum < 6) loop
FV_WAIT_OBJ.EXTEND;
fv_wait_obj(fv_wait_obj.count) :=  ty_obj('| ' || lpad(round(i.pct,1) || '%',6,' ') || ' | ' || rpad(substr(i.event,1,34),34,' ') || ' | ' || rpad(i.wait_class,13,' ') || ' |');
-------------- Storing info in 4 variables to get the % of of all the waits for total active sessions for graph
case
when i.wait_class = 'ON CPU'      then pv_cpuwaitpct :=   (pv_cpuwaitpct + i.pct);
when i.wait_class = 'User I/O'    then pv_iowaitpct  :=   (pv_iowaitpct  + i.pct);
when i.wait_class = 'System I/O'  then pv_iowaitpct  :=   (pv_iowaitpct  + i.pct);
when i.wait_class = 'Cluster'     then pv_cluwaitpct :=   (pv_cluwaitpct + i.pct);
ELSE
pv_othwaitpct := (pv_othwaitpct + i.pct );
end case;
-------------
end loop;
--- getting top 5 sqls based on time spent event wise
 FOR II IN (select PLANHASH, PCT,SQL_ID || '(' || SQL_CHILD || ')' SQL_ID, OFFLOADPCT,PLANCNTRL, pgamb, tmpmb
 FROM      (select SQL_ID,SQL_CHILD, PLANHASH, OFFLOADPCT, PLANCNTRL, ROUND(SQLTIME/TOTTIME * 100,1) PCT, PGAMB, TMPMB
 FROM      (select SQL_ID,SQL_CHILD, PLANHASH, max(OFFLOADPCT) OFFLOADPCT,min(PLANCNTRL) PLANCNTRL, max(pgamb) pgamb, max(tmpmb) tmpmb, SUM(TIME_WAITED) SQLTIME FROM TABLE(FV_ONLY_GASH)
where sql_id is not null group by sql_id,sql_child, planhash ) sqlt,
(select sum(time_Waited) tottime from  table(fv_only_gash)) tot order by pct desc) where rownum < 6) loop
--- building inst_id and sid string for top sqls
select substr(sidstring,1,66) into fv_sid_string
from (select  listagg(inst_id || ':' || sid,', ') within group (order by  sql_id || '(' || sql_child || ')' ) sidstring
FROM (select DISTINCT SQL_ID, SQL_CHILD, INST_ID, SID FROM TABLE(FV_ONLY_GASH) WHERE SQL_ID || '(' || SQL_CHILD || ')' = II.SQL_ID));
V_PGAMB := FBYT(II.PGAMB);
v_tmpmb := fbyt(ii.tmpmb);
            FV_SQL_OBJ.EXTEND;
            fv_sql_obj(fv_sql_obj.count)  :=  ty_obj('    | ' || lpad(round(ii.pct,1) || '%',6,' ') || ' | ' || rpad(ii.sql_id,17,' ') || '| ' || rpad(nvl(ii.planhash,' '),9,' ') || ' | ' || lpad(ii.OFFLOADPCT || '%',7,' ') || ' |' || lpad(v_pgamb,7,' ') || '|' || lpad(v_tmpmb,7,' ') || '| ' || rpad(nvl(ii.PLANCNTRL,' '),5,' ') || ' | ' || rpad(fv_sid_string,32,' ') || ' |');
                --- filling global collection pv_top_sql for later use
           pv_top_sql.extend; pv_top_sql(pv_Top_sql.count) := ty_obj(substr(ii.sql_id,1,13));
 end loop;
  FV_TA_OBJ.EXTEND;
  fv_ta_obj(fv_ta_obj.count) := ty_obj('+IMPACT%-+--TOP WAIT EVENTS-------------------+-WAIT CLASS----+    +IMPACT%-+ TOP SQLs (child)-+--PLAN#----+-OFFLOAD-+--PGA--+--TEMP-+-PLANC-+------TOP SESSIONS----INST:SID----+' ) ;
--- printing top wait events and top sqls
  for iii in 1..greatest(fv_wait_obj.count,fv_sql_obj.count) loop
    IF FV_WAIT_OBJ.EXISTS(III)
      then
        fv_output := fv_wait_obj(iii).output;
      ELSE
        FV_OUTPUT :=                         '|        |                                    |               |' ;
      end if;
      if fv_sql_obj.exists(iii) then
        fv_output := fv_output || fv_sql_obj(iii).output;
      ELSE
       FV_OUTPUT := FV_OUTPUT || '    |        |                  |           |         |       |       |       |                                  |';
            END IF;
             fv_ta_obj.extend;
             fv_ta_obj(fv_ta_obj.count) := ty_obj(fv_output);
  end loop;
  FV_TA_OBJ.EXTEND;
  fv_ta_obj(fv_ta_obj.count) := ty_obj('+--------+------------------------------------+---------------+    +--------+------------------+-----------+---------+-------+-------+-------+----------------------------------+' );
 -- adding emplty lines to getting fixed ASG [Active Session Graph ]
 for iv in 1..(7-fv_ta_obj.count) loop
   fv_ta_obj.extend;
   fv_ta_obj(fv_ta_obj.count):= ty_obj(' ');
   end loop;
return fv_ta_obj;
--exception
--when others then
--raise_application_Error(-20001,'GASH: ' || sqlerrm);
end;
-------------------
----#######################
PROCEDURE PRINT_MAXCPU(v_ARRAYNO  INT )
as
BEGIN
PA69(V_ARRAYNO).OUTPUT := '-';
PA68(V_ARRAYNO).OUTPUT := 'M';
PA67(V_ARRAYNO).OUTPUT := 'A';
PA66(V_ARRAYNO).OUTPUT := 'X';
PA65(V_ARRAYNO).OUTPUT := ' ';
PA64(V_ARRAYNO).OUTPUT := 'C';
PA63(V_ARRAYNO).OUTPUT := 'P';
PA62(V_ARRAYNO).OUTPUT := 'U';
PA61(V_ARRAYNO).OUTPUT := '[';
if length(pv_num_cpus)= 1 then
PA60(V_ARRAYNO).OUTPUT := PV_NUM_CPUS;
PA59(V_ARRAYNO).OUTPUT := ']';
PA58(V_ARRAYNO).OUTPUT := '-';
ELSIF LENGTH(PV_NUM_CPUS)= 2 THEN
PA60(V_ARRAYNO).OUTPUT := SUBSTR(PV_NUM_CPUS,1,1);
PA59(V_ARRAYNO).OUTPUT := SUBSTR(PV_NUM_CPUS,2,1);
PA58(V_ARRAYNO).OUTPUT := ']';
PA57(V_ARRAYNO).OUTPUT := '-';
ELSIF LENGTH(PV_NUM_CPUS)= 3 THEN
PA60(V_ARRAYNO).OUTPUT := SUBSTR(PV_NUM_CPUS,1,1);
PA59(V_ARRAYNO).OUTPUT := SUBSTR(PV_NUM_CPUS,2,1);
PA58(V_ARRAYNO).OUTPUT := SUBSTR(PV_NUM_CPUS,3,1);
PA57(V_ARRAYNO).OUTPUT := ']';
PA56(V_ARRAYNO).OUTPUT := '-';
END IF;
end;
------------------
------##################
-- Gcinfo uses pv_only_gc collection built by ginstbuilddata to format
------##################
function gcinfo return ta_obj
as
fv_gcs     ta_obj := ta_obj();
fv_topgseg ta_obj := ta_obj();
fv_ta_obj  ta_obj := ta_obj();
fv_seg              varchar2(40);
fv_totblks           int;
fv_totmsgs           int;
begin
------------------------------
-- *BASED on AWR, below formula can be used to calculate  Estd interconnect Traffic
------------------------------
/*
Estd Interconnect traffic (KB): =(('gc cr blocks received' + 'gc current blocks received' + 'gc cr blocks served' + 'gc current blocks served') * db Block size)
+ (('gcs messages sent' + 'ges messages sent' + 'gcs msgs received' + 'ges msgs received' )* 200 )/1024/
 -- Sample Calculation from AWR using Above Formula
 Global Cache Load Profile
~~~~~~~~~~~~~~~~~~~~                  Per Second       Per Transact
                                      ---------------       ------------
  Global Cache blocks received:              1,086.29                  3
    Global Cache blocks served:              1,088.33                  3
     GCS/GES messages received:              2,736.50                  9
         GCS/GES messages sent:              2,681.79                  9
            DBWR Fusion writes:                  5.90                  0
 Estd Interconnect traffic (KB)             18,455.23
((1086.29 + 1088.33) * 8192) / 1024 = 17396.96
((2736.50 + 2681.79) * 200 / 1024 = 1058.26
 17396.96 + 1058.26  = (18455.22) <-- Final Value
*/
--  pv_only_gc is being populated from ginstbuilddata function [ access gv\$sysstat and gv\$dlm_misc ] only for GC* waits
--  calculating totblks received/sent and total GCS/GES messages received/sent
for i in 1..pv_only_gc.count loop
fv_totblks :=  (nvl(pv_only_gc(i).GCBCS,0) + nvl(pv_only_gc(i).GCBRS,0)) * pv_block_size ;
fv_totmsgs :=   nvl(pv_only_gc(i).GMSR,0) * 200 ;
fv_gcs.extend;
fv_gcs(fv_gcs.count) := ty_obj ( lpad(pv_only_gc(i).inst_id,3,' ') || ' | ' || lpad(nvl(pv_only_gc(i).GCBCS,0),9,' ') || '|' || lpad(nvl(pv_only_gc(i).GCBRS,0),10,' ') || '|' || lpad(round(((fv_totblks+fv_totmsgs)/1048576),1),11,' ') || '|');
end loop;
--
--  querying pv_only_gash [ global active session history data for Cluster waits and using current_obj# to find the topobject
   for ii in (select * from (select obj#, round(evnttime/tottime * 100,1) pct from
                            (select  obj#,sum(time_waited) evnttime from table(pv_only_gash) where wait_class = 'Cluster' and  obj# != -1 group by obj# ) gcobj,
                            (select sum(time_Waited) tottime from table(pv_only_gash ) where wait_class = 'Cluster' and  obj# != -1 ) tot order by pct desc) where rownum < 6) loop
            begin
            --- getting object name from gv\$segment_statistics
            select rpad((substr(s.object_type,1,3) || ':' || substr(s.object_name || nvl2(subobject_name, ':' || subobject_name,null),1,33)),37,' ') into fv_seg from gv\$segment_statistics s where s.obj# = ii.obj# and rownum = 1;
            exception
            when no_data_found then
            fv_seg := 'Obj ID not populated' ;
            end;
            fv_topgseg.extend;
            fv_topgseg(fv_topgseg.count) := ty_obj (' |' || lpad(ii.pct || '%',5) || ' ' || fv_seg);
            end loop;
--
-- building header for Global Cache info
fv_ta_obj.extend;fv_ta_obj(fv_ta_obj.count) := ty_obj( '    |  Global  |  Global  | Estd.     |                            ');
fv_ta_obj.extend;fv_ta_obj(fv_ta_obj.count) := ty_obj( '    |  Cache   |  Cache   | Intercnt  |  | TOP Segments by GC*     |');
FV_TA_OBJ.EXTEND;FV_TA_OBJ(FV_TA_OBJ.COUNT) := TY_OBJ( 'Inst|  Blocks  |  Blocks  | Traffic   |  | Waits                   |');
FV_TA_OBJ.EXTEND;FV_TA_OBJ(FV_TA_OBJ.COUNT) := TY_OBJ( '  ID|  Sent/s  |  Rcvd/s  | MB/s      |  | IMPACT% [Type:Segment]  |');
fv_ta_obj.extend;fv_ta_obj(fv_ta_obj.count) := ty_obj( '+---+----------+----------+-----------+  +-------------------------+');
            for iii in 1..12 loop     -- Concatinating output about GC info and TOP Segment
               if fv_gcs.count < iii then fv_gcs.extend; end if;
               if fv_topgseg.count < iii then fv_topgseg.extend; end if;
            fv_ta_obj.extend; fv_ta_obj(fv_ta_obj.count) := ty_obj(rpad(nvl(fv_gcs(iii).output,' '),39,' ') || ' ' || fv_topgseg(iii).output );
            end loop;
return fv_ta_obj;
exception
when others then
raise_application_Error(-20001,'GCINFO : ' || sqlerrm );
end ;
-------------------
------##################
--   stactsessar - it shuffles all the arrays to have moving effect in ASG
--   it also rearrange the max sess based on the changed array range.
------##################
procedure stactsessarr
as
procedure setgraphdigit(p_varrlenset int, p_pa in out ta_obj)
as
begin
pv_work_done := 1 ;
pva := 0;
pvb := 0;
pvc := 0;
pvd := 0;
pve := 0;
 if to_number(p_pa(18).output) > 0 then    -- CPU
     p_localarray := round(p_varrlenset * to_number(p_pa(18).output)/100) ;
     if p_localarray > 0 then
          for i in pv_work_done..p_localarray loop
            p_pa(i) := ty_obj(pv_cpu_dig) ;
            end loop;
          pv_work_done := pv_work_done + p_localarray ;
     end if;
end if;
if to_number(p_pa(19).output) > 0 then    -- IO
     p_localarray := round( p_varrlenset * to_number(p_pa(19).output)/100);
     if p_localarray > 0 then
          for i in pv_work_done..(pv_work_done + p_localarray) loop
            p_pa(i) := ty_obj(pv_io_dig) ;
          end loop;
          pv_work_done :=  pv_work_done + p_localarray ;
     end if;
end if;
if to_number(p_pa(20).output) > 0 then    -- CLU
     p_localarray := round( p_varrlenset * to_number(p_pa(20).output)/100);
     if p_localarray > 0 then
          for i in pv_work_done..(pv_work_done + p_localarray) loop
            p_pa(i) := ty_obj(pv_CLU_dig) ;
          end loop;
          pv_work_done :=  pv_work_done + p_localarray ;
     end if;
end if;
if to_number(p_pa(21).output) > 0 then    -- OTH
     p_localarray := round( p_varrlenset * to_number(p_pa(21).output)/100);
     if p_localarray > 0 then
          for i in pv_work_done..(pv_work_done + p_localarray) loop
            p_pa(i) := ty_obj(pv_oth_dig) ;
          end loop;
          pv_work_done :=  pv_work_done + p_localarray ;
     end if;
end if;
     FOR I IN (P_VARRLENSET+1)..15 LOOP  --filling remaining array
         P_PA(I) := TY_OBJ(' ');   -- I have replaced single space ' ' with ' ' to adjust colored graph
       end loop;
 end;
begin
 --- shuffling array except the first one
pa80 := pa79; pa79 := pa78; pa78 := pa77; pa77 := pa76; pa76 := pa75; pa75 := pa74; pa74 := pa73; pa73 := pa72; pa72 := pa71; pa71 := pa70;
pa70 := pa69; pa69 := pa68; pa68 := pa67; pa67 := pa66; pa66 := pa65; pa65 := pa64; pa64 := pa63; pa63 := pa62; pa62 := pa61; pa61 := pa60;
pa60 := pa59; pa59 := pa58; pa58 := pa57; pa57 := pa56; pa56 := pa55; pa55 := pa54; pa54 := pa53; pa53 := pa52; pa52 := pa51; pa51 := pa50;
pa50 := pa49; pa49 := pa48; pa48 := pa47; pa47 := pa46; pa46 := pa45; pa45 := pa44; pa44 := pa43; pa43 := pa42; pa42 := pa41; pa41 := pa40;
pa40 := pa39; pa39 := pa38; pa38 := pa37; pa37 := pa36; pa36 := pa35; pa35 := pa34; pa34 := pa33; pa33 := pa32; pa32 := pa31; pa31 := pa30;
pa30 := pa29; pa29 := pa28; pa28 := pa27; pa27 := pa26; pa26 := pa25; pa25 := pa24; pa24 := pa23; pa23 := pa22; pa22 := pa21; pa21 := pa20;
pa20 := pa19; pa19 := pa18; pa18 := pa17; pa17 := pa16; pa16 := pa15; pa15 := pa14; pa14:=pa13; pa13:=pa12; pa12:=pa11; pa11:=pa10;
pa10:= pa9; pa9:=pa8; pa8 :=pa7; pa7:=pa6; pa6:=pa5; pa5:=pa4; pa4:=pa3; pa3:=pa2; pa2:=pa1;
    -- updating first array
       pa1(21) := ty_obj(pv_othwaitpct);
       pa1(20) := ty_obj(pv_cluwaitpct);
       pa1(19) := ty_obj(pv_iowaitpct);
       pa1(18) := ty_obj(pv_cpuwaitpct);
       pa1(17) := ty_obj(pv_maxval);
       pa1(16) := ty_obj(pv_maxsess);
--- here else clause is used for the empty arrays when we start dashboard
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa1(16).output) then js_maxsess := to_number(pa1(16).output); js_arr := i-1;  setgraphdigit(i-1,pa1);  exit; else pa1(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa2(16).output) then setgraphdigit(i-1,pa2);  exit; else pa2(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa3(16).output) then setgraphdigit(i-1,pa3);  exit; else pa3(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa4(16).output) then setgraphdigit(i-1,pa4);  exit; else pa4(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa5(16).output) then setgraphdigit(i-1,pa5);  exit; else pa5(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa6(16).output) then setgraphdigit(i-1,pa6);  exit; else pa6(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa7(16).output) then setgraphdigit(i-1,pa7);  exit; else pa7(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa8(16).output) then setgraphdigit(i-1,pa8);  exit; else pa8(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa9(16).output) then setgraphdigit(i-1,pa9);  exit; else pa9(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa10(16).output) then setgraphdigit(i-1,pa10);  exit; else pa10(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa11(16).output) then setgraphdigit(i-1,pa11);  exit; else pa11(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa12(16).output) then setgraphdigit(i-1,pa12);  exit; else pa12(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa13(16).output) then setgraphdigit(i-1,pa13);  exit; else pa13(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa14(16).output) then setgraphdigit(i-1,pa14);  exit; else pa14(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa15(16).output) then setgraphdigit(i-1,pa15);  exit; else pa15(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa16(16).output) then setgraphdigit(i-1,pa16);  exit; else pa16(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa17(16).output) then setgraphdigit(i-1,pa17);  exit; else pa17(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa18(16).output) then setgraphdigit(i-1,pa18);  exit; else pa18(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa19(16).output) then setgraphdigit(i-1,pa19);  exit; else pa19(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa20(16).output) then setgraphdigit(i-1,pa20);  exit; else pa20(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa21(16).output) then setgraphdigit(i-1,pa21);  exit; else pa21(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa22(16).output) then setgraphdigit(i-1,pa22);  exit; else pa22(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa23(16).output) then setgraphdigit(i-1,pa23);  exit; else pa23(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa24(16).output) then setgraphdigit(i-1,pa24);  exit; else pa24(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa25(16).output) then setgraphdigit(i-1,pa25);  exit; else pa25(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa26(16).output) then setgraphdigit(i-1,pa26);  exit; else pa26(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa27(16).output) then setgraphdigit(i-1,pa27);  exit; else pa27(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa28(16).output) then setgraphdigit(i-1,pa28);  exit; else pa28(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa29(16).output) then setgraphdigit(i-1,pa29);  exit; else pa29(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa30(16).output) then setgraphdigit(i-1,pa30);  exit; else pa30(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa31(16).output) then setgraphdigit(i-1,pa31);  exit; else pa31(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa32(16).output) then setgraphdigit(i-1,pa32);  exit; else pa32(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa33(16).output) then setgraphdigit(i-1,pa33);  exit; else pa33(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa34(16).output) then setgraphdigit(i-1,pa34);  exit; else pa34(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa35(16).output) then setgraphdigit(i-1,pa35);  exit; else pa35(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa36(16).output) then setgraphdigit(i-1,pa36);  exit; else pa36(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa37(16).output) then setgraphdigit(i-1,pa37);  exit; else pa37(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa38(16).output) then setgraphdigit(i-1,pa38);  exit; else pa38(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa39(16).output) then setgraphdigit(i-1,pa39);  exit; else pa39(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa40(16).output) then setgraphdigit(i-1,pa40);  exit; else pa40(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa41(16).output) then setgraphdigit(i-1,pa41);  exit; else pa41(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa42(16).output) then setgraphdigit(i-1,pa42);  exit; else pa42(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa43(16).output) then setgraphdigit(i-1,pa43);  exit; else pa43(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa44(16).output) then setgraphdigit(i-1,pa44);  exit; else pa44(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa45(16).output) then setgraphdigit(i-1,pa45);  exit; else pa45(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa46(16).output) then setgraphdigit(i-1,pa46);  exit; else pa46(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa47(16).output) then setgraphdigit(i-1,pa47);  exit; else pa47(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa48(16).output) then setgraphdigit(i-1,pa48);  exit; else pa48(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa49(16).output) then setgraphdigit(i-1,pa49);  exit; else pa49(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa50(16).output) then setgraphdigit(i-1,pa50);  exit; else pa50(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa51(16).output) then setgraphdigit(i-1,pa51);  exit; else pa51(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa52(16).output) then setgraphdigit(i-1,pa52);  exit; else pa52(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa53(16).output) then setgraphdigit(i-1,pa53);  exit; else pa53(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa54(16).output) then setgraphdigit(i-1,pa54);  exit; else pa54(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa55(16).output) then setgraphdigit(i-1,pa55);  exit; else pa55(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa56(16).output) then setgraphdigit(i-1,pa56);  exit; else pa56(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa57(16).output) then setgraphdigit(i-1,pa57);  exit; else pa57(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa58(16).output) then setgraphdigit(i-1,pa58);  exit; else pa58(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa59(16).output) then setgraphdigit(i-1,pa59);  exit; else pa59(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa60(16).output) then setgraphdigit(i-1,pa60);  exit; else pa60(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa61(16).output) then setgraphdigit(i-1,pa61);  exit; else pa61(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa62(16).output) then setgraphdigit(i-1,pa62);  exit; else pa62(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa63(16).output) then setgraphdigit(i-1,pa63);  exit; else pa63(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa64(16).output) then setgraphdigit(i-1,pa64);  exit; else pa64(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa65(16).output) then setgraphdigit(i-1,pa65);  exit; else pa65(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa66(16).output) then setgraphdigit(i-1,pa66);  exit; else pa66(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa67(16).output) then setgraphdigit(i-1,pa67);  exit; else pa67(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa68(16).output) then setgraphdigit(i-1,pa68);  exit; else pa68(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa69(16).output) then setgraphdigit(i-1,pa69);  exit; else pa69(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa70(16).output) then setgraphdigit(i-1,pa70);  exit; else pa70(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa71(16).output) then setgraphdigit(i-1,pa71);  exit; else pa71(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa72(16).output) then setgraphdigit(i-1,pa72);  exit; else pa72(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa73(16).output) then setgraphdigit(i-1,pa73);  exit; else pa73(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa74(16).output) then setgraphdigit(i-1,pa74);  exit; else pa74(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa75(16).output) then setgraphdigit(i-1,pa75);  exit; else pa75(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa76(16).output) then setgraphdigit(i-1,pa76);  exit; else pa76(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa77(16).output) then setgraphdigit(i-1,pa77);  exit; else pa77(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa78(16).output) then setgraphdigit(i-1,pa78);  exit; else pa78(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa79(16).output) then setgraphdigit(i-1,pa79);  exit; else pa79(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa80(16).output) then setgraphdigit(i-1,pa80);  exit; else pa80(i) := ty_obj(' ');  end if;  end loop;
                for i in 2..15 loop
               if pv_num_cpus < to_number(pa_stet(i).output) then
                   pv_maxcpuprint := pa_stet(i-1).output;  exit; end if;
               end loop;
               -- printing exact active sess
               pa81.delete; pa81.extend(15);
               pa82.delete; pa82.extend(15);
               pa83.delete; pa83.extend(15);
               pa84.delete; pa84.extend(15);
               for i in 1..15 loop
               if  pa1(i).output in (pv_cpu_dig,pv_io_dig,pv_clu_dig,pv_oth_dig) then
                 null; -- need to add logic
                 else
                   if i > 1 then -- protecting being no active session
                   pa81(i-1) := ty_obj(substr(lpad(pv_maxsess,4,'_'),1,1));
                   pa82(i-1) := ty_obj(substr(lpad(pv_maxsess,4,'_'),2,1));
                   pa83(i-1) := ty_obj(substr(lpad(pv_maxsess,4,'_'),3,1));
                   pa84(i-1) := ty_obj(substr(lpad(pv_maxsess,4,'_'),4,1));
                   end if;
                 exit;
                 end if;
               end loop;
exception
when others then
raise_application_Error(-20001,'STACTSESSAR : ' || sqlerrm || '  ' || pv_work_done ) ;
end;
-------------------
------##################
-- gactses : it set the upper bound of array based on
-- no. of active sessions and add 15%
-- it also builds the range of sessions
------##################
Procedure gactses
is
begin
       -- Max active session at this point
       select  count (distinct ( inst_id||':'||sid )) into  pv_maxsess  from  table(pv_only_gash);
          -- Setting MAx VALUE top of CPU Vs Active sess and adding 15% -
        select case when round (max(pv_maxsess+(pv_maxsess*15/100))) < 15 then 15 else round (max(pv_maxsess+(pv_maxsess*15/100))) end  maxval  into pv_maxval from dual;
        --- searching if any existing array has got higher value.
             pv_tmp_maxval := greatest(pv_maxval,nvl(pa1(17).output,0),nvl(pa2(17).output,0),nvl(pa3(17).output,0),nvl(pa4(17).output,0)
            ,nvl(pa5(17).output,0),nvl(pa6(17).output,0), nvl(pa7(17).output,0),nvl(pa8(17).output,0),nvl(pa9(17).output,0),nvl(pa10(17).output,0),nvl(pa11(17).output,0)
            ,nvl(pa12(17).output,0),nvl(pa13(17).output,0),nvl(pa14(17).output,0),nvl(pa15(17).output,0)
            ,nvl(pa16(17).output,0) ,nvl(pa17(17).output,0) ,nvl(pa18(17).output,0) ,nvl(pa19(17).output,0) ,nvl(pa20(17).output,0)
            ,nvl(pa21(17).output,0) ,nvl(pa22(17).output,0) ,nvl(pa23(17).output,0) ,nvl(pa24(17).output,0) ,nvl(pa25(17).output,0)
            ,nvl(pa26(17).output,0) ,nvl(pa27(17).output,0) ,nvl(pa28(17).output,0) ,nvl(pa29(17).output,0) ,nvl(pa30(17).output,0)
            ,nvl(pa31(17).output,0) ,nvl(pa32(17).output,0) ,nvl(pa33(17).output,0) ,nvl(pa34(17).output,0) ,nvl(pa35(17).output,0)
            ,nvl(pa36(17).output,0) ,nvl(pa37(17).output,0) ,nvl(pa38(17).output,0) ,nvl(pa39(17).output,0) ,nvl(pa40(17).output,0)
            ,nvl(pa41(17).output,0) ,nvl(pa42(17).output,0) ,nvl(pa43(17).output,0) ,nvl(pa44(17).output,0) ,nvl(pa45(17).output,0)
            ,nvl(pa46(17).output,0) ,nvl(pa47(17).output,0) ,nvl(pa48(17).output,0) ,nvl(pa49(17).output,0) ,nvl(pa50(17).output,0)
            ,nvl(pa51(17).output,0) ,nvl(pa52(17).output,0) ,nvl(pa53(17).output,0) ,nvl(pa54(17).output,0) ,nvl(pa55(17).output,0)
            ,nvl(pa56(17).output,0) ,nvl(pa57(17).output,0) ,nvl(pa58(17).output,0) ,nvl(pa59(17).output,0) ,nvl(pa60(17).output,0)
            ,nvl(pa61(17).output,0) ,nvl(pa62(17).output,0) ,nvl(pa63(17).output,0) ,nvl(pa64(17).output,0) ,nvl(pa65(17).output,0)
            ,nvl(pa66(17).output,0) ,nvl(pa67(17).output,0) ,nvl(pa68(17).output,0) ,nvl(pa69(17).output,0) ,nvl(pa70(17).output,0)
            ,nvl(pa71(17).output,0) ,nvl(pa72(17).output,0) ,nvl(pa73(17).output,0) ,nvl(pa74(17).output,0) ,nvl(pa75(17).output,0)
            ,nvl(pa76(17).output,0) ,nvl(pa77(17).output,0) ,nvl(pa78(17).output,0) ,nvl(pa79(17).output,0) ,nvl(pa80(17).output,0));
          -- Fill Start/End array to print
             pa_stet.delete;
             select  ty_obj(val) bulk collect into pa_stet from
			 (select ceil(rownum * (pv_tmp_maxval/14)) val from dict where rownum < 15
        union all
        select 1 from dual) order by val;
        pa_stet.extend;
        pa_stet.extend;
stactsessarr;   -- calls stactsessarr to shuffle all the arrays to have moving effect
exception
when others then
raise_application_Error(-20001,'GACTSES : ' || sqlerrm);
end;
-------------------/
Procedure gset3sysmetrics (p_sysmetric_id1 int,p_sysmetric_id2 int,p_sysmetric_id3 int)
as
BEGIN
--------
PV_SYSMETRIC_STRING1 := ' ';   -- setting space for rpad
PV_SYSMETRIC_STRING2 := ' ';
PV_SYSMETRIC_STRING3 := ' ';
--------
--------------------------
select MAX(DECODE(METRIC_ID, NVL(P_SYSMETRIC_ID1,2144), V)),
       MAX(DECODE(METRIC_ID, NVL(P_SYSMETRIC_ID2,2008), V)),
       max(decode(metric_id, nvl(p_sysmetric_id3,2010), V))
       into
       pv_sysmetric_string1,
       PV_SYSMETRIC_STRING2,
       pv_sysmetric_string3
from
(select  metric_id, metric_name||'- '||V  v from
(select metric_id, METRIC_NAME, LISTAGG(VALUE, ', ') WITHIN GROUP (ORDER BY METRIC_name) "V"
FROM (select metric_id,REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(METRIC_NAME,
         'Average Synchronous Single-Block Read Latency','SingBlk Read Latency'),
         'User Rollback Undo','UsrRlbkUndo'),
         'Logical Reads Per Sec','LogicalReads /s'),
         'Per Second','/s'),
         'Per Sec','/s'),
         'Per Txn','/tx'),
         'Shared Pool','SPool'),
         'Hit Ratio','HitRtio'),
         'Global Cache','GC'),
         'Total','Tot'),
         'Database','DB'),
         'Enqueue','Enq'),
         'Percentage','%'),
         'per Second','/s'),
         'Physical','Phy'),
         'Workload','Wrklod'),
         'Capture','Cptur'),
         'Execute','Exec'),
         'Consistent','Consist'),
         'parallelized','PX'),
         'downgraded','\/'),
         'Records','Recrds'),
         'Requests','Reqs'),
         'Block','Blk'),
         'Interconnect','Interc'),
         'statements','stmts'),
         'Bytes','Byts') Metric_name, Value
        FROM (select metric_id, METRIC_NAME, INST_ID || ':' || ROUND(VALUE,1) VALUE FROM GV\$SYSMETRIC WHERE GROUP_ID = 2 and metric_id in ( nvl(p_sysmetric_id1,2144),nvl(p_sysmetric_id2,2008),nvl(p_sysmetric_id3,2010))))
GROUP BY metric_id, METRIC_NAME
order by Metric_name)
order by decode (metric_id, nvl(p_sysmetric_id1,2144), 1, nvl(p_sysmetric_id2,2008), 2, NVL(P_SYSMETRIC_ID3,2010), 3));
--------------------------
end;
------##################
-- gactsesret : it uses all global pa* arrays to format Active Session Graph
------##################
function gactsessret return ta_obj
as
fv_ta_obj  ta_obj := ta_obj();
BEGIN

IF     PV_MAXCPUPRINT = PA_STET(1).OUTPUT THEN PRINT_MAXCPU(1);
ELSIF  PV_MAXCPUPRINT = PA_STET(2).OUTPUT THEN PRINT_MAXCPU(2);
ELSIF  PV_MAXCPUPRINT = PA_STET(3).OUTPUT THEN PRINT_MAXCPU(3);
ELSIF  PV_MAXCPUPRINT = PA_STET(4).OUTPUT THEN PRINT_MAXCPU(4);
ELSIF  PV_MAXCPUPRINT = PA_STET(5).OUTPUT THEN PRINT_MAXCPU(5);
ELSIF  PV_MAXCPUPRINT = PA_STET(6).OUTPUT THEN PRINT_MAXCPU(6);
ELSIF  PV_MAXCPUPRINT = PA_STET(7).OUTPUT THEN PRINT_MAXCPU(7);
ELSIF  PV_MAXCPUPRINT = PA_STET(8).OUTPUT THEN PRINT_MAXCPU(8);
ELSIF  PV_MAXCPUPRINT = PA_STET(9).OUTPUT THEN PRINT_MAXCPU(9);
ELSIF  PV_MAXCPUPRINT = PA_STET(10).OUTPUT THEN PRINT_MAXCPU(10);
ELSIF  PV_MAXCPUPRINT = PA_STET(11).OUTPUT THEN PRINT_MAXCPU(11);
ELSIF  PV_MAXCPUPRINT = PA_STET(12).OUTPUT THEN PRINT_MAXCPU(12);
ELSIF  PV_MAXCPUPRINT = PA_STET(13).OUTPUT THEN PRINT_MAXCPU(13);
ELSIF  PV_MAXCPUPRINT = PA_STET(14).OUTPUT THEN PRINT_MAXCPU(14);
ELSIF  PV_MAXCPUPRINT = PA_STET(15).OUTPUT THEN PRINT_MAXCPU(15);
End If;

fv_Ta_obj.extend(20);
fv_ta_obj(1) :=ty_obj(rpad(' ',71,' ')||'        -------+'||'                                 ACTIVE SESSIONS GRAPH                              +----');
fv_ta_obj(2) :=ty_obj(rpad(' ',71,' ')||'  Active'||lpad(pa_stet(15).output,6,' ')||' |'||(
pa80(15).output||pa79(15).output||pa78(15).output||pa77(15).output||pa76(15).output||pa75(15).output||pa74(15).output||pa73(15).output||pa72(15).output||pa71(15).output||pa70(15).output||pa69(15).output||pa68(15).output||pa67(15).output||pa66(15).output||pa65(15).output||pa64(15).output||pa63(15).output||
pa62(15).output||pa61(15).output||pa60(15).output||pa59(15).output||pa58(15).output||pa57(15).output||pa56(15).output||pa55(15).output||pa54(15).output||pa53(15).output||pa52(15).output||pa51(15).output||pa50(15).output||pa49(15).output||pa48(15).output||pa47(15).output||pa46(15).output||pa45(15).output||
pa44(15).output||pa43(15).output||pa42(15).output||pa41(15).output||pa40(15).output||pa39(15).output||pa38(15).output||pa37(15).output||pa36(15).output||pa35(15).output||pa34(15).output||pa33(15).output||pa32(15).output||pa31(15).output||pa30(15).output||pa29(15).output||pa28(15).output||pa27(15).output||
pa26(15).output||pa25(15).output||pa24(15).output||pa23(15).output||pa22(15).output||pa21(15).output||pa20(15).output||pa19(15).output||pa18(15).output||pa17(15).output||pa16(15).output||pa15(15).output||pa14(15).output||pa13(15).output||pa12(15).output||pa11(15).output||pa10(15).output||pa9(15).output||
pa8(15).output||pa7(15).output||pa6(15).output||pa5(15).output||pa4(15).output||pa3(15).output||pa2(15).output||pa1(15).output)||rpad(nvl(pa81(15).output||pa82(15).output||pa83(15).output||pa84(15).output,' '),4,' ')||'| '||rpad(pa_stet(15).output,6,' '));

fv_ta_obj(3)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(1).output,1,71),71,' ')||'Sessions'||lpad(pa_stet(14).output,6,' ')||' |'||(
pa80(14).output||pa79(14).output||pa78(14).output||pa77(14).output||pa76(14).output||pa75(14).output||pa74(14).output||pa73(14).output||pa72(14).output||pa71(14).output||pa70(14).output||pa69(14).output||pa68(14).output||pa67(14).output||pa66(14).output||pa65(14).output||pa64(14).output||pa63(14).output||
pa62(14).output||pa61(14).output||pa60(14).output||pa59(14).output||pa58(14).output||pa57(14).output||pa56(14).output||pa55(14).output||pa54(14).output||pa53(14).output||pa52(14).output||pa51(14).output||pa50(14).output||pa49(14).output||pa48(14).output||pa47(14).output||pa46(14).output||pa45(14).output||
pa44(14).output||pa43(14).output||pa42(14).output||pa41(14).output||pa40(14).output||pa39(14).output||pa38(14).output||pa37(14).output||pa36(14).output||pa35(14).output||pa34(14).output||pa33(14).output||pa32(14).output||pa31(14).output||pa30(14).output||pa29(14).output||pa28(14).output||pa27(14).output||
PA26(14).OUTPUT||PA25(14).OUTPUT||PA24(14).OUTPUT||PA23(14).OUTPUT||PA22(14).OUTPUT||PA21(14).OUTPUT||PA20(14).OUTPUT||PA19(14).OUTPUT||PA18(14).OUTPUT||PA17(14).OUTPUT||PA16(14).OUTPUT||PA15(14).OUTPUT||PA14(14).OUTPUT||PA13(14).OUTPUT||PA12(14).OUTPUT||PA11(14).OUTPUT||PA10(14).OUTPUT||PA9(14).OUTPUT||
pa8(14).output||pa7(14).output||pa6(14).output||pa5(14).output||pa4(14).output||pa3(14).output||pa2(14).output||pa1(14).output)||rpad(nvl(pa81(14).output||pa82(14).output||pa83(14).output||pa84(14).output,' '),4,' ')||'| '||rpad(pa_stet(14).output,6,' ')||'           ' );

fv_ta_obj(4)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(2).output,1,71),71,' ')||'        '||lpad(pa_stet(13).output,6,' ')||' |'||(
pa80(13).output||pa79(13).output||pa78(13).output||pa77(13).output||pa76(13).output||pa75(13).output||pa74(13).output||pa73(13).output||pa72(13).output||pa71(13).output||pa70(13).output||pa69(13).output||pa68(13).output||pa67(13).output||pa66(13).output||pa65(13).output||pa64(13).output||pa63(13).output||
pa62(13).output||pa61(13).output||pa60(13).output||pa59(13).output||pa58(13).output||pa57(13).output||pa56(13).output||pa55(13).output||pa54(13).output||pa53(13).output||pa52(13).output||pa51(13).output||pa50(13).output||pa49(13).output||pa48(13).output||pa47(13).output||pa46(13).output||pa45(13).output||
pa44(13).output||pa43(13).output||pa42(13).output||pa41(13).output||pa40(13).output||pa39(13).output||pa38(13).output||pa37(13).output||pa36(13).output||pa35(13).output||pa34(13).output||pa33(13).output||pa32(13).output||pa31(13).output||pa30(13).output||pa29(13).output||pa28(13).output||pa27(13).output||
PA26(13).OUTPUT||PA25(13).OUTPUT||PA24(13).OUTPUT||PA23(13).OUTPUT||PA22(13).OUTPUT||PA21(13).OUTPUT||PA20(13).OUTPUT||PA19(13).OUTPUT||PA18(13).OUTPUT||PA17(13).OUTPUT||PA16(13).OUTPUT|| PA15(13).OUTPUT||PA14(13).OUTPUT||PA13(13).OUTPUT||PA12(13).OUTPUT||PA11(13).OUTPUT||PA10(13).OUTPUT||PA9(13).OUTPUT||
pa8(13).output||pa7(13).output||pa6(13).output||pa5(13).output||pa4(13).output||pa3(13).output||pa2(13).output||pa1(13).output)||rpad(nvl(pa81(13).output||pa82(13).output||pa83(13).output||pa84(13).output,' '),4,' ')||'| '||rpad(pa_stet(13).output,6,' ')||'           ' );

fv_ta_obj(5)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(3).output,1,71),71,' ')||'        '||lpad(pa_stet(12).output,6,' ')||' |'||(
pa80(12).output||pa79(12).output||pa78(12).output||pa77(12).output||pa76(12).output||pa75(12).output||pa74(12).output||pa73(12).output||pa72(12).output||pa71(12).output||pa70(12).output||pa69(12).output||pa68(12).output||pa67(12).output||pa66(12).output||pa65(12).output||pa64(12).output||pa63(12).output||
pa62(12).output||pa61(12).output||pa60(12).output||pa59(12).output||pa58(12).output||pa57(12).output||pa56(12).output||pa55(12).output||pa54(12).output||pa53(12).output||pa52(12).output||pa51(12).output||pa50(12).output||pa49(12).output||pa48(12).output||pa47(12).output||pa46(12).output||pa45(12).output||
pa44(12).output||pa43(12).output||pa42(12).output||pa41(12).output||pa40(12).output||pa39(12).output||pa38(12).output||pa37(12).output||pa36(12).output||pa35(12).output||pa34(12).output||pa33(12).output||pa32(12).output||pa31(12).output||pa30(12).output||pa29(12).output||pa28(12).output||pa27(12).output||
PA26(12).OUTPUT||PA25(12).OUTPUT||PA24(12).OUTPUT||PA23(12).OUTPUT||PA22(12).OUTPUT||PA21(12).OUTPUT||PA20(12).OUTPUT||PA19(12).OUTPUT||PA18(12).OUTPUT||PA17(12).OUTPUT||PA16(12).OUTPUT||PA15(12).OUTPUT||PA14(12).OUTPUT||PA13(12).OUTPUT||PA12(12).OUTPUT||PA11(12).OUTPUT||PA10(12).OUTPUT||PA9(12).OUTPUT||
PA8(12).OUTPUT||PA7(12).OUTPUT||PA6(12).OUTPUT||PA5(12).OUTPUT||PA4(12).OUTPUT||PA3(12).OUTPUT||PA2(12).OUTPUT||PA1(12).OUTPUT)||RPAD(NVL(PA81(12).OUTPUT||PA82(12).OUTPUT||PA83(12).OUTPUT||PA84(12).OUTPUT,' '),4,' ')||'| '||RPAD(PA_STET(12).OUTPUT,6,' ')||'           ' );

fv_ta_obj(6)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(4).output,1,71),71,' ')||'        '||lpad(pa_stet(11).output,6,' ')||' |'||(
pa80(11).output||pa79(11).output||pa78(11).output||pa77(11).output||pa76(11).output||pa75(11).output||pa74(11).output||pa73(11).output||pa72(11).output||pa71(11).output||pa70(11).output||pa69(11).output||pa68(11).output||pa67(11).output||pa66(11).output||pa65(11).output||pa64(11).output||pa63(11).output||
pa62(11).output||pa61(11).output||pa60(11).output||pa59(11).output||pa58(11).output||pa57(11).output||pa56(11).output||pa55(11).output||pa54(11).output||pa53(11).output||pa52(11).output||pa51(11).output||pa50(11).output||pa49(11).output||pa48(11).output||pa47(11).output||pa46(11).output||pa45(11).output||
pa44(11).output||pa43(11).output||pa42(11).output||pa41(11).output||pa40(11).output||pa39(11).output||pa38(11).output||pa37(11).output||pa36(11).output||pa35(11).output||pa34(11).output||pa33(11).output||pa32(11).output||pa31(11).output||pa30(11).output||pa29(11).output||pa28(11).output||pa27(11).output||
PA26(11).OUTPUT||PA25(11).OUTPUT||PA24(11).OUTPUT||PA23(11).OUTPUT||PA22(11).OUTPUT||PA21(11).OUTPUT||PA20(11).OUTPUT||PA19(11).OUTPUT||PA18(11).OUTPUT||PA17(11).OUTPUT||PA16(11).OUTPUT||PA15(11).OUTPUT||PA14(11).OUTPUT||PA13(11).OUTPUT||PA12(11).OUTPUT||PA11(11).OUTPUT||PA10(11).OUTPUT||PA9(11).OUTPUT||
pa8(11).output||pa7(11).output||pa6(11).output||pa5(11).output||pa4(11).output||pa3(11).output||pa2(11).output||pa1(11).output)||rpad(nvl(pa81(11).output||pa82(11).output||pa83(11).output||pa84(11).output,' '),4,' ')||'| '||rpad(pa_stet(11).output,6,' ')||'           ' );

fv_ta_obj(7)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(5).output,1,71),71,' ')||'        '||lpad(pa_stet(10).output,6,' ')||' |'||(
pa80(10).output||pa79(10).output||pa78(10).output||pa77(10).output||pa76(10).output||pa75(10).output||pa74(10).output||pa73(10).output||pa72(10).output||pa71(10).output||pa70(10).output||pa69(10).output||pa68(10).output||pa67(10).output||pa66(10).output||pa65(10).output||pa64(10).output||pa63(10).output||
pa62(10).output||pa61(10).output||pa60(10).output||pa59(10).output||pa58(10).output||pa57(10).output||pa56(10).output||pa55(10).output||pa54(10).output||pa53(10).output||pa52(10).output||pa51(10).output||pa50(10).output||pa49(10).output||pa48(10).output||pa47(10).output||pa46(10).output||pa45(10).output||
pa44(10).output||pa43(10).output||pa42(10).output||pa41(10).output||pa40(10).output||pa39(10).output||pa38(10).output||pa37(10).output||pa36(10).output||pa35(10).output||pa34(10).output||pa33(10).output||pa32(10).output||pa31(10).output||pa30(10).output||pa29(10).output||pa28(10).output||pa27(10).output||
pa26(10).output||pa25(10).output||pa24(10).output||pa23(10).output||pa22(10).output||pa21(10).output||pa20(10).output||pa19(10).output||pa18(10).output||pa17(10).output||pa16(10).output||pa15(10).output||pa14(10).output||pa13(10).output||pa12(10).output||pa11(10).output||pa10(10).output||pa9(10).output||
pa8(10).output||pa7(10).output||pa6(10).output||pa5(10).output||pa4(10).output||pa3(10).output||pa2(10).output||pa1(10).output)||rpad(nvl(pa81(10).output||pa82(10).output||pa83(10).output||pa84(10).output,' '),4,' ')||'| '||rpad(pa_stet(10).output,6,' ')||'           ' );

fv_ta_obj(8)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(6).output,1,77),77,' ')||'  '||lpad(pa_stet(9).output,6,' ')||' |'||(
pa80(9).output||pa79(9).output||pa78(9).output||pa77(9).output||pa76(9).output||pa75(9).output||pa74(9).output||pa73(9).output||pa72(9).output||pa71(9).output||pa70(9).output||pa69(9).output||pa68(9).output||pa67(9).output||pa66(9).output||pa65(9).output||pa64(9).output||pa63(9).output||pa62(9).output||
pa61(9).output||pa60(9).output||pa59(9).output||pa58(9).output||pa57(9).output||pa56(9).output||pa55(9).output||pa54(9).output||pa53(9).output||pa52(9).output||pa51(9).output||pa50(9).output||pa49(9).output||pa48(9).output||pa47(9).output||pa46(9).output||pa45(9).output||pa44(9).output||pa43(9).output||
pa42(9).output||pa41(9).output||pa40(9).output||pa39(9).output||pa38(9).output||pa37(9).output||pa36(9).output||pa35(9).output||pa34(9).output||pa33(9).output||pa32(9).output||pa31(9).output||pa30(9).output||pa29(9).output||pa28(9).output||pa27(9).output||pa26(9).output||pa25(9).output||pa24(9).output||
PA23(9).OUTPUT||PA22(9).OUTPUT||PA21(9).OUTPUT||PA20(9).OUTPUT||PA19(9).OUTPUT||PA18(9).OUTPUT||PA17(9).OUTPUT||PA16(9).OUTPUT|| PA15(9).OUTPUT||PA14(9).OUTPUT||PA13(9).OUTPUT||PA12(9).OUTPUT||PA11(9).OUTPUT||PA10(9).OUTPUT||PA9(9).OUTPUT||PA8(9).OUTPUT||PA7(9).OUTPUT||PA6(9).OUTPUT||PA5(9).OUTPUT||
PA4(9).OUTPUT||PA3(9).OUTPUT||PA2(9).OUTPUT||PA1(9).OUTPUT)||RPAD(NVL(PA81(9).OUTPUT||PA82(9).OUTPUT||PA83(9).OUTPUT||PA84(9).OUTPUT,' '),4,' ')||'| '||RPAD(PA_STET(9).OUTPUT,6,' ')||'           ' );

fv_ta_obj(9)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(7).output,1,77),77,' ')||'  '||lpad(pa_stet(8).output,6,' ') ||' |'||(
pa80(8).output||pa79(8).output||pa78(8).output||pa77(8).output||pa76(8).output||pa75(8).output||pa74(8).output||pa73(8).output||pa72(8).output||pa71(8).output||pa70(8).output||pa69(8).output||pa68(8).output||pa67(8).output||pa66(8).output||pa65(8).output||pa64(8).output||pa63(8).output||pa62(8).output||
pa61(8).output||pa60(8).output||pa59(8).output||pa58(8).output||pa57(8).output||pa56(8).output||pa55(8).output||pa54(8).output||pa53(8).output||pa52(8).output||pa51(8).output||pa50(8).output||pa49(8).output||pa48(8).output||pa47(8).output||pa46(8).output||pa45(8).output||pa44(8).output||pa43(8).output||
pa42(8).output||pa41(8).output||pa40(8).output||pa39(8).output||pa38(8).output||pa37(8).output||pa36(8).output||pa35(8).output||pa34(8).output||pa33(8).output||pa32(8).output||pa31(8).output||pa30(8).output||pa29(8).output||pa28(8).output||pa27(8).output||pa26(8).output||pa25(8).output||pa24(8).output||
PA23(8).OUTPUT||PA22(8).OUTPUT||PA21(8).OUTPUT||PA20(8).OUTPUT||PA19(8).OUTPUT||PA18(8).OUTPUT||PA17(8).OUTPUT||PA16(8).OUTPUT||PA15(8).OUTPUT||PA14(8).OUTPUT||PA13(8).OUTPUT||PA12(8).OUTPUT||PA11(8).OUTPUT||PA10(8).OUTPUT||PA9(8).OUTPUT||PA8(8).OUTPUT||PA7(8).OUTPUT||PA6(8).OUTPUT||PA5(8).OUTPUT||
PA4(8).OUTPUT||PA3(8).OUTPUT||PA2(8).OUTPUT||PA1(8).OUTPUT)||RPAD(NVL(PA81(8).OUTPUT||PA82(8).OUTPUT||PA83(8).OUTPUT||PA84(8).OUTPUT,' '),4,' ')||'| '||RPAD(PA_STET(8).OUTPUT,6,' ')||'           ' );

fv_ta_obj(10)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(8).output,1,77),77,' ')||'  '||lpad(pa_stet(7).output,6,' ') ||' |'||(
pa80(7).output||pa79(7).output||pa78(7).output||pa77(7).output||pa76(7).output||pa75(7).output||pa74(7).output||pa73(7).output||pa72(7).output||pa71(7).output||pa70(7).output||pa69(7).output||pa68(7).output||pa67(7).output||pa66(7).output||pa65(7).output||pa64(7).output||pa63(7).output||pa62(7).output||
pa61(7).output||pa60(7).output||pa59(7).output||pa58(7).output||pa57(7).output||pa56(7).output||pa55(7).output||pa54(7).output||pa53(7).output||pa52(7).output||pa51(7).output||pa50(7).output||pa49(7).output||pa48(7).output||pa47(7).output||pa46(7).output||pa45(7).output||pa44(7).output||pa43(7).output||
pa42(7).output||pa41(7).output||pa40(7).output||pa39(7).output||pa38(7).output||pa37(7).output||pa36(7).output||pa35(7).output||pa34(7).output||pa33(7).output||pa32(7).output||pa31(7).output||pa30(7).output||pa29(7).output||pa28(7).output||pa27(7).output||pa26(7).output||pa25(7).output||pa24(7).output||
pa23(7).output||pa22(7).output||pa21(7).output||pa20(7).output||pa19(7).output||pa18(7).output||pa17(7).output||pa16(7).output||pa15(7).output||pa14(7).output||pa13(7).output||pa12(7).output||pa11(7).output||pa10(7).output||pa9(7).output||pa8(7).output||pa7(7).output||pa6(7).output||pa5(7).output||
pa4(7).output||pa3(7).output||pa2(7).output||pa1(7).output)||rpad(nvl(pa81(7).output||pa82(7).output||pa83(7).output||pa84(7).output,' '),4,' ')||'| '||rpad(pa_stet(7).output,6,' ')||'           ' );

fv_ta_obj(11) :=ty_obj(rpad(substr(pv_tmp_gcinfo(9).output,1,77),77,' ')||'  '||lpad(pa_stet(6).output,6,' ') ||' |'||(
pa80(6).output||pa79(6).output||pa78(6).output||pa77(6).output||pa76(6).output||pa75(6).output||pa74(6).output||pa73(6).output||pa72(6).output||pa71(6).output||pa70(6).output||pa69(6).output||pa68(6).output||pa67(6).output||pa66(6).output||pa65(6).output||pa64(6).output||pa63(6).output||pa62(6).output||
pa61(6).output||pa60(6).output||pa59(6).output||pa58(6).output||pa57(6).output||pa56(6).output||pa55(6).output||pa54(6).output||pa53(6).output||pa52(6).output||pa51(6).output||pa50(6).output||pa49(6).output||pa48(6).output||pa47(6).output||pa46(6).output||pa45(6).output||pa44(6).output||pa43(6).output||
pa42(6).output||pa41(6).output||pa40(6).output||pa39(6).output||pa38(6).output||pa37(6).output||pa36(6).output||pa35(6).output||pa34(6).output||pa33(6).output||pa32(6).output||pa31(6).output||pa30(6).output||pa29(6).output||pa28(6).output||pa27(6).output||pa26(6).output||pa25(6).output||pa24(6).output||
pa23(6).output||pa22(6).output||pa21(6).output||pa20(6).output||pa19(6).output||pa18(6).output||pa17(6).output||pa16(6).output||pa15(6).output||pa14(6).output||pa13(6).output||pa12(6).output||pa11(6).output||pa10(6).output||pa9(6).output||pa8(6).output||pa7(6).output||pa6(6).output||pa5(6).output||
pa4(6).output||pa3(6).output||pa2(6).output||pa1(6).output)||rpad(nvl(pa81(6).output||pa82(6).output||pa83(6).output||pa84(6).output,' '),4,' ')||'| '||rpad(pa_stet(6).output,6,' ')||'           ' );

fv_ta_obj(12) :=ty_obj(rpad(substr(pv_tmp_gcinfo(10).output,1,77),77,' ')||'  '||lpad(pa_stet(5).output,6,' ') ||' |'||(
pa80(5).output||pa79(5).output||pa78(5).output||pa77(5).output||pa76(5).output||pa75(5).output||pa74(5).output||pa73(5).output||pa72(5).output||pa71(5).output||pa70(5).output||pa69(5).output||pa68(5).output||pa67(5).output||pa66(5).output||pa65(5).output||pa64(5).output||pa63(5).output||pa62(5).output||
pa61(5).output||pa60(5).output||pa59(5).output||pa58(5).output||pa57(5).output||pa56(5).output||pa55(5).output||pa54(5).output||pa53(5).output||pa52(5).output||pa51(5).output||pa50(5).output||pa49(5).output||pa48(5).output||pa47(5).output||pa46(5).output||pa45(5).output||pa44(5).output||pa43(5).output||
pa42(5).output||pa41(5).output||pa40(5).output||pa39(5).output||pa38(5).output||pa37(5).output||pa36(5).output||pa35(5).output||pa34(5).output||pa33(5).output||pa32(5).output||pa31(5).output||pa30(5).output||pa29(5).output||pa28(5).output||pa27(5).output||pa26(5).output||pa25(5).output||pa24(5).output||
pa23(5).output||pa22(5).output||pa21(5).output||pa20(5).output||pa19(5).output||pa18(5).output||pa17(5).output||pa16(5).output||pa15(5).output||pa14(5).output||pa13(5).output||pa12(5).output||pa11(5).output||pa10(5).output||pa9(5).output||pa8(5).output||pa7(5).output||pa6(5).output||pa5(5).output||
pa4(5).output||pa3(5).output||pa2(5).output||pa1(5).output)||rpad(nvl(pa81(5).output||pa82(5).output||pa83(5).output||pa84(5).output,' '),4,' ')||'| '||rpad(pa_stet(5).output,6,' ')||'           ' );

fv_ta_obj(13) :=ty_obj(rpad(substr(pv_tmp_gcinfo(11).output,1,77),77,' ')||'  '||lpad(pa_stet(4).output,6,' ') ||' |'||(
pa80(4).output||pa79(4).output||pa78(4).output||pa77(4).output||pa76(4).output||pa75(4).output||pa74(4).output||pa73(4).output||pa72(4).output||pa71(4).output||pa70(4).output||pa69(4).output||pa68(4).output||pa67(4).output||pa66(4).output||pa65(4).output||pa64(4).output||pa63(4).output||pa62(4).output||
pa61(4).output||pa60(4).output||pa59(4).output||pa58(4).output||pa57(4).output||pa56(4).output||pa55(4).output||pa54(4).output||pa53(4).output||pa52(4).output||pa51(4).output||pa50(4).output||pa49(4).output||pa48(4).output||pa47(4).output||pa46(4).output||pa45(4).output||pa44(4).output||pa43(4).output||
pa42(4).output||pa41(4).output||pa40(4).output||pa39(4).output||pa38(4).output||pa37(4).output||pa36(4).output||pa35(4).output||pa34(4).output||pa33(4).output||pa32(4).output||pa31(4).output||pa30(4).output||pa29(4).output||pa28(4).output||pa27(4).output||pa26(4).output||pa25(4).output||pa24(4).output||
PA23(4).OUTPUT||PA22(4).OUTPUT||PA21(4).OUTPUT||PA20(4).OUTPUT||PA19(4).OUTPUT||PA18(4).OUTPUT||PA17(4).OUTPUT||PA16(4).OUTPUT||PA15(4).OUTPUT||PA14(4).OUTPUT||PA13(4).OUTPUT||PA12(4).OUTPUT||PA11(4).OUTPUT||PA10(4).OUTPUT||PA9(4).OUTPUT||PA8(4).OUTPUT||PA7(4).OUTPUT||PA6(4).OUTPUT||PA5(4).OUTPUT||
pa4(4).output||pa3(4).output||pa2(4).output||pa1(4).output)||rpad(nvl(pa81(4).output||pa82(4).output||pa83(4).output||pa84(4).output,' '),4,' ')||'| '||rpad(pa_stet(4).output,6,' ')||'           ' );

fv_ta_obj(14) :=ty_obj(rpad(substr(pv_tmp_gcinfo(12).output,1,55),55,' ')||' ALL OTHER EVENTS : '||pv_oth_dig ||'   '||lpad(pa_stet(3).output,6,' ') ||' |'||(
pa80(3).output||pa79(3).output||pa78(3).output||pa77(3).output||pa76(3).output||pa75(3).output||pa74(3).output||pa73(3).output||pa72(3).output||pa71(3).output||pa70(3).output||pa69(3).output||pa68(3).output||pa67(3).output||pa66(3).output||pa65(3).output||pa64(3).output||pa63(3).output||pa62(3).output||
pa61(3).output||pa60(3).output||pa59(3).output||pa58(3).output||pa57(3).output||pa56(3).output||pa55(3).output||pa54(3).output||pa53(3).output||pa52(3).output||pa51(3).output||pa50(3).output||pa49(3).output||pa48(3).output||pa47(3).output||pa46(3).output||pa45(3).output||pa44(3).output||pa43(3).output||
pa42(3).output||pa41(3).output||pa40(3).output||pa39(3).output||pa38(3).output||pa37(3).output||pa36(3).output||pa35(3).output||pa34(3).output||pa33(3).output||pa32(3).output||pa31(3).output||pa30(3).output||pa29(3).output||pa28(3).output||pa27(3).output||pa26(3).output||pa25(3).output||pa24(3).output||
PA23(3).OUTPUT||PA22(3).OUTPUT||PA21(3).OUTPUT||PA20(3).OUTPUT||PA19(3).OUTPUT||PA18(3).OUTPUT||PA17(3).OUTPUT||PA16(3).OUTPUT||PA15(3).OUTPUT||PA14(3).OUTPUT||PA13(3).OUTPUT||PA12(3).OUTPUT||PA11(3).OUTPUT||PA10(3).OUTPUT||PA9(3).OUTPUT||PA8(3).OUTPUT||PA7(3).OUTPUT||PA6(3).OUTPUT||PA5(3).OUTPUT||
pa4(3).output||pa3(3).output||pa2(3).output||pa1(3).output)||rpad(nvl(pa81(3).output||pa82(3).output||pa83(3).output||pa84(3).output,' '),4,' ')||'| '||rpad(pa_stet(3).output,6,' ')||'           ');

fv_ta_obj(15) :=ty_obj(rpad(substr(pv_tmp_gcinfo(13).output,1,55),55,' ')||'          CLUSTER : '||pv_clu_dig ||'   '||lpad(pa_stet(2).output,6,' ') ||' |'||(
pa80(2).output||pa79(2).output||pa78(2).output||pa77(2).output||pa76(2).output||pa75(2).output||pa74(2).output||pa73(2).output||pa72(2).output||pa71(2).output||pa70(2).output||pa69(2).output||pa68(2).output||pa67(2).output||pa66(2).output||pa65(2).output||pa64(2).output||pa63(2).output||pa62(2).output||
PA61(2).OUTPUT||PA60(2).OUTPUT||PA59(2).OUTPUT||PA58(2).OUTPUT||PA57(2).OUTPUT||PA56(2).OUTPUT||PA55(2).OUTPUT||PA54(2).OUTPUT||PA53(2).OUTPUT||PA52(2).OUTPUT||PA51(2).OUTPUT||PA50(2).OUTPUT||PA49(2).OUTPUT||PA48(2).OUTPUT||PA47(2).OUTPUT||PA46(2).OUTPUT||PA45(2).OUTPUT||PA44(2).OUTPUT||PA43(2).OUTPUT||
pa42(2).output||pa41(2).output||pa40(2).output||pa39(2).output||pa38(2).output||pa37(2).output||pa36(2).output||pa35(2).output||pa34(2).output||pa33(2).output||pa32(2).output||pa31(2).output||pa30(2).output||pa29(2).output||pa28(2).output||pa27(2).output||pa26(2).output||pa25(2).output||pa24(2).output||
PA23(2).OUTPUT||PA22(2).OUTPUT||PA21(2).OUTPUT||PA20(2).OUTPUT||PA19(2).OUTPUT||PA18(2).OUTPUT||PA17(2).OUTPUT||PA16(2).OUTPUT||PA15(2).OUTPUT||PA14(2).OUTPUT||PA13(2).OUTPUT||PA12(2).OUTPUT||PA11(2).OUTPUT||PA10(2).OUTPUT||PA9(2).OUTPUT||PA8(2).OUTPUT||PA7(2).OUTPUT||PA6(2).OUTPUT||PA5(2).OUTPUT||
pa4(2).output||pa3(2).output||pa2(2).output||pa1(2).output)||rpad(nvl(pa81(2).output||pa82(2).output||pa83(2).output||pa84(2).output,' '),4,' ')||'| '||rpad(pa_stet(2).output,6,' ')||'           ' );

fv_ta_obj(16) :=ty_obj(rpad(substr(pv_tmp_gcinfo(14).output,1,55),55,' ')||'               IO : '||pv_io_dig||'   '||lpad(pa_stet(1).output,6,' ') ||' |'||(
pa80(1).output||pa79(1).output||pa78(1).output||pa77(1).output||pa76(1).output||pa75(1).output||pa74(1).output||pa73(1).output||pa72(1).output||pa71(1).output||pa70(1).output||pa69(1).output||pa68(1).output||pa67(1).output||pa66(1).output||pa65(1).output||pa64(1).output||pa63(1).output||pa62(1).output||
pa61(1).output||pa60(1).output||pa59(1).output||pa58(1).output||pa57(1).output||pa56(1).output||pa55(1).output||pa54(1).output||pa53(1).output||pa52(1).output||pa51(1).output||pa50(1).output||pa49(1).output||pa48(1).output||pa47(1).output||pa46(1).output||pa45(1).output||pa44(1).output||pa43(1).output||
pa42(1).output||pa41(1).output||pa40(1).output||pa39(1).output||pa38(1).output||pa37(1).output||pa36(1).output||pa35(1).output||pa34(1).output||pa33(1).output||pa32(1).output||pa31(1).output||pa30(1).output||pa29(1).output||pa28(1).output||pa27(1).output||pa26(1).output||pa25(1).output||pa24(1).output||
PA23(1).OUTPUT||PA22(1).OUTPUT||PA21(1).OUTPUT||PA20(1).OUTPUT||PA19(1).OUTPUT||PA18(1).OUTPUT||PA17(1).OUTPUT||PA16(1).OUTPUT||PA15(1).OUTPUT||PA14(1).OUTPUT||PA13(1).OUTPUT||PA12(1).OUTPUT||PA11(1).OUTPUT||PA10(1).OUTPUT||PA9(1).OUTPUT||PA8(1).OUTPUT||PA7(1).OUTPUT||PA6(1).OUTPUT||PA5(1).OUTPUT||
PA4(1).OUTPUT||PA3(1).OUTPUT||PA2(1).OUTPUT||PA1(1).OUTPUT)||RPAD(NVL(PA81(1).OUTPUT||PA82(1).OUTPUT||PA83(1).OUTPUT||PA84(1).OUTPUT,' '),4,' ')||'| '||RPAD(PA_STET(1).OUTPUT,6,' ')||'           ' );

FV_TA_OBJ(17) :=TY_OBJ(RPAD(' ',69,' ')||'CPU : '||PV_CPU_DIG ||'   '||LPAD(0,6,' ')||' +'||RPAD('-',84,'-')||'+ 0');
FV_TA_OBJ(18) :=TY_OBJ(RPAD(PV_SYSMETRIC_STRING1,88,' ')||'^'||' '||TO_CHAR(SYSDATE-(1/24/60/(60/(P_SAMPLE*80))),'hh24:mi:ss')||LPAD(' ',21,' ')||TO_CHAR(SYSDATE-(1/24/60/(60/(P_SAMPLE*40))),'hh24:mi:ss')||' '||'^'||LPAD(' ',29,' ')||TO_CHAR(SYSDATE,'hh24:mi:ss')||' '||'^');
FV_TA_OBJ(19) :=TY_OBJ(RPAD(PV_SYSMETRIC_STRING2,170,' '));
FV_TA_OBJ(20) :=TY_OBJ(RPAD(PV_SYSMETRIC_STRING3,170,' '));

return fv_ta_obj;
exception
when others then
RAISE_APPLICATION_ERROR(-20001,'GACTSESSRET : '||SQLERRM );
end;
-------------------
------##################
-- gsqlm : ---  building dataset from gv\$sql_monitor for all running queries.
--- print info for pv_top_sql
------##################
function gsqlm  return ta_obj
as
fv_Ta_obj     ta_obj  := ta_obj();
v_rcnt        int := 0 ;
fv_sql        varchar2(500) := q'[ select ty_gsqlm(inst_id,sql_id,substr(sql_text,1,100),elapsed_time,cpu_time,concurrency_wait_time, cluster_wait_Time,user_io_wait_time,physical_read_bytes,px_server#) from gv\$sql_monitor where status = 'EXECUTING' and elapsed_time > 0 ]';
----##
function  f_convert_datetime(fvs number ) return varchar2
as
v_result    varchar2(20) ;
begin
with
   hrs as (select secs, trunc(secs/60/60) as h from (select fvs secs from dual))
 , mins as (select secs, h, trunc((secs - h * 60 * 60) / 60) as m from hrs)
select lpad(h,2,'0') || ':' || lpad(m,2,'0') || ':' || lpad((secs - (h * 60 * 60) - (m * 60) ),2,'0') into v_result
  from  mins;
  v_result := replace(v_result,'::') ;
return v_result;
end;
---##
begin
execute immediate fv_sql bulk collect into pv_only_gsqlm;
fv_ta_obj.extend;fv_ta_obj(fv_ta_obj.count) := ty_obj( ' ');
fv_ta_obj.extend;fv_ta_obj(fv_ta_obj.count) := ty_obj( '+--SqlID--------+--SqlText---' || lpad('-',73,'-') || '+-LongstDur-+-InstCnt-+-Cnt-+--CPU%--+--CONC%--+--CLUS%--+-IO%-+-PhyReadMb+');
for i in (select (select round(max(elapsed_time)/1000000) from table(pv_only_gsqlm) gsq1 where gsq1.sql_id = gsm.sql_id) maxduration,
                 (select count(distinct inst_id) from table(pv_only_gash)  sq1 where sq1.sql_id = gsm.sql_id) acrossins, sql_id,
                 (select SUBSTR(SQL_TEXT,1,87) FROM TABLE(PV_ONLY_GASH) SQ2 WHERE SQ2.SQL_ID = GSM.SQL_ID AND ROWNUM = 1) SQL_TEXT,
                 (select lpad(nvl(round(sum(cpu_time)/ nvl(sum(elapsed_time),1) *100,1),0),6,' ') || ' | ' || lpad(nvl(round(sum(concurrency_Wait_Time)/nvl(sum(elapsed_time),1)*100,1),0),6,' ') || ' | ' || lpad(nvl(round(sum(cluster_Wait_Time)/nvl(sum(elapsed_time),1)*100,1),0),6,' ') || ' | ' || lpad(nvl(round(sum(user_io_wait_time)/nvl(sum(elapsed_time),1)*100,1),0),4,'  ') || ' | ' || lpad(nvl(round(sum(physical_read_bytes)/1048576),0),10,'  ') || ' | ' from table(pv_only_gsqlm) sql3 where sql3.sql_id = gsm.sql_id) db_time,
                 (select count( distinct inst_id || sid) from table(pv_only_gash) sq4 where sq4.sql_id = gsm.sql_id ) exccount from (select distinct output sql_id from table(pv_top_sql)) gsm)
          loop
 v_rcnt := 1;
 fv_ta_obj.extend;
fv_ta_obj(fv_ta_obj.count) := ty_obj('| ' || i.sql_id || ' | ' || rpad(nvl(i.sql_text,' '),83,' ') || ' | ' || lpad(nvl(f_convert_datetime(i.maxduration),' '),9,' ') || ' |    ' || rpad(i.acrossins,4,'  ') || '  |  ' || lpad(i.exccount,2,'  ') || ' | ' || i.db_time );
fv_ta_obj.extend;fv_ta_obj(fv_ta_obj.count) := ty_obj('+---------------+' || lpad('-',85,'-') || '+-----------+---------+-----+--------+---------+---------+-----+----------+');
        end loop;
           if v_rcnt = 0 then
            fv_ta_obj.extend;
			fv_ta_obj(fv_ta_obj.count) := ty_obj( '+---------------+' || lpad('-',85,'-') || '+-----------+---------+-----+--------+---------+---------+-----+----------+');
           end if;
return  fv_ta_obj;
exception
when others then
raise_application_Error(-20001,'GSQLM : ' || sqlerrm);
end;
-------------------/
------##################
-- gtop : pipe lined function, which calls all the sections
------##################
FUNCTION gtop(PV_ARR_SIZE     INT DEFAULT 50 ,
              PV_SAMPLE       INT DEFAULT 6,
              PV_COLORS       INT DEFAULT 1,
              PV_SYSMETRC_ID1 INT DEFAULT NULL,
              PV_SYSMETRC_ID2 INT DEFAULT NULL,
              PV_SYSMETRC_ID3 INT DEFAULT NULL
              ) RETURN ta_obj pipelined
is
v_tot_rec       int := 0 ;
BEGIN
p_sample  := pv_Sample;
---############################
--If Non-Colored Graph Required
---############################
IF PV_COLORS = 0 THEN     -- No color
PV_CPU_DIG     :=  '#';
pv_io_dig      :=  'O';
PV_CLU_DIG     :=  '+';
PV_OTH_DIG     :=  '*';
ELSIF PV_COLORS = 2 THEN
PV_CPU_DIG     :=  CHR(27)||'[32m'||'#'||CHR(27)||'[0m';  -- Colored Digit
PV_IO_DIG      :=  CHR(27)||'[34m'||'O'||CHR(27)||'[0m';
PV_CLU_DIG     :=  CHR(27)||'[33m'||'+'||CHR(27)||'[0m';
PV_OTH_DIG     :=  CHR(27)||'[31m'||'*'||CHR(27)||'[0m';
ELSIF PV_COLORS = 1 THEN                                  -- Background Colored
PV_CPU_DIG     :=  CHR(27)||'[42m'||' '||CHR(27)||'[0m';
PV_IO_DIG      :=  CHR(27)||'[44m'||' '||CHR(27)||'[0m';
PV_CLU_DIG     :=  CHR(27)||'[47m'||' '||CHR(27)||'[0m';
PV_OTH_DIG     :=  CHR(27)||'[41m'||' '||CHR(27)||'[0m';
END IF;
      --- Printing Banner..
        begin
        pipe row ( ty_obj('########################################')); v_tot_rec := v_tot_Rec + 1;
        PIPE ROW ( TY_OBJ('Taking first sample .......             ')); V_TOT_REC := V_TOT_REC + 1;
        PIPE ROW ( TY_OBJ('Author  : Ribas                         ')); V_TOT_REC := V_TOT_REC + 1;
        PIPE ROW ( TY_OBJ('Version : V2.1                          ')); V_TOT_REC := V_TOT_REC + 1;
        PIPE ROW ( TY_OBJ('########################################')); V_TOT_REC := V_TOT_REC + 1;
                pipe row ( ty_obj('')); V_TOT_REC := V_TOT_REC + 1;
                PIPE ROW ( TY_OBJ('')); V_TOT_REC := V_TOT_REC + 1;
                PIPE ROW ( TY_OBJ('Please use below sql to see help !!')); V_TOT_REC := V_TOT_REC + 1;
                PIPE ROW ( TY_OBJ('-- select * from table(jss.help()); ')); V_TOT_REC := V_TOT_REC + 1;
                PIPE ROW ( TY_OBJ('')); V_TOT_REC := V_TOT_REC + 1;
                PIPE ROW ( TY_OBJ('')); V_TOT_REC := V_TOT_REC + 1;
           IF V_TOT_REC <= PV_ARR_SIZE THEN
                     for i in 1..(pv_arr_size-v_tot_rec) loop
                     pipe row ( ty_obj(' ')); v_tot_rec := v_tot_Rec + 1;
                    end loop;
           end if;
        initactarr;                 -- calling initactarr to extend all the arrays
        pv_first_ginst := ginsteff; -- getting first sample for ginsteff
        dbms_lock.sleep(pv_sample); -- sleep based on passed parameter, default is 6 seconds
        v_tot_rec := 0;
        end;
loop
--#######################
-- Printing Instance Eff.
--#######################
------------------ -- Building output for Inst Eff.
pv_last_ginst :=  ginsteff;  -- Taking second sample for Inst Eff. data
pv_tmp_obj    :=  ginstbuilddata(pv_first_ginst,pv_last_ginst);  -- getting data formatted
for i in 1..pv_tmp_obj.count loop   pipe row( ty_obj( pv_tmp_obj(i).output )); v_tot_rec := v_tot_rec + 1; end loop;  pipe row ( ty_obj(' ')); v_tot_rec := v_tot_rec + 1; -- printing
pv_tmp_obj.delete;  -- deleting temp obj
------------------
--#########################
-- Printing TOP SQLs,Waits
--#########################
------------------
pv_only_gash  := gash(pv_st_sample,pv_et_sample); -- building dataset from global active session history
pv_tmp_obj    := gashbuilddata (pv_only_gash); -- getting dataset formatted
for i in 1..pv_tmp_obj.count loop   pipe row( ty_obj( pv_tmp_obj(i).output )); v_tot_rec := v_tot_rec + 1; end loop;  -- printing
pv_tmp_obj.delete;  -- deleting temp obj
------------------
--#########################
-- Building Cluster/GC* data
--#########################
pv_tmp_gcinfo :=  gcinfo ; -- building dataset for Cluster waits,
--#########################
-- Printing Active Sessions
--#########################
-----------------
gset3sysmetrics(PV_SYSMETRC_ID1,PV_SYSMETRC_ID2,PV_SYSMETRC_ID3); -- Customizable Section/Sysmetric Id
gactses ;
PV_TMP_OBJ := GACTSESSRET;
FOR I IN 1..PV_TMP_OBJ.COUNT LOOP   PIPE ROW( TY_OBJ( PV_TMP_OBJ(I).OUTPUT )); V_TOT_REC := V_TOT_REC + 1; END LOOP;
--pipe row ( ty_obj(' ')); v_tot_rec := v_tot_rec + 1;
pv_tmp_obj.delete;
--------------------
--#########################
-- Printing SQL Monitor
--#########################
------------------
pv_tmp_obj := gsqlm;    -- using pv_top_sql to fill detail from sql monitor
for i in 1..pv_tmp_obj.count loop   pipe row( ty_obj( pv_tmp_obj(i).output )); v_tot_rec := v_tot_rec + 1; end loop;
pv_tmp_obj.delete;
-------------------
--#######################
-- Fill remaining Array
--#######################
        if v_tot_rec < pv_arr_size then
            for i in 1..(pv_arr_size-v_tot_rec) loop
             pipe row ( ty_obj(' '));
            end loop;
        end if;
--##############################
-- Sleep, triming all the arrays
--
--##############################
pv_first_ginst := pv_last_ginst;   -- shuffling ginst collection
dbms_lock.sleep(pv_sample);
v_tot_rec := 0;
end loop ;
RETURN ;
--exception
--when others then
--raise_application_Error(-20001,'GTOP: '||sqlerrm );
end;
---
--#############################
-- Below Section Talks About GTOP Help
FUNCTION GTOPHELP RETURN TA_OBJ PIPELINED
as
begin
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  Arguments Name In GTOP Function    '));
pipe row ( ty_obj('  ---------------   '));
pipe row ( ty_obj('  PV_ARR_SIZE       : Pass SQL Array Size (Set Sqlarray Size <Value>) '));
pipe row ( ty_obj('  PV_SAMPLE         : Time Interval In Seconds For Sample, Default=6 Seconds, Screen Refresh Time '));
pipe row ( ty_obj('  PV_COLORS         : 0=No Colors, 1=BG Colors(Default), 2=Colored Digits '));
pipe row ( ty_obj('  PV_SYSMETRC_ID1   : Pass Metric_ID column from v\$sysmetric to monitor, Default=2144 (Single Blk Read Latency) '));
pipe row ( ty_obj('  PV_SYSMETRC_ID2   : Pass Metric_ID column from v\$sysmetric to monitor, Default=2088 (Physical Read Direct)  '));
pipe row ( ty_obj('  PV_SYSMETRC_ID3   : Pass Metric_ID column from v\$sysmetric to monitor, Default=2010 (Physical Write Direct) '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj(' ## With All Defaults Values -- Sample=6 Secs , Colors=Background Color, Default 3 Sysmetrics  '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
pipe row ( ty_obj('  SET LINESIZE 5000 pagesize 0 Arraysize 50 TAB OFF '));
pipe row ( ty_obj('  select * FROM TABLE(JSS.GTOP(50)); '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj(' ## With Changed Sample Size -- Interval=3 Sec, Remaining All Defaults '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
pipe row ( ty_obj('  SET LINESIZE 5000 pagesize 0 Arraysize 50 TAB OFF '));
pipe row ( ty_obj('  select * FROM TABLE(JSS.GTOP(50,3)); '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj(' ## With Changed Sample Size and No Colors -- Interval=3 Secs, Colors=No Color, Remaining All Defaults '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
pipe row ( ty_obj('  SET LINESIZE 5000 pagesize 0 Arraysize 50 TAB OFF '));
pipe row ( ty_obj('  select * FROM TABLE(JSS.GTOP(50,3,0)); '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj(' ## With Customized Sysmetrics- 2003=User Transactions Per Sec, 2018=Logins Per Sec, 2026=>User Calls Per Sec '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
pipe row ( ty_obj('  SET LINESIZE 5000 pagesize 0 Arraysize 50 TAB OFF '));
pipe row ( ty_obj('  select * FROM TABLE(JSS.GTOP(50,pv_sysmetrc_id1=>2003,pv_sysmetrc_id2=>2018,pv_sysmetrc_id3=>2026)); '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
end;
--#############################
--########################
-- Package Begin Section
--########################
Begin
dbms_application_info.set_action('JSS.GTOP');
select VALUE  INTO PV_BLOCK_SIZE FROM V\$PARAMETER WHERE NAME = 'db_block_size' ;   -- this query will get executed once per session
select SUBSTR(VALUE,1,INSTR(VALUE,'.')-1) INTO PV_VERSION FROM V\$PARAMETER WHERE NAME = 'compatible' ;
END JSS;
/
quit;
EOF
else
sqlplus -S  '/ as sysdba' <<EOF
alter session set current_schema=system;
SET LINESIZE 5000 pagesize 0 Arraysize 51 TAB OFF
prompt ##############################################################
prompt # ACCESSING THE DATABASE DASHBOARD
prompt ##############################################################
select * from table(jss.gtop(51));
/
quit;
EOF
fi
}
#
#########################################################################################################
# VERIFY ALL SQL IDS STATEMENTS
#########################################################################################################
#
function Func_DB_091()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_091
else
  Func_DB_NON_PDB_091
fi
}
# PDB
function Func_DB_PDB_091()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 32767 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
prompt
prompt ##############################################################
prompt # Session related Queries                                    #
prompt ##############################################################
prompt # Last/Latest Running SQL                                    #
prompt ##############################################################
set pages 50000 lines 32767 timing on feedback on echo on heading on verify on colsep '|'
col username for a20
col "Last SQL" for a130
select t.inst_id
  , s.username
  , s.sid
  , s.serial#
  , t.sql_id
  , t.sql_text "Last SQL"
FROM gv\$session s, gv\$sqlarea t
WHERE s.sql_address = t.address
AND s.sql_hash_value = t.hash_value;
quit;
EOF
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- Verify the SQL ID from Statements --"
Func_DB_SQLID
}
# NON PDB
function Func_DB_NON_PDB_091()
{
sqlplus -S  '/ as sysdba' <<EOF
prompt ##############################################################
prompt # Session related Queries                                    #
prompt ##############################################################
prompt # Last/Latest Running SQL                                    #
prompt ##############################################################
set pages 50000 lines 32767 timing on colsep '|'
col username for a20
col "Last SQL" for a130
select t.inst_id
  , s.username
  , s.sid
  , s.serial#
  , t.sql_id
  , t.sql_text "Last SQL"
FROM gv\$session s, gv\$sqlarea t
WHERE s.sql_address = t.address
AND s.sql_hash_value = t.hash_value;
quit;
EOF
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- Verify the SQL ID from Statements --"
Func_DB_SQLID
}
#
#########################################################################################################
# VERIFY NLS CONFIGURATION
#########################################################################################################
#
function Func_DB_092()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_092
else
  Func_DB_NON_PDB_092
fi
}
# PDB
function Func_DB_PDB_092()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- select YOUR DATABASE [ CDB$ROOT / PDB ] --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
select SET_PDB in ${varDB_PDBS}; do
  PDB_NAME=${SET_PDB}
  break 1
done
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- YOUR DATABASE SELECTED IS: ${PDB_NAME} --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
sqlplus -S  '/ as sysdba' <<EOF
set pagesize 0 linesize 0 feedback off verify off heading off echo off timing off
alter session set container=${PDB_NAME};
prompt ##############################################################
select '# Database: ' || NAME FROM V\$CONTAINERS WHERE NAME = '${PDB_NAME}';
prompt ##############################################################
prompt
prompt ##############################################################
prompt # VERIFY NLS CONFIGURATION                                   #
prompt ##############################################################
prompt
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
COL PARAMETER FOR A30
COL DATABASE FOR A30
COL INSTANCE FOR A30
COL SESSION FOR A30
SELECT DB.PARAMETER
  , DB.VALUE "DATABASE"
  , I.VALUE "INSTANCE"
  , S.VALUE "SESSION"
FROM NLS_DATABASE_PARAMETERS DB, NLS_INSTANCE_PARAMETERS I, NLS_SESSION_PARAMETERS S
WHERE DB.PARAMETER=I.PARAMETER(+) AND DB.PARAMETER=S.PARAMETER(+)
ORDER BY 1;
quit;
EOF
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
Func_DB_SQLID
}
# NON PDB
function Func_DB_NON_PDB_092()
{
sqlplus -S  '/ as sysdba' <<EOF
prompt ##############################################################
prompt # VERIFY NLS CONFIGURATION                                   #
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
COL PARAMETER FOR A30
COL DATABASE FOR A30
COL INSTANCE FOR A30
COL SESSION FOR A30
SELECT DB.PARAMETER
  , DB.VALUE "DATABASE"
  , I.VALUE "INSTANCE"
  , S.VALUE "SESSION"
FROM NLS_DATABASE_PARAMETERS DB, NLS_INSTANCE_PARAMETERS I, NLS_SESSION_PARAMETERS S
WHERE DB.PARAMETER=I.PARAMETER(+) AND DB.PARAMETER=S.PARAMETER(+)
ORDER BY 1;
quit;
EOF
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
Func_DB_SQLID
}
#
#
#########################################################################################################
# 
#########################################################################################################
#
function Func_DB_093()
{
if [[ ${varDB_PLUGGABLE} = "Y" ]]; then
  Func_DB_PDB_093
else
  Func_DB_NON_PDB_093
fi
}
# NON PDB
function Func_DB_NON_PDB_093()
{
sqlplus -S  '/ as sysdba' <<EOF
prompt ##############################################################
prompt # #
prompt ##############################################################
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'

quit;
EOF
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
Func_DB_SQLID
}
#





#
#########################################################################################################
# VERIFY ALL SQL IDS STATEMENTS
#########################################################################################################
#
# Check SQL ID
function Func_DB_SQLID()
{
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- INSERT A SQL_ID --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
SQL_ID=""
read SQL_ID
if [[ "${SQL_ID}" = "" ]]; then
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- THE SQL_ID WAS NOT INSERTED --"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
else
sqlplus -S  '/ as sysdba' <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
clear col bre comp
set pages 700 lines 700 long 9999999 numwidth 20 echo off verify off feedback off colsep '|'
col elapsed_time_in_sec format 9999.99
col first_load_time format a19
col last_load_time format a19
col SQL_FULLTEXT format a150
col child_number format 999 heading "CHLD|NUM"
col executions format 99999999 heading "EXECS"
col END_OF_FETCH_COUNT heading "FULL|EXECS"
col disk_reads heading "DISK|READS"
col buffer_gets heading "BUFFER|GETS"
col DIRECT_WRITES heading "DIRECT|WRITES"
col APPLICATION_WAIT_TIME heading "APP|WAIT|TIME"
col CONCURRENCY_WAIT_TIME heading "CONC|WAIT|TIME"
col CLUSTER_WAIT_TIME heading "CLUS|WAIT|TIME"
col USER_IO_WAIT_TIME heading "IO|WAIT|TIME"
col PLSQL_EXEC_TIME heading "PLSQL|EXEC|TIME"
col JAVA_EXEC_TIME heading "JAVA|EXEC|TIME"
col rows_processed format 999999999999 heading "ROWS|PROCESSED"
col optimizer_cost format 99999990 heading "COST"
col cpu_sec format 9999990.00 heading "CPU_TIME|SEC"
col elap_sec format 9999990.00 heading "ELAPSED|SEC"
col module format a50
col action format a50
col SHARABLE_MEM heading "SHARE|MEM"
col PERSISTENT_MEM heading "PERST|MEM"
col RUNTIME_MEM heading "RUN|MEM"
col LOADED_VERSIONS format 9999 heading "LOADED|VERS"
col KEPT_VERSIONS format 999 heading "KEPT|VERS"
col OPEN_VERSIONS format 999 heading "OPEN|VERS"
col loads format 9999
col INVALIDATIONS format 99999 heading "INVL"
col PARSE_CALLS format 99999999 heading "PARSE|CALLS"
col PARSING_USER_ID format 999999 heading "PARSING|USER|ID"
col PARSING_SCHEMA_ID format 999999 heading "PARSING|SCHEMA|ID"
prompt
prompt ##############################################################
prompt # CHECK MODULE AND ACTION                                    #
prompt ##############################################################
select child_number
  , MODULE
  , ACTION
  , PROGRAM_ID
  , PROGRAM_LINE#
from v\$sql
where sql_id='${SQL_ID}'
/
prompt
prompt ##############################################################
prompt # CHECK MEMORY                                               #
prompt ##############################################################
select child_number
  , SHARABLE_MEM
  , PERSISTENT_MEM
  , RUNTIME_MEM
  , LOADED_VERSIONS
  , KEPT_VERSIONS
  , OPEN_VERSIONS
  , LOADS
  , INVALIDATIONS
  , PARSE_CALLS
  , FIRST_LOAD_TIME
  , LAST_LOAD_TIME
  , PARSING_USER_ID
  , PARSING_SCHEMA_ID
from v\$sql
where sql_id='${SQL_ID}'
/
prompt
prompt ##############################################################
prompt # CHECK EXECS                                                #
prompt ##############################################################
select CHILD_NUMBER
  , EXECUTIONS
  , END_OF_FETCH_COUNT
  , DISK_READS
  , BUFFER_GETS
  , sorts
  , DIRECT_WRITES
  , FETCHES
  , ROWS_PROCESSED
  , OPTIMIZER_COST
from v\$sql
where sql_id='${SQL_ID}'
/
prompt
prompt ##############################################################
prompt # CHECK CPU TIME                                             #
prompt ##############################################################
select CHILD_NUMBER
  , round(cpu_time/1000000,2) CPU_SEC
  , round(elapsed_time/1000000,2) elap_sec
  , APPLICATION_WAIT_TIME
  , CONCURRENCY_WAIT_TIME
  , CLUSTER_WAIT_TIME
  , USER_IO_WAIT_TIME
  , PLSQL_EXEC_TIME
  , JAVA_EXEC_TIME
from v\$sql
where sql_id='${SQL_ID}'
/
prompt
prompt ##############################################################
prompt # CHECK SQL FULL TEXT OF STATEMENT                           #
prompt ##############################################################
select SQL_FULLTEXT
from v\$sql
where sql_id='${SQL_ID}'
/
prompt
prompt ##############################################################
prompt # CHECK OBJECT LOB OF THE STATEMENT                          #
prompt ##############################################################
select distinct object_name LOB_NAME
from sys.x\$kglob, dba_objects
where kglobt03 = '${SQL_ID}'
and KGLNAOBJ like 'table%'
and object_id = to_number(regexp_substr(KGLNAOBJ, '[^_]+', 1, 4),'xxxx')
/
prompt
prompt ##############################################################
prompt # CHECK CPU COSTS OF THE STATEMENT                           #
prompt ##############################################################
select SQL_ID
  , PLAN_HASH_VALUE
  , sum(EXECUTIONS_DELTA) EXECUTIONS
  , sum(ROWS_PROCESSED_DELTA) CROWS
  , trunc(sum(CPU_TIME_DELTA)/1000000/60) CPU_MINS
  , trunc(sum(ELAPSED_TIME_DELTA)/1000000/60) ELA_MINS
from DBA_HIST_SQLSTAT
where SQL_ID in ('${SQL_ID}')
group by SQL_ID , PLAN_HASH_VALUE
order by SQL_ID, CPU_MINS
/
prompt
prompt ##############################################################
prompt # CHECK XPLAN FROM AWR REPORT                                #
prompt ##############################################################
select * FROM table(DBMS_XPLAN.DISPLAY_AWR('${SQL_ID}'))
/
prompt
prompt ##############################################################
prompt # CHECK SQL BASELINE FOR DIFFERENT EXECUTION PLAN PER TIME   #
prompt ##############################################################
select
-- q.snap_id,
to_char(s.begin_interval_time,'dd/mm/yyyy hh24:mi:ss') begin_interval_time,
-- to_char(s.end_interval_time,'dd/mm/yyyy hh24:mi:ss') end_interval_time,
PLAN_HASH_VALUE,
-- ROWS_PROCESSED_DELTA,
round(ROWS_PROCESSED_DELTA/executions_delta,0) rows_processed,
executions_delta executions_per_report,
round(executions_delta/900,0) executions_per_sec,
-- buffer_gets_delta,
round(buffer_gets_DELTA/executions_delta,0) buffer_gets,
round(DISK_READS_DELTA/executions_delta,0) disk_read,
round(ELAPSED_TIME_DELTA/executions_delta/1000000,3) elapsed_time_in_sec
from dba_hist_sqlstat q, dba_hist_snapshot s
where q.snap_id = s.snap_id
and  sql_id='${SQL_ID}'
and  executions_delta > 0
order by q.snap_id
/
prompt
prompt ##############################################################
prompt # CHECK SQL BASELINE FOR EXECUTION PLAN                      #
prompt ##############################################################
col execs for 999,999,999
col avg_etime for 999,999.999
col avg_lio for 999,999,999.9
col begin_interval_time for a20
col node for 99999
break on plan_hash_value on startup_time skip 1
select ss.snap_id
  , ss.instance_number node
  , to_char(begin_interval_time, 'dd/mm/yyyy HH24:mm:ss') as begin_interval_time
  , sql_id
  , plan_hash_value
  , nvl(executions_delta,0) execs
  , (elapsed_time_delta/decode(nvl(executions_delta,0),0,1,executions_delta))/1000000 avg_etime
  , (buffer_gets_delta/decode(nvl(buffer_gets_delta,0),0,1,executions_delta)) avg_lio
from DBA_HIST_SQLSTAT S, DBA_HIST_SNAPSHOT SS
where sql_id = '${SQL_ID}'
and ss.snap_id = S.snap_id
and ss.instance_number = S.instance_number
and executions_delta > 0
order by 1, 2, 3;
undefine SQL_ID
set echo on verify on feedback on
quit;
EOF
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
echo " -- SQL_ID: ${SQL_ID}"
printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
fi
}
#
#
#
#
#
#
#########################################################################################################
# RMAN Funtions

#
#########################################################################################################
# RMAN: VERIFY RMAN CONFIGURATIONS
#########################################################################################################
#
function Func_RMAN_001()
{
rman target / <<EOF
show all;
quit;
EOF
}
#
#########################################################################################################
# RMAN: VIEW GENERAL REPORT
#########################################################################################################
#
function Func_RMAN_002()
{
rman target / <<EOF
report schema;
quit;
EOF
}
#
#
#########################################################################################################
# RMAN: LIST BACKUP
#########################################################################################################
#
function Func_RMAN_003()
{
rman target / <<EOF
list backup;
quit;
EOF
}
#
#
#########################################################################################################
# RMAN: LIST BACKUP SUMMARY
#########################################################################################################
#
function Func_RMAN_004()
{
rman target / <<EOF
list backup summary;
quit;
EOF
}
#
#
#########################################################################################################
# RMAN: 
#########################################################################################################
#
function Func_RMAN_005()
{
rman target / <<EOF

quit;
EOF
}
#
#
#
#
#
#

#########################################################################################################
# ASM Funtions
#

#########################################################################################################
# VERIFY ASM DISKS ATTRIBUTES
#########################################################################################################
#
function Func_ASM_003()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # VERIFY ASM DISKS ATTRIBUTES
prompt ##############################################################
col diskgroup for a20
col name for a60
col value for a60
select substr(dg.name,1,12) as diskgroup
  , substr(a.name,1,24) as name
  , substr(a.value,1,24) as value
  , read_only 
from v\$asm_diskgroup dg
  ,  v\$asm_attribute a 
order by 1, 2, 3;
-- where dg.group_number = a.group_number
-- and a.name not like '%template%';
prompt
prompt ##############################################################
prompt # SHOW ASM DISKGROUP COMPATIBILITY, STATUS AND TYPE
prompt ##############################################################
select name as diskgroup
  , substr(compatibility,1,12) as asm_compat
  , substr(database_compatibility,1,12) as db_compat 
  , state
  , type
from v\$asm_diskgroup
order by 1, 2, 3;
quit;
EOF
}
#
#########################################################################################################
# VERIFY ASM INTELLIGENT DATA PLACEMENT INFORMATIONS
#########################################################################################################
#
function Func_ASM_004()
{
sqlplus -S  '/ as sysdba' <<EOF
set pages 700 lines 700 timing on feedback on echo on heading on verify on colsep '|'
prompt ##############################################################
prompt # VERIFY ASM INTELLIGENT DATA PLACEMENT INFORMATIONS
prompt ##############################################################
col diskgroup for a20
col name for a60
select dg.name as diskgroup
  , t.name
  , t.stripe
  , t.redundancy
  , t.primary_region
  , t.mirror_region 
from v\$asm_diskgroup dg, v\$asm_template t 
where dg.group_number = t.group_number 
-- and dg.name = 'DATA' 
ORDER BY 1,2;
quit;
EOF
}
#


#
#########################################################################################################
# OPATCH VERSION + DETAILS
#########################################################################################################
#
function Func_ASM_098()
{
echo "##############################################################"
echo "# OPatch Version with Details                                #"
echo "##############################################################"
${GRID_HOME}/OPatch/opatch version
echo "##############################################################"
echo "# OPatch List Patches                                        #"
echo "##############################################################"
${GRID_HOME}/OPatch/opatch lspatches
echo "##############################################################"
echo "# OPatch LSINVENTORY with Details                            #"
echo "##############################################################"
${GRID_HOME}/OPatch/opatch lsinventory -detail
}
#







#########################################################################################################
# RAC Funtions
#







#########################################################################################################
# DATAGUARD Funtions
#







#########################################################################################################
# GOLDENGATE Funtions
#






#########################################################################################################
# WALLET Funtions
#








#########################################################################################################
# ODA Funtions
#









#########################################################################################################
# EXADATA Funtions
#

#
#########################################################################################################
# EXADATA Rack Layout
#########################################################################################################
#
function Func_EXA_001()
{
# Fred Denis -- Jan 2019 -- http://unknowndba.blogspot.com -- fred.denis3@gmail.com
#
# Show what's on an Exadata based on the /opt/oracle.SupportTools/onecommand/databasemachine.xml file
# The output shows each Exadata component, their IP, ILOM and ILOM IP on the form of an Exadata Rack layout
#
# Please have a look at https://goo.gl/wv2z5m for more information on this script
#
# The current version of the script is 20190222
#
# 20190222 - Fred Denis - Option -s to not show the empty U slots
#			  Option -f to specify a non default databasemachine.xml file
# 20190128 - Fred Denis - Added PDUs
# 20190126 - Fred Denis - Some dbmachine files may not have the info in the same order -- fixed this
# 20190125 - Fred Denis - Moved Blue to Lightblue and Red to Lightred to have a more pastel output
# 20190124 - Fred Denis - Initial Release
#
#
# Variables
#
SHOW_EMPTY_U="YES"              # Set SHOW_EMPTY_U="NO" here to always not show the empty U by default
          IN=""			        # If a file is specified with the -f option

#
# Function usage
#
usage()
{
printf "\033[1;37m%-8s\033[m\n" "NAME"                ;
cat << END
  $(basename $0) - Show an Exadata Rack Layout based on the databasemachine.xml file
END

printf "\n\033[1;37m%-8s\033[m\n" "SYNOPSIS"            ;
cat << END
  $0 [-f] [-s] [-h]
END

printf "\n\033[1;37m%-8s\033[m\n" "OPTIONS"             ;
cat << END
  -f	Specify a non default databasemachine.xml file
  $0 -f /tmp/mydatabasemachine.xml
  -s      Show a short form of the Rack Layout by hiding the empty U slots
          You can set SHOW_EMPTY_U="NO" on top of the script to always show the short form
  -h      Show this help
END
printf "\n"
exit 123
}

#
# Options management
#
while getopts "shf:" OPT; do
case ${OPT} in
  s)
    SHOW_EMPTY_U="NO"
    ;;
  f)
    IN=${OPTARG}				             	       
    ;;
  h)
    usage                                             
    ;;
 \?)   
    echo "Invalid option: -$OPTARG" >&2; usage        
    ;;
  esac
done

#
# The databasemachine.xml file we base our report on
#
if [[ -z "${IN}" ]]; then
  DBMACHINE=/opt/oracle.SupportTools/onecommand/databasemachine.xml
else
  DBMACHINE=${IN}
fi

if [[ ! -f ${DBMACHINE} ]] || [[ ! -r ${DBMACHINE} ]]; then
cat << !
  The ${DBMACHINE} cannot be found or is not readable, cannot continue.
!
  exit 123
fi
printf "\n"

awk -v SHOW_EMPTY_U="$SHOW_EMPTY_U" 'BEGIN\
        {       FS="<|>"                                                                ;
                # some colors
             COLOR_BEGIN =       "\033[1;"                                              ;
               COLOR_END =       "\033[m"                                               ;
                # Foreground colors code
                   WHITE =       "37m"                                                  ;
                  NORMAL =       "0m"                                                   ;
                # Background colors code
                    BLUE =       "44m"                                                  ;
                    BLUE =       "104m"                                                 ;       # Lightblue
                   GREEN =       "42m"                                                  ;
                  YELLOW =       "43m"                                                  ;
                    GREY =       "100m"
                     RED =       "41m"                                                  ;
                     RED =       "101m"                                                 ;       # Lightred
                   COL_U =       3                                                      ;       # Size of the "U" column
        }
        #
        # A function to center the outputs with colors
        #
        function center( str, n, color, sep)
        {       right = int((n - length(str)) / 2)                                      ;
                left  = n - length(str) - right                                         ;
                return sprintf(COLOR_BEGIN color "%" left "s%s%" right "s" COLOR_END sep, "", str, "" )        ;
        }
        #
        # A function that just print a "---" white line
        #
        function print_a_line(size)
        {
                if ( ! size)
                {       size = COL_DB+COL_VER+(COL_NODE*n)+COL_TYPE+n+3                 ;
                }
                printf("%s", COLOR_BEGIN WHITE)                                         ;
                for (k=1; k<=size; k++) {printf("%s", "-");}                            ;
                printf("%s", COLOR_END"\n")                                             ;
        }
        {       if ($2 == "RACKS")
                {       while (getline)
                        {       if ($2 == "MACHINETYPES")       {MODEL=$3       ;}
                                if ($2 == "MACHINEUSIZE")       { NB_U=$3       ;}
                                if ($2 == "ITEMS")              {ITEMS=$3       ; break ;}
                        }
                }
                if ($2 ~ /ITEM ID/)
                {       ADMINNAME=""; ADMINIP=""; ILOMNAME=""; ILOMIP=""        ;
                        while (getline)
                        {       if ($2 == "TYPE")               {TYPE=$3        ;}
                                if ($2 == "ADMINNAME")          { ADMINNAME=$3  ; if (length($3) > MAX_COL1) {MAX_COL1 = length($3)}}
                                if ($2 == "ADMINIP")            {   ADMINIP=$3  ; if (length($3) > MAX_COL2) {MAX_COL2 = length($3)}}
                                if ($2 == "ILOMNAME")           {  ILOMNAME=$3  ; if (length($3) > MAX_COL3) {MAX_COL3 = length($3)}}
                                if ($2 == "ILOMIP")             {    ILOMIP=$3  ; if (length($3) > MAX_COL4) {MAX_COL4 = length($3)}}
                                if ($2 == "ULOCATION")          {ULOC=$3        ;}
                                if ($2 == "/ITEM")              {       if (TYPE == "pdu")
                                                                        {       if (tab[ULOC] == "")
                                                                                {       tab[ULOC]=TYPE";"ADMINNAME";"ADMINIP;
                                                                                } else {tab[ULOC]=tab[ULOC]";"ADMINNAME";"ADMINIP;
                                                                                }
                                                                        } else {        tab[ULOC]=TYPE";"ADMINNAME";"ADMINIP";"ILOMNAME";"ILOMIP ;   }
                                                                        break   ;
                                                                }
                        }
                }
        }
        END\
        {       # To have a space with the right table separator
                COL_U++                                                                 ;
                MAX_COL1++                                                              ;
                MAX_COL2++                                                              ;
                MAX_COL3++                                                              ;
                MAX_COL4++                                                              ;
                line_size=COL_U+MAX_COL1+MAX_COL2+MAX_COL3+MAX_COL4+10                  ;       # Size of the "---" lines

                printf("%s\n\n", center(MODEL, line_size, WHITE))                       ;

                #Header
                printf("%s|", center("U" ,  COL_U+1, WHITE))                            ;
                printf("%s|", center("Hostname", MAX_COL1+1, WHITE))                    ;
                printf("%s|", center("Host IP", MAX_COL2+1, WHITE))                     ;
                printf("%s|", center("ILOM name", MAX_COL3+1, WHITE))                   ;
                printf("%s|", center("ILOM IP", MAX_COL4+1, WHITE))                     ;
                printf "\n"     ;
                print_a_line(line_size)                                                 ;

                for (i=NB_U; i>=0; i--)
                {
                        split (tab[i], to_print, ";")                                   ;
                        ui="U"i ;

                        color=NORMAL                                                    ;
                        if (to_print[2] != "")
                        {
                                if (to_print[1] == "computenode") {color=BLUE}          ;
                                if (to_print[1] == "cellnode")    {color=RED}           ;
                                if (to_print[1] == "ib")          {color=YELLOW}        ;
                                if (to_print[1] == "cisco")       {color=GREEN}         ;
                                if (to_print[1] == "pdu")         {color=GREY}          ;
                        }
                        if (to_print[1] == "")
                        {
                                if (tab[i-1] ~ /cellnode/)
                                {       split(tab[i-1], temp, ";")                      ;
                                        if (temp[2] != "") {color=RED}                  ;
                                }
                        }
			#if ((to_print[2] != "") || (toupper(SHOW_EMPTY_U) == "YES"))
                        if ((to_print[2] != "") || (toupper(SHOW_EMPTY_U) == "YES") || ((temp[2] != "") && (tab[i-1] ~ /cellnode/)))
			{
                           printf(COLOR_BEGIN color "%s", "")                           ;
                           printf(" %-"COL_U"s|", ui);                                  ;       # U
                           printf(" %-"MAX_COL1"s|", to_print[2])                       ;       # Hostname
                           printf(" %-"MAX_COL2"s|", to_print[3])                       ;       # Host IP
                           if ((to_print[1] ~ /node/) || (to_print[1] == "pdu"))
                           {
                                   to_print_col3 = to_print[4]                          ;
                                   to_print_col4 = to_print[5]                          ;
                           } else {
                                   to_print_col3 = ""                                   ;
                                   to_print_col4 = ""                                   ;
                           }
                           printf(" %-"MAX_COL3"s|", to_print_col3)                     ;       # ILOM name
                           printf(" %-"MAX_COL4"s|", to_print_col4)                     ;       # ILOM IP
                           printf(COLOR_END "%s", "")                                   ;
                           printf "\n"                                                  ;
			}
                }
                print_a_line(line_size)                                                 ;
                printf "\n"                                                             ;

                # A legend to explain the colors
                printf("%s", "   ")     ;
                printf(COLOR_BEGIN BLUE"%s"COLOR_END, "Database Servers")               ;
                printf("%s", "   ")     ;
                printf(COLOR_BEGIN RED"%s"COLOR_END, "Storage Servers")                 ;
                printf("%s", "   ")     ;
                printf(COLOR_BEGIN YELLOW"%s"COLOR_END, "IB Switches")                  ;
                printf("%s", "   ")     ;
                printf(COLOR_BEGIN GREEN"%s"COLOR_END, "Cisco Switch")                  ;
                printf "\n\n"                                                           ;
        }
' ${DBMACHINE} | sed s'/^/  /'
}
#
#########################################################################################################
# EXADATA Many Rack Layout
#########################################################################################################
#
function Func_EXA_002()
{
# Fred Denis -- Jan 2019 -- http://unknowndba.blogspot.com -- fred.denis3@gmail.com
#
# A simple script to launch exa-racklayout.sh on many hosts
# - SSH keys deployed to these hosts are needed
# - Fill the "LIST" variable below with your hosts in the user@IP/HOST form
# - OPTION contains the option for exa-racklayout.sh (see https://goo.gl/wv2z5m for more info)
#
# The current version of the script is 20190225
#
# 20190225 - Fred Denis - Initial release
#

# The Exadatas you want to connect to (1 connection per line and form shold be user@IP or user@hostname)
#
LIST="oracle@AN_IP
oracle@ANOTHER_IP"

#
# Variables
#
RACKLAYOUT=exa-racklayout.sh
DBMACHINE=/opt/oracle.SupportTools/onecommand/databasemachine.xml
TMP=/tmp/temp$$.txt
OPTION=" -s "		# exa-racklayout.sh in its short form (empty U hidden)
#    OPTION=""			# exa-racklayout.sh in its whole form (empty U slots are shown)

#
# Check that exa-racklayout.sh is here
#
if [[ ! -x ${RACKLAYOUT} ]]; then
cat << !
  ${RACKLAYOUT} does not exist or is not executable; to fix this issue you can:
  - Have a look at https://goo.gl/wv2z5m and download ${RACKLAYOUT}
  - Make it executable :
  $ chmod u+x ${RACKLAYOUT}
!
  exit 123
fi

for X in $(echo $LIST)
do
printf "\033[1;37m%s\033[m" "Connecting to ... ${X} "
scp -q ${X}:${DBMACHINE} ${TMP}
if [[ $? -eq 0 ]]; then
  printf "\t\033[1;32m%-8s\033[m\n" "OK" ;
  if [[ -f ${TMP} ]]; then
    ./${RACKLAYOUT} ${OPTION} -f ${TMP}
    rm -f ${TMP}
  fi
else
  printf "\t\033[1;31m%-8s\033[m\n" "Error $?" ;
fi
done
}

#
#########################################################################################################
# EXADATA: Verify Cell Status
#########################################################################################################
#
function Func_EXA_003()
{
# Fred Denis -- May 2019 -- http://unknowndba.blogspot.com -- fred.denis3@gmail.com
#
# Shows a status of the cell disks and grid disks across all the nodes of an Exadata, see usage function (option -h) for more information
# More details on this scrit: https://unknowndba.blogspot.com/2019/05/cell-status-sh-overview-exadata-cells.html
#
# The current script version is 20190510
#
# History :
#
# 20190510 - Fred Denis - Initial release
#
# Variables
#
        NB_PER_LINE=$(bc <<< "$(tput cols)/30")                                  # Number of DG to show per line,  can be changed with -n option
                TMP=/tmp/cell-status$$.tmp                                      # A tempfile
               TMP2=/tmp/cell-status2$$.tmp                                     # A tempfile
     SHOW_BAD_DISKS="NO"                                                        # Shows the details of the bad disks (-v option)
          DBMACHINE="/opt/oracle.SupportTools/onecommand/databasemachine.xml"   # databasemachine.xml file
#
# User used to connect to the cells $(basename $0) -h for more information on this
#
               USER="root"                                                      # User to connect to the cells (-u option)
        NONROOTUSER="cellmonitor"                                               # User to connect to the cells if a non root user runs cell-status.sh (-u option)

        # If root is not used to run the script it is then less likely than root SSH keys will be deployed for this user
        # We then use ${NONROOTUSER} to connect
        if [[ $(id -u) -ne 0 ]]
        then
                USER=${NONROOTUSER}
        fi

#
# An usage function
#
usage()
{
printf "\n\033[1;37m%-8s\033[m\n" "NAME"                ;
cat << END
        $(basename $0) shows a status of the Cell disks and the Grid disks on all the cells of an Exadata
END
printf "\n\033[1;37m%-8s\033[m\n" "SYNOPSIS"            ;
cat << END
        $0 [-v] [-u] [-c] [-o] [-f] [-n] [-h]
END
printf "\n\033[1;37m%-8s\033[m\n" "DESCRIPTION"         ;
cat << END
        - $(basename $0) shows a status of the Cell disks and the Grid disks on all the cells of an Exadata
        - It has be be executed by a user with SSH equivalence on the cell servers
                - If $(basename $0) is executed as root, then $USER is used to connect to the cells
                - If $(basename $0) is executed as a non root user, then $NONROOTUSER is used to connect to the cells
                - You can change this behavior by forcing the use of a specific user with the -u option
        - About the cells $(basename $0) reports about:
                - If $(basename $0) is executed as root, it uses ibhosts to build the list of cells to connect to
                - If $(basename $0) is executed as a non root user, it uses the databasemachine.xml file to build the list of cells to connect to
                - You can also specify a specific list of cells to analyze using the -c option
END
printf "\n\033[1;37m%-8s\033[m\n" "OPTIONS"             ;
cat << END
        -v      Shows the details of the bad disks (with error or bad status)
        -u      User to connect to the cells (if the default does not suit you)
        -c      Specify a file which contains the cell list to connect to (aka cell_group)

        -o      Save the output of the dcli commands in a file ($(basename $0) -o outputfile.log)
        -f      Use a file generated by the -o option as input ($(basename $0) -f outputfile.log)
        -n      Number of diskgroups to show per line (if not specified, $(basename $0) adapts it to the terminal size)

        -h      Shows this help

END
exit 123
}

#
# Options
#
while getopts "ho:f:n:vu:c:" OPT; do
        case ${OPT} in
        o)           OUT=${OPTARG}                                                              ;;
        f)            IN=${OPTARG}                                                              ;;
        n)   NB_PER_LINE=${OPTARG}                                                              ;;
        v)SHOW_BAD_DISKS="YES"                                                                  ;;
        u)          USER=${OPTARG}                                                              ;;
        c)    CELL_GROUP=${OPTARG}                                                              ;;
        h)         usage                                                                        ;;
        \?)        echo "Invalid option: -$OPTARG" >&2; usage                                   ;;
        esac
done

if [[ -z ${IN} ]]       # No input file specified, we dynamically find the info from the cells
then
  if [[ $(id -u) -eq 0 ]]
  then    # root is executing the script
    ibhosts | sed s'/"//' | grep cel | awk '{print $6}' | sort > ${TMP2}   # list of cells
  else    # When no root
    if [[ -f ${DBMACHINE} ]]
    then
      cat ${DBMACHINE} | awk 'BEGIN {FS="<|>"} {if ($3 == "cellnode") {while(getline) {if ($2 == "ADMINNAME") {print $3; break; } } }}' > ${TMP2}
    else
      cat << END
        Cannot access ${DBMACHINE}, cannot continue.
END
        exit 255
    fi
  fi
if [[ -n ${CELL_GROUP} && -f ${CELL_GROUP} ]]                           # If a cell_group file is specified we use it
then
  cp ${CELL_GROUP} ${TMP2}
fi
  dcli -g ${TMP2} -l ${USER} "echo celldisk; cellcli -e list celldisk attributes name,status,size,errorcount,disktype; echo BREAK; echo griddisk; cellcli -e list griddisk attributes asmDiskGroupName,name,asmmodestatus,asmdeactivationoutcome,size,errorcount,disktype; echo BREAK_CELL" > ${TMP}
  IN=${TMP}
fi
if [[ -n ${OUT} ]]      # Output file specified, we save the cell infos in and we exit
then
  cp ${TMP} ${OUT}
  rm ${TMP}
  cat << END
  Output file ${OUT} has been successfully generated.
END
exit 456
fi
if [[ ! -f ${IN} ]]
then
  cat << !
  Cannot find the file ${IN}; cannot continue.
!
exit 123
fi

#
# Show the Exadata model if possible
#
printf "\n"
if [ -f ${DBMACHINE} ] && [ -r ${DBMACHINE} ]
then
  cat << !
  Cluster is a $(grep -i MACHINETYPES ${DBMACHINE} | sed s'/\t*//' | sed -e s':</*MACHINETYPES>::g' -e s'/^ *//' -e s'/ *$//')
!
else
  printf "\n"
fi

#
# Read the information from the cells and make nice tables
#
awk -v nb_per_line="$NB_PER_LINE" -v show_bad_disks="$SHOW_BAD_DISKS" 'BEGIN\
        {
          # Some colors
             COLOR_BEGIN =       "\033[1;"                      ;
               COLOR_END =       "\033[m"                       ;
                     RED =       "31m"                          ;
                   GREEN =       "32m"                          ;
                  YELLOW =       "33m"                          ;
                    BLUE =       "34m"                          ;
                    TEAL =       "36m"                          ;
                   WHITE =       "37m"                          ;
                  NORMAL =        "0m"                          ;
          BACK_LIGHTBLUE =      "104m"                          ;
          RED_BACKGROUND =       "41m"                          ;
        # Column size
                COL_CELL =      20                              ;
            COL_DISKTYPE =      26                              ;
                  COL_NB =      COL_DISKTYPE/3                  ;
        }
        #
        # A function to center the outputs with colors
        #
        function center( str, n, color, sep)
        {       right = int((n - length(str)) / 2)                                                                    ;
              left  = n - length(str) - right                                                                         ;
              return sprintf(COLOR_BEGIN color "%" left "s%s%" right "s" COLOR_END sep, "", str, "" )                 ;
        }
        #
        # A function that just print a "---" white line
        #
        function print_a_line(size)
        {
               if ( ! size)
               {       size = COL_DB+COL_VER+(COL_NODE*n)+COL_TYPE+n+3                  ;
               }
               printf("%s", COLOR_BEGIN WHITE)                                          ;
               for (k=1; k<=size; k++) {printf("%s", "-");}                             ;
               printf("%s", COLOR_END"\n")                                              ;
        }
        {       sub (":", "", $1)                                                       ;
                if ($2 == "celldisk")
                {       cell = $1                                                       ;
                        tab_cell[cell] = cell                                           ;
                        while (getline)
                        {       sub (":", "", $1)                                       ;
                                if ($2 == "BREAK")
                                {
                                        break                                           ;
                                }
                                if ($3 == "normal")
                                {
                                        tab_status[cell,$NF,$3]++                       ;       # With status = normal
                                } else {
                                        bad_cell_disks[$0] = $0                         ;       # Bad disks with status != normal
                                }
                                tab_err[cell,$NF]+=$(NF-1)                              ;       # Disks with errors
                                if ($(NF-1) > 0)
                                {       bad_cell_disks[$0] = $0                         ;       # Details to show with -v option
                                }
                                tab_nbdisks[cell,$NF]++                                 ;       # NB disks per distype
                                tab_disktype[$NF]=$NF                                   ;       # Disktypes
                        }
                }       # End if ($2 == "celldisk")
                if ($2 == "griddisk")
                {       cell = $1                                                       ;
                        while(getline)
                        {       sub (":", "", $1)                                       ;
                                if ($2 == "BREAK_CELL")
                                {
                                        break                                           ;
                                }
                                if ($3 != "UNUSED")                                             # Unused disks have no DG
                                {
                                        tab2_err[cell,$2]+=$7                           ;       # Grid disks with errors
                                        if ($7 > 0)
                                        {       bad_grid_disks[$0] = $0                 ;       # Details to show with -v option
                                        }
                                        tab2_nbdisks[cell,$2]++                         ;       # Nb disks per diskgroup
                                        tab2_dgs[$2]=$2                                 ;       # Diskgroups
                                        if (tolower($5) != "yes")                               # asmDeactivationOutcome
                                        {       tab2_deact[cell,$2]="no"                ;
                                                bad_grid_disks[$0] = $0                 ;       # Details to show with -v option
                                        }
                                        if ($4 == "ONLINE")
                                        {       tab2_status[cell,$2]++                  ;       # cell,DG
                                        } else {
                                                tab2_bad[cell,$2]++                     ;       # bad status disks
                                                bad_grid_disks[$0] = $0                 ;       # Details to show with -v option
                                        }
                                }
                        }
                }       # End if ($2 == "griddisk")

        }
        function print_blue_hyphen(size, sep)
        {
                printf ("%s", center("--", size, BLUE, sep))                            ;       # Just print a blue "--"
        }
        function print_red_cross(size, sep)
        {
                printf ("%s", center("xx", size, COLOR_STATUS, sep))                    ;       # Just print a red "xx"
        }
        function print_legend()
        {       # A legend behind the tables
                printf(COLOR_BEGIN BLUE " %-"3"s" COLOR_END, "--")                              ;
                printf(COLOR_BEGIN WHITE " %-"12"s |" COLOR_END, ": Unused disks")              ;
                printf(COLOR_BEGIN RED " %-"3"s" COLOR_END, "xx")                               ;
                printf(COLOR_BEGIN WHITE " %-"20"s |" COLOR_END, ": Not ONLINE disks")          ;
                printf(COLOR_BEGIN RED_BACKGROUND " %-"3"s" COLOR_END, "  ")                    ;
                printf(COLOR_BEGIN WHITE " %-"20"s" COLOR_END, ": asmDeactivationOutcome is NOT yes");
        }
        function print_table(in_array, in_title, in_header)
        {
                # Print a table from in_array adapting every column to the largest colum in the table
                # including the header from in_header hich is a string collectyion separated by blank like "col1 col2 col3"
                # Only the first column always have a COL_CELL size to match with the other tables to keep nice output
                # It then always make a nice table and it was fun to code :)
                a=asort(in_array, sorted)                                               ;
                sorted[a+1]= in_header                                                  ;       # Table header
                print sorted[0]                                          ;
                printf("%s", center(in_title, COL_CELL, TEAL))       ;
                printf("\n")                                                            ;
                for (i=1; i<=a+1; i++)                                                          # For each line
                {       split(sorted[i], bad)                            ;
                        for (j=1; j<=length(bad); j++)                                          # For each column
                        {       if (j == 1)                                                     # To have the cell column same on all tables
                                {       size[j] = COL_CELL                              ;
                                } else {
                                        if (length(bad[j])>size[j]) { size[j] = length(bad[j])+2}       ;
                                }
                        }
                }
                line_size=0                                                             ;
                for (k=1; k<=length(size); k++) { line_size+=size[k]                    ;}
                for (i=1; i<=a; i++)                                                            # For each line
                {       split(sorted[i], bad)                            ;
                        if (i == 1)
                        {       for (j=1; j<=length(bad); j++)                                  # For each column
                                {       split(sorted[a+1], title)        ;
                                        printf("%s", center(title[j], size[j], NORMAL, "|"))            ;
                                }
                                printf("\n")                                            ;
                                print_a_line(line_size+length(size))                    ;
                        }
                        for (j=1; j<=length(bad); j++)  # Each column                           # For each column
                        {
                                printf("%s", center(bad[j], size[j], NORMAL, "|"))      ;
                        }
                        printf("\n")                                                    ;
                }
                print_a_line(line_size+length(size))                                    ;
        }
        function print_griddisk_header(i)
        {
                printed=0                                                               ;
                printf("\n\n", "")                                                        ;
                printf ("%s", center("Grid Disks", COL_CELL, TEAL, "|"))                ;

                for (j=i; j<i+nb_per_line; j++)
                {
                        dg=dgs_sorted[j]                                                ;       # To ease the naming below

                        if (j > nb_dgs)         # Everything is printed so we stop even if line is not full
                        {       break                                                   ;
                        }
                        printf ("%s", center(dg, COL_DISKTYPE, WHITE, "|"))             ;
                }
                printf("\n")                                                            ;
                printf ("%s", center(" ", COL_CELL, WHITE, "|"))                        ;

                for (j=i; j<i+nb_per_line; j++)
                {
                        if (j > nb_dgs)         # Everything is printed so we stop even if line is not full
                        {       break                                                   ;
                        }
                        printf ("%s", center("Nb", COL_NB, WHITE, "|"))                 ;
                        printf ("%s", center("Online", COL_NB, WHITE, "|"))             ;
                        printf ("%s", center("Errors", COL_NB, WHITE, "|"))             ;
                        printed++                                                       ;
                }
                printf("\n")                                                            ;
                print_a_line(COL_CELL+COL_DISKTYPE*printed+printed+1)                   ;
        }
        END\
        {       # Sort the arrays
                nb_cells=asort(tab_cell, tab_cell_sorted)                               ;
                #
                # CELL DISKS
                #
                # Disk Types
                printf("\n", "")                                                        ;
                printf ("%s", center("Cell Disks", COL_CELL, TEAL, "|"))                ;
                for (disktype in tab_disktype)
                {
                        printf ("%s", center(disktype, COL_DISKTYPE, WHITE, "|"))       ;
                }
                printf("\n")                                                            ;
                printf ("%s", center(" ", COL_CELL, WHITE, "|"))                        ;
                for (disktype in tab_disktype)
                {
                        printf ("%s", center("Nb", COL_NB, WHITE, "|"))                 ;
                        printf ("%s", center("Normal", COL_NB, WHITE, "|"))             ;
                        printf ("%s", center("Errors", COL_NB, WHITE, "|"))             ;
                }
                printf("\n")                                                            ;
                print_a_line(COL_CELL+COL_DISKTYPE*length(tab_disktype)+length(tab_disktype)+1) ;

                for (x=1; x<=nb_cells; x++)
                {
                        cell=tab_cell_sorted[x]                                         ;
                        printf ("%s", center(cell, COL_CELL, WHITE, "|"))               ;
                        for (y in tab_status)
                        {       split(y,sep,SUBSEP)                                     ;
                                if (sep[1] == cell)
                                {       for (disktype in tab_disktype)
                                        {
                                                COLOR_ERROR=GREEN                       ;
                                                COLOR_STATUS=GREEN                      ;

                                                # Nb disks
                                                printf ("%s", center(tab_nbdisks[cell,disktype], COL_NB, WHITE, "|"))                   ;

                                                # Disks status
                                                if (tab_status[cell,disktype,sep[3]]<tab_nbdisks[cell,disktype]) { COLOR_STATUS=RED;}
                                                printf ("%s", center(tab_status[cell,disktype,sep[3]], COL_NB, COLOR_STATUS, "|"))      ;

                                                # Number of error
                                                if (tab_err[cell,disktype]>0)   { COLOR_ERROR=RED;      }
                                                printf ("%s", center(tab_err[cell,disktype], COL_NB, COLOR_ERROR, "|"))                 ;
                                        }
                                        break                                           ;
                                }
                        }
                        printf("\n")                                                    ;
                }
                print_a_line(COL_CELL+COL_DISKTYPE*length(tab_disktype)+length(tab_disktype)+1)                                         ;

                #
                # Print the failed cell disks details contained in the array bad_cell_disks
                #
                if (tolower(show_bad_disks) == "yes")
                {
                        if (length(bad_cell_disks) > 0)
                        {       print_table(bad_cell_disks, "Failed Cell Disks details", "Cell Name Status Size Nb_Error Disktype")   ;
                        }
                }

                #
                # GRID DISKS
                #
                nb_dgs=asort(tab2_dgs, dgs_sorted)                                      ;

                for (i=1; i<=nb_dgs; i+=nb_per_line)
                {
                        print_griddisk_header(i)                                        ;
                        for (x=1; x<=nb_cells; x++)
                        {
                                      cell=tab_cell_sorted[x]                           ;        # To ease the naming below
                                nb_printed=0    ;
                                printf ("%s", center(cell, COL_CELL, WHITE, "|"))       ;
                                for (k=i; k<i+nb_per_line; k++)
                                {
                                        if (k > nb_dgs)                                         # Everything is printed so we stop even if line is not full
                                        {       break                                   ;
                                        }
                                        dg=dgs_sorted[k]                                ;       # To ease the naming below

                                        if (tab2_deact[cell,dg])                                # asmdeactivationoutcome is NOT yes
                                        {
                                                     COLOR_ERROR=RED_BACKGROUND         ;
                                                    COLOR_STATUS=RED_BACKGROUND         ;
                                                COLOR_STATUS_BAD=RED_BACKGROUND         ;
                                                  COLOR_NB_DISKS=RED_BACKGROUND         ;
                                        } else {
                                                     COLOR_ERROR=GREEN                  ;
                                                    COLOR_STATUS=GREEN                  ;
                                                 COLOR_STATUS_BAD=RED                   ;
                                                   COLOR_NB_DISKS=WHITE                 ;
                                        }

                                        if (tab2_nbdisks[cell,dg])
                                        {       printf ("%s", center(tab2_nbdisks[cell,dg], COL_NB, COLOR_NB_DISKS, "|"))       ;      # NB disks
                                        } else {
                                                print_blue_hyphen(COL_NB, "|")          ;
                                        }

                                        if (tab2_status[cell,dg]<tab2_nbdisks[cell,dg]) { COLOR_STATUS=COLOR_STATUS_BAD;}
                                        if (tab2_bad[cell,dg] > 0)
                                        {       print_red_cross(COL_NB, "|")            ;
                                        } else {
                                                if (tab2_status[cell,dg])
                                                {       printf ("%s", center(tab2_status[cell,dg], COL_NB, COLOR_STATUS, "|"))  ; # Nb disks with ONLINE status
                                                } else {
                                                        print_blue_hyphen(COL_NB, "|")  ;
                                                }
                                        }

                                        if (tab2_err[cell,dg]>0)    { COLOR_ERROR=COLOR_STATUS_BAD;      }
                                        if (tab2_err[cell,dg] != "")
                                        {       printf ("%s", center(tab2_err[cell,dg], COL_NB, COLOR_ERROR, "|"))              ;     # NB errors
                                        } else {
                                                print_blue_hyphen(COL_NB, "|")          ;
                                        }
                                        nb_printed++                                    ;
                                }
                                printf("\n")                                            ;
                        }
                        print_a_line(COL_CELL+COL_DISKTYPE*nb_printed+nb_printed+1)     ;
                        print_legend()                                                  ;
                }       # End         for (i=1; i<=nb_dgs; i++)

                # Show bad grid disks
                if (tolower(show_bad_disks) == "yes")
                {       printf("\n\n")                                                          ;
                        printf("%s", center("Failed Grid Disks details", COL_CELL, TEAL))       ;
                        printf("\n")                                                            ;
#                       print_table(bad_grid_disks, "Failed Grid Disks details", "Cell asmDGName Name Status Deact Size NBError Disktype")      ;
                        if (length(bad_grid_disks) > 0)
                        {
                                a=asort(bad_grid_disks, bad_grid_disks_sorted)                  ;
                                printf("%-14s%-24s%12s%16s%6s%8s%6s%16s\n", "cell", "asmDGName", "name","status", "deactoutcome", "size", "error" ,"disktype" )       ;
                                for (i=1; i<=a; i++)
                                {
                                        printf ("%s\n", bad_grid_disks_sorted[i])               ;
                                }
                        }
                        printf("\n")                                                            ;
                }
        printf("\n")                                                                    ;
        printf("\n")                                                                    ;
        }' ${IN}

#
# Delete tempfiles
#
for F in ${TMP} ${TMP2}
do
if [[ -f ${F} ]]; then
  rm -f ${F}
fi
done
}
#
#########################################################################################################
# EXADATA Verify ASM DU
#########################################################################################################
#
function Func_EXA_004()
{
# Fred Denis -- Jun 2016 -- http://unknowndba.blogspot.com -- fred.denis3@gmail.com
#
# This scripts shows a clear and colored status of the ASM used and free space
# Please have a look at the usage function or $0 -h for the available options and their description
# More information and screenshots : https://unknowndba.blogspot.ca/2018/03/asmdush-far-better-du-for-asmcmd.html
#
# A note on the --nocp option
# Note that the --nocp asmcmd option (it disables the connection pooling) has been originaly implemented
# as a workaround of a bug that appeared with the April 2016 PSU
# It resolves error messages like this one :
# sh: -c: line 0: unexpected EOF while looking for matching `''
# sh: -c: line 1: syntax error: unexpected end of file
#
#
# The current version of the script is 20190219
#
# 20190219 - Fred Denis - Some had issues with the instance list, I then moved from sed to cut to fix it -- Thanks Jakub !
# 20181218 - Fred Denis - A new -n option to print with no color -- DEFAULT_NOCOLOR can be used to modify the default behavior
#                       - Fixed the regexp to list the instances running
# 20180827 - Fred Denis - A better regexp to list the instances running
# 20180503 - Fred Denis - GI 12c introduces a "Logical_Sector" column, took this into account (Thanks Leon !)
# 20180327 - Fred Denis - "Raw Used " label for the subdirectories "Mirror_used_MB" column, adjustments in the help
# 20180318 - Fred Denis - Shows only mirrored sizes by default and the total non mirrored size only shown with the -v option
# 20180211 - Fred Denis - Many improvements:
#                       - -d options to list the subdirectories of a directory
#                       - -v option to show the Raw Free and Reserverd size
#                       - -m -g and -t to choose the Unit you want the report to be in
#                       - Default values and verbosity can be changed using the DEFAULT_UNIT and the DEFAULT_VERBOSE variables
#                       - A nice usage function
# 20170719 - Fred Denis - Remove the --nocp option as default
#
# Default values (when no option is specified in the command line)
# The last uncommented value wins
#
# DEFAULT_UNIT="MB"       # asmcmd default
DEFAULT_UNIT="GB"
# DEFAULT_UNIT="TB"
DEFAULT_VERBOSE="Yes"
# DEFAULT_VERBOSE="No"
DEFAULT_NOCOLOR="Yes"   # Print with no color
# DEFAULT_NOCOLOR="No"    # Print with colors
#
# Colored thresholds (Red, Yellow, Green)
#
CRITICAL=90
WARNING=80
#
# A color for a nice header
#
WHITE="\033[1;37m"
END_COLOR="\033[m"
#
# An usage function
#
usage()
{
printf "\n\033[1;37m%-8s\033[m\n" "NAME";
cat << END
asmdu.sh - Shows a nice summary of the ASM DiskGroups Sizes
END

printf "\n\033[1;37m%-8s\033[m\n" "SYNOPSIS";
cat << END
$0 [-d] [-m -g -t] [-n] [-v] [-h]
END

printf "\n\033[1;37m%-8s\033[m\n" "DESCRIPTION";
cat << END
$0 needs to be executed as the GI owner user to be able to use asmcmd
With no option $0 will be showing what instances are running and a size summary for each DiskGroup
END

printf "\n\033[1;37m%-8s\033[m\n" "OPTIONS";
cat << END
  -d        The directory you want the size details
  -v        Verbose -- show the "Total Raw", "Raw Free" and "Reserved" size
            You can change the default behavior with the DEFAULT_VERBOSE variable
  -m        Shows the output in MB
  -g        Shows the output in GB
  -t        Shows the output in TB
  -m -g -t  The default Unit can be specified using the DEFAULT_UNIT variable
            If more than one of these options is specified, the last one wins
  -n        Shows the output with no color (handy to send it by email)
  -h        Shows this help
END
exit 123
}
#
# Parameters management
#
PARAM_UNIT=""
PARAM_VERBOSE=""
#
while getopts "d:mgtnvh" OPT; do
  case ${OPT} in
    d) D=${OPTARG};;
    m) PARAM_UNIT="MB";;
    g) PARAM_UNIT="GB";;
    t) PARAM_UNIT="TB";;
    n) PARAM_NOCOLOR="Yes";;
    v) PARAM_VERBOSE="Yes";;
    h) usage;;
    \?) echo "Invalid option: -$OPTARG" >&2; usage;;
  esac
done

if [[ -z ${PARAM_UNIT} ]]
then # No parameter specified, we use the default
  UNIT=${DEFAULT_UNIT}
else
  UNIT=${PARAM_UNIT}
fi
if [[ -z ${PARAM_VERBOSE} ]]
then # No parameter specified, we use the default
  VERBOSE=${DEFAULT_VERBOSE}
else
  VERBOSE=${PARAM_VERBOSE}
fi
if [[ -z ${PARAM_NOCOLOR} ]]
then # No parameter specified, we use the default
  NOCOLOR=${DEFAULT_NOCOLOR}
else
  NOCOLOR=${PARAM_NOCOLOR}
fi
if [[ ${NOCOLOR} == "Yes" ]]
then
  WHITE=""
  END_COLOR=""
fi

#
# Set the ASM env
#
OLD_SID=${ORACLE_SID}
ORACLE_SID=$(ps -ef | grep pmon | grep asm | awk '{print $NF}' | sed s'/asm_pmon_//' | egrep "^[+]")
export ORAENV_ASK=NO
. oraenv > /dev/null 2>&1

#
# A quick list of the instances that are running on the server
#
ps -ef | grep pmon | grep -v grep | awk '{print $NF}' | cut -d_ -f3,4 | sort | awk -v H="$(hostname -s)" 'BEGIN {printf("\n%s", "Instances running on " H " : ")} { printf("%s, ", $0)} END{printf("\n")}' | sed s'/, $//'

#
# Manage parameters
#
if [[ -z $D ]]
then                          # No directory provided, will check all the DG
  DG=$(asmcmd lsdg | grep -v State | awk '{print $NF}' | sed s'/\///')
  SUBDIR="No"                 # Do not show the subdirectories details if no directory is specified
else
  DG=$(echo $D | sed s'/\/.*$//g')
fi

#
# A header
#
printf "\n%25s%16s${WHITE}%16s${END_COLOR}" "DiskGroup" "Redundancy" "Total ${UNIT}"  # "Raw Free ${UNIT}" "Reserved ${UNIT}"  "Usable ${UNIT}" "% Free"
if [[ ${VERBOSE} == "Yes" ]]
then
  printf "%16s%16s%16s" "Raw Total ${UNIT}" "Raw Free ${UNIT}" "Reserved ${UNIT}"
fi
printf "${WHITE}%16s%14s${END_COLOR}\n" "Usable ${UNIT}" "% Free"
printf "%25s%16s${WHITE}%16s${END_COLOR}"   "---------"     "-----------" "--------"
if [[ ${VERBOSE} == "Yes" ]]
then
  printf "%16s%16s%16s"           "------------"  "-----------" "-----------"
fi
printf "${WHITE}%16s${END_COLOR}%14s\n"     "---------"     "------"

#
# Show DG info
#
for X in ${DG}
do
  asmcmd lsdg ${X} | tail -1 | awk -v DG="$X" -v W="$WARNING" -v C="$CRITICAL" -v UNIT="$UNIT" -v VERBOSE="$VERBOSE" -v NOCOLOR="$NOCOLOR" '\
  BEGIN \
  {
  if (NOCOLOR == "Yes")
    {
    COLOR_BEGIN = "";
    COLOR_END = "";
    RED = "";
    GREEN = "";
    YELLOW = "";
    WHITE = "";
    COLOR = "";
    } 
  else 
    {
    COLOR_BEGIN = "\033[1;";
    COLOR_END = "\033[m";
    RED = COLOR_BEGIN"31m";
    GREEN = COLOR_BEGIN"32m";
    YELLOW = COLOR_BEGIN"33m";
    WHITE = COLOR_BEGIN"37m";
    COLOR = GREEN;
    }
  DIVIDER = 1;                                              # Unit divider
  RED_DIV = 1;                                              # Redundancy divider

  if (UNIT == "GB") { DIVIDER="1024"};
  if (UNIT == "TB") { DIVIDER="1048576"};                   # 1024 * 1024
  }
  {
  if ($2 == "HIGH") {RED_DIV=3;}                            # Redundancy divider
  if ($2 == "NORMAL") {RED_DIV=2;}                          # Redundancy divider

  TOTAL = sprintf("%16.2f", $(NF-6)/DIVIDER/RED_DIV);       # Total mirrored in Unit
  USABLE = sprintf("%16.2f", $(NF-3)/DIVIDER);              # Usable space in Unit
  FREE = sprintf("%12d", USABLE/TOTAL*100);                 # % Free calculated using the Usable size

  if ((100-FREE) > W) { COLOR=YELLOW;}                      # Colored %Free thresholds
  if ((100-FREE) > C) { COLOR=RED;}                         # Colored %Free thresholds

  printf("%25s%16s%16s", DG, $2, WHITE TOTAL COLOR_END);    # DG Redundancy and Total

  if (VERBOSE == "Yes")
  {
    printf("%16.2f%16.2f%16.2f", $(NF-6)/DIVIDER, $(NF-5)/DIVIDER, $(NF-4)/DIVIDER);       # Total Raw, Raw Free and reserved if Verbose
  }
    printf("%16s%14s\n", WHITE USABLE COLOR_END, COLOR FREE COLOR_END);       # Usable and Free %
  }'
done
printf "\n"

#
# Subdirs info
#
if [ -z ${SUBDIR} ]
then
  (for DIR in $(asmcmd ls ${D})
do
  echo ${DIR} $(asmcmd --nocp du ${D}/${DIR} | tail -1)      # Please look at the "About the --nocp option" notes in the header for more information
# echo ${DIR} $(asmcmd du ${D}/${DIR} | tail -1)
done) | awk -v D="$D" -v UNIT="$UNIT"\
  ' BEGIN {    printf("\n\t\t%40s\n\n", D " subdirectories size")                      ;
               printf("%25s%16s%16s\n", "Subdir", "Used " UNIT, "Raw Used " UNIT)      ;
               printf("%25s%16s%16s\n", "------", "-------", "-----------")            ;

               DIVIDER=1                                                               ;
            if (UNIT == "GB") { DIVIDER="1024"}                                        ;
            if (UNIT == "TB") { DIVIDER="1048576"}                                     ;   # 1024 * 1024
           }
           {
               use=sprintf("%16.2f", $2/DIVIDER)                                       ;
               mir=sprintf("%16.2f", $3/DIVIDER)                                       ;

               printf("%25s%16s%16s\n", $1, use, mir)                                  ;

               total_use += $2                                                         ;
               total_mir += $3                                                         ;
            }
     END  {    total_use = sprintf("%16.2f", total_use/DIVIDER)                        ;
               total_mir = sprintf("%16.2f", total_mir/DIVIDER)                        ;
               printf("\n\n%25s%16s%16s\n", "------", "-------", "---------")          ;
               printf("%25s%16s%16s\n\n", "Total", total_use, total_mir)               ;
          } '
fi
#
# For information
#
if [[ ${VERBOSE} == "Yes" ]]
then
  printf "\t\t%40s\n\n" "Note : Usable = (Raw Free - Reserved)/Redundancy";
fi
}
#
#########################################################################################################
# EXADATA Verify How Smart
#########################################################################################################
#
function Func_EXA_005()
{
# Fred Denis - March 2019
#
#*** Script in DEV ***
#
# History:
# 20190510 - Fred Denis -- divide by zero when no HCC in 12.2
#
TMP=/tmp/exastats$$.tmp
#. oraenv <<< floltp1 > /dev/null 2>&1
#cat /dev/null >  ${TMP}
#sqlplus -S / as sysdba << END | tee -a ${TMP}
sqlplus -S / as sysdba << END > ${TMP}
set lines 200                                                           ;
set head off                                                            ;
set feed off                                                            ;
col value for 99999999999999999999999999999999                          ;
select (select instance_name from gv\$instance where inst_id = b.inst_id) || '|' || b.name || '|' || b.value from gv\$sysstat b order by b.inst_id, value ;
END

awk ' BEGIN {FS="|"}
{
    # Some colors
    COLOR_BEGIN="\033[1;"                      ;
      COLOR_END="\033[m"                       ;
            RED="31m"                          ;
          GREEN="32m"                          ;
         YELLOW="33m"                          ;
           BLUE="34m"                          ;
           TEAL="36m"                          ;
          WHITE="37m"                          ;
         NORMAL="0m"                           ;
 BACK_LIGHTBLUE="104m"                         ;

    # Size columns
       COL_EVENT=35                            ;
        COL_NODE=12                            ;
       # Misc
           FIRST=1                             ;

    # Save info in arrays
    if (NF == 3)
      {
         instances[$1] = $1                      ;
         gsub(/ *$/, "", $2)                     ;
         sub("cell physical IO",    "CPIO", $2)  ;
         sub("physical read total", "PRT",  $2)  ;
         sub("cell physical write", "CPW",  $2)  ;
         sub("physical write total", "PWT",  $2) ;
         events[$2] = $2                         ;
         tab[$1,$2] = $3                         ;
       }

       # Events
        LRFC="logical read bytes from cache"                           ;    LRFC_descr="logical read from cache (bytes)"        ;
        PRTB="PRT bytes"                                               ;    PRTB_descr="Physical read (bytes)"                  ;
       PRTBO="PRT bytes optimized"                                     ;   PRTBO_descr="Physical read optimized"                ;
       CPIOP="CPIO bytes eligible for predicate offload"               ;   CPIOP_descr="Eligible for Smart Scans (bytes)"       ;
      CPIOSI="CPIO bytes saved by storage index"                       ;  CPIOSI_descr="% saved by Storage Index"               ;
     CPIOSCC="CPIO bytes saved by columnar cache"                      ; CPIOSCC_descr="% saved by Columnar Cache"              ;
      CPIOSC="CPIO interconnect bytes returned by smart scan"          ;  CPIOSC_descr="% returned by Smart Scans"              ;
       CPIOI="CPIO interconnect bytes"                                 ;                                                        # IN + OUT Traffic + count ASM mirrorring
      CPIOFC="CPIO bytes saved during optimized file creation"         ;  CPIOFC_descr="% saved during file creation"           ;
    CPIOBCPU="CPIO bytes sent directly to DB node to balance CPU"      ;CPIOBCPU_descr="When cells are overloaded"              ;
         UNC="cell IO uncompressed bytes"                              ;     UNC_descr="cell IO uncompressed (bytes)"           ;
         PWT="PWT bytes"                                               ;     PWT_descr="Physical writes"                        ;
        PWTO="PWT bytes optimized"                                     ;    PWTO_descr="Physical writes optimized"              ;
        CWFC="cell writes to flash cache"                              ;    CWFC_descr="Writes to Flash Cache"                  ;
     HCCCUNC="HCC scan cell bytes decompressed"                        ; HCCCUNC_descr="HCC decompressed on cell (bytes)"       ;
     HCCBUNC="HCC scan rdbms bytes decompressed"                       ; HCCBUNC_descr="% decompressed on rdbms"                ;
          PW="physical writes"                                         ;      PW_descr="Nb of physical writes"                  ;       # Includes ASM mirorring so unusable

 }
 #
 # A function to center the outputs with colors
 #
 function center( str, n, color, sep)
 {
   right = int((n - length(str)) / 2)                                                                    ;
   left  = n - length(str) - right                                                                       ;
   return sprintf(COLOR_BEGIN color "%" left "s%s%" right "s" COLOR_END sep, "", str, "" )               ;
 }
#
# A function that just print a "---" white line
#
function print_a_line(size)
{
  if ( ! size)
  {
     size = COL_DB+COL_VER+(COL_NODE*n)+COL_TYPE+n+3                 ;
  }
   printf("%s", COLOR_BEGIN WHITE)                                         ;
   for (k=1; k<=size; k++) {printf("%s", "-");}                            ;
   printf("%s", COLOR_END"\n")                                             ;
}
#
# Calculate and print a ratio as a line of the output table
#
function print_ratio(event, event_descr, eventtodivideby, threshold)
{
  if (! threshold)
  {
     threshold  = "80|95"  ;
  }
  if (event_descr)        # If there is a description, we print it as it is usually more friendly
  {
     to_print=event_descr    				;
  } 
  else
  {
  to_print=event          				;
}
if (! eventtodivideby)
{
  if (! FIRST)
  {
     printf ("%s\n", center("", line_size, WHITE, "|"))			;
  }
  printf (COLOR_BEGIN BACK_LIGHTBLUE"%-" COL_EVENT"s"COLOR_END"|", to_print)	;
  FIRST=0									;
  } 
  else
  {
  printf ("  %-"COL_EVENT-2"s|", to_print)       			;	# -2 as I put 2 spaces before to "indent"
}

for(i=1; i<=nb_inst; i++)
{
  value_event = tab[instances[i],events[event]]                  	 	# Value of the event for this instance
  sum_event += value_event                             				# For the overall value
  if (eventtodivideby)                                 			        # If an event to divide, we calculate a %
  {	
    divider  = tab[instances[i],events[eventtodivideby]]     			# Value of the event to divide by to get a %
    sum_divider += divider                          			;       # For the overall value
    if (divider != 0)
    {
      value  = (value_event/divider*100)             			;
    }
    printf ("%s", center(sprintf("%.2f%%", value), COL_NODE, NORMAL, "|"))	;
  }
  else
  {                                                        			# Nothing to divide with, we just print the event value
    printf ("%s", center(sprintf("%.2e", value_event), COL_NODE, NORMAL, "|"));
  }
}
# Print the overall value
if (eventtodivideby)
{
  if (sum_divider != 0)
  {
    printf ("%s", center(sprintf("%.2f%%", sum_event/sum_divider*100), COL_NODE, WHITE, "|"))   ;
  }
  else
  {
  printf ("%s", center(sprintf("%s", "n/a"), COL_NODE, WHITE, "|"))   ;
  } 
}
else
{
  printf ("%s", center(sprintf("%.2e", sum_event), COL_NODE, WHITE, "|"))	;
}
# # Print the description outside on the right of the table
# printf ("%s", event_descr)      ;
eventtodivideby = ""    							;
      sum_event = 0     							;
    sum_divider = 0     							;
printf ("\n")									;
}
END
{
  nb_inst = asorti(instances)     					;
  line_size=COL_EVENT+COL_NODE*(nb_inst+1)+nb_inst+1			;

 # Header
  printf("\n");
  print_a_line(line_size)                                                 ;
  printf ("%s", center("Event" , COL_EVENT, BLUE, "|"))                   ;
  for(i=1; i<=nb_inst; i++)
  {
    printf ("%s", center(instances[i], COL_NODE, BLUE, "|"))        ;
  }
  printf ("%s", center("Overall", COL_NODE, BLUE, "|"))                   ;
  printf ("\n");
  print_a_line(line_size)                                                 ;

  # Print the events we want
  print_ratio(events[LRFC], LRFC_descr)                                   ;
  print_ratio(events[PRTB], "% Physical read", events[LRFC])              ;
  print_ratio(events[PWT], "% Physical write", events[LRFC])              ;
  print_ratio(events[PRTB], PRTB_descr)                                   ;
  print_ratio(events[PRTBO], PRTBO_descr, events[PRTB])                   ;
  print_ratio(events[CPIOP], "% eligible for Smart Scans", events[PRTB])  ;
  print_ratio(events[CPIOP], CPIOP_descr)                                 ;
  print_ratio(events[CPIOSI], CPIOSI_descr, events[CPIOP])                ;
  print_ratio(events[CPIOFC], CPIOFC_descr, events[CPIOP])                ;
  print_ratio(events[CPIOSCC], CPIOSCC_descr, events[CPIOP])              ;
  print_ratio(events[CPIOBCPU], CPIOBCPU_descr, events[CPIOP])            ;
  print_ratio(events[UNC], UNC_descr)                                     ;
  print_ratio(events[CPIOSC], CPIOSC_descr, events[UNC])                  ;
  # Physical writes includes ASM mirorring so useless here
  #print_ratio(events[PW], PW_descr)                                      ;
  #print_ratio(events[CWFC], CWFC_descr, events[PW])                      ;
  # HCC events have all changed in 12.2
  if (events[HCCBUNC])
  {
    print_ratio(events[HCCCUNC], HCCCUNC_descr)                     ;
    print_ratio(events[HCCBUNC], "% decompressd on DB Server", events[HCCCUNC])          ;
  }
  print_a_line(line_size)                                                 ;
  printf ("\n")                                                           ;
}
'  ${TMP} | sed s'/^/  /'

if [[ -f ${TMP} ]]
then
  rm -f ${TMP}
fi
}
#
#
#########################################################################################################
# EXADATA Verify EXADATA Version
#########################################################################################################
#
function Func_EXA_006()
{
# Fred Denis -- Nov 2017 -- http://unknowndba.blogspot.com -- fred.denis3@gmail.com
#
# An Exadata version summary (https://unknowndba.blogspot.com/2018/04/exa-versionssh-exadata-components.html):
# -- has to be run as root
# -- the server where this script is started should have the root ssh  keys deployed on all the other servers (DB Nodes, Cells and IB Swicthes)
# -- see the usage fonction and/or use the -h option for a complete description
# -- For Cells and DB servers (I found no equivalent for the IB swicthes), I also check the status of the image
#    from the imageinfo command as it can be "failure" even if the good version is shown;
#    I then use a piece of awk to format the "imageinfo -ver -status" output like this :
#      node1:12.2.1.1.3.171017:success
#      node2:12.2.1.1.3.171017:failure    <= a failure status when the good version shown
#      node3:12.2.1.1.3.171017:success
#      node4:12.2.1.1.3.171017:success
#    If a DB servers or cell has a status = failure returned by the imageinfo command, the host will appear
#    in red and a note about this will be shown at the end of the report
#
# The current version of the script is 20190528
#
# 20190528 - Fred Denis - Fixed a bug on the headers
# 20190524 - Fred Denis - Better management of the naming of the hosts, cells and IB
# 20180913 - Fred Denis - Add the status = failure information for the Cells and DB Servers
#
#
# Variables
#
DBMACHINE=/opt/oracle.SupportTools/onecommand/databasemachine.xml       # File where we should find the Exadata model
SHOW_ALL="Yes"
SHOW_DBS="No"
SHOW_CELLS="No"
SHOW_IBS="No"
NB_PER_LINE=$(bc <<< "$(tput cols)/22")          # Number of element to print per line
                                                #       -- default adapts to the size of the screen (thanks to tput)
                                                #       -- can be changed at script execution with the -n option
#
# usage function
#

usage()
{
printf "\n\033[1;37m%-8s\033[m\n" "NAME";
cat << END
  exa_versions.sh - Show a nice summary of the versions of each component of an Exadata stack (DB servers, Cells and InfiniBand Switches)
END

printf "\n\033[1;37m%-8s\033[m\n" "SYNOPSIS";
cat << END
  $0 [-d] [-c] [-i] [-n] [-h]
END

printf "\n\033[1;37m%-8s\033[m\n" "DESCRIPTION";
cat << END
  $0 needs to be executed as root and the ssh keys to each Exadata component have to be deployed With no option $0 will show the versions of all the Exadata components (DB servers, Cells and IB)
  $0 relies on the ibhosts ad the ibswitches commands to find the list of nodes to look at, not on any static [dbs|cell|ib]_group file
END

printf "\n\033[1;37m%-8s\033[m\n" "OPTIONS";
cat << END
  -d      Show the Database servers versions
  -c      Show the Cells (storage servers) versions
  -i      Show the Infiniband Switches versions
  -n      Number of nodes to show per line (default adapts the output to the current screen size)
  -h      Show this help
END
exit 123
}

#
# Options management
#
while getopts "dcin:h" OPT; do
case ${OPT} in
  d)  SHOW_ALL="No"; SHOW_DBS="Yes";;
  c)  SHOW_ALL="No"; SHOW_CELLS="Yes";;
  i)  SHOW_ALL="No"; SHOW_IBS="Yes";;
  n)  NB_PER_LINE=${OPTARG};;
  h)  usage;;
  \?) echo "Invalid option: -$OPTARG" >&2; usage;;
esac
done

#
# Few tempfiles
#
DBS_GROUP=/tmp/dbsgroup$$.tmp
CELL_GROUP=/tmp/cellgroup$$.tmp
IB_GROUP=/tmp/ibgroup$$.tmp

#
# Set the ASM env to be able to use some commands (future use)
#
ORACLE_SID=$(ps -ef | grep pmon | grep asm | awk '{print $NF}' | sed s'/asm_pmon_//' | egrep "^[+]")

export ORAENV_ASK=NO
. oraenv > /dev/null 2>&1

#
# Show the Exadata model if possible
#
if [ -f ${DBMACHINE} ] && [ -r ${DBMACHINE} ]
then
  cat << !
  Cluster is a $(grep -i MACHINETYPES ${DBMACHINE} | sed s'/\t*//' | sed -e s':</*MACHINETYPES>::g' -e s'/^ *//' -e s'/ *$//')
!
else
  printf "\n"
fi

#
# Fill the tempfiles
#
ibhosts | grep db | grep -v cel | sed s'/"//g' | awk '{print $6}'  > ${DBS_GROUP}
ibhosts | grep cel | sed s'/"//g' | awk '{print $6}'               > ${CELL_GROUP}
ibswitches | awk '{print $10}'                                     > ${IB_GROUP}


( if [[ "$SHOW_DBS" == "Yes" ]] || [[ "$SHOW_ALL" == "Yes" ]]
  then
    dcli -g ${DBS_GROUP} -l root "imageinfo -ver -status" | sort | awk -F ": " '{if(node==""){node=$1}; if($2 != "") {status=$3; getline; printf ("%s:%s:%s:%s\n","db", node, $3, status);  node="" ;}}'
    echo ""
  fi
  if [[ "$SHOW_CELLS" == "Yes" ]] || [[ "$SHOW_ALL" == "Yes" ]]
  then
    dcli -g ${CELL_GROUP} -l root "imageinfo -ver -status" | grep "Active" | sort | awk -F ": " '{if(node==""){node=$1}; if($2 != "") {status=$3; getline; printf ("%s:%s:%s:%s\n","cel", node, $3, status);  node="" ;}}'
    echo ""
  fi
  if [[ "$SHOW_IBS" == "Yes" ]] || [[ "$SHOW_ALL" == "Yes" ]]
  then
    dcli -g ${IB_GROUP}  -l root version | grep -v BIOS | grep "version:" | awk '{print "ib:", $1, $NF}' | sort
    echo ""
  fi
)\
        | awk -v NB_PER_LINE="$NB_PER_LINE" ' BEGIN \
                {             FS=":"                                                                             ;
                  # some colors
                     COLOR_BEGIN="\033[1;"                                                                       ;
                       COLOR_END="\033[m"                                                                        ;
                             RED="31m"                                                                           ;
                           GREEN="32m"                                                                           ;
                          YELLOW="33m"                                                                           ;
                            BLUE="34m"                                                                           ;
                            TEAL="36m"                                                                           ;
                           WHITE="37m"                                                                           ;

                  # Columns size
                        COL_SIZE=20                                                                              ;

                  # Some variables
                         nb_node=0                                                                               ;
                        FAILURES=0                                                                               ;
                }
                function print_a_line(size)
                {
                        printf("%s", COLOR_BEGIN WHITE)                                                                 ;
                        for (k=1; k<=size;k++) {printf("%s", "-");}                                                     ;
                        printf("%s", COLOR_END"\n")                                                                     ;
                }
                #
                # A function to center the outputs with colors
                #
                function center(str, n, color)
                {       right = int((n - length(str)) / 2)                                                              ;
                         left = n - length(str) - right                                                                 ;
                        return sprintf(COLOR_BEGIN color "%" left "s%s%" right "s" COLOR_END, "", str, "" )             ;
                }
                {       if ($0 !~ /^$/)
                        {
                                            nb_node++                                                                   ;
                                               type = $1                                                                ;
                                   db_node[nb_node] = $2                                                                ;
                                db_version[nb_node] = $3                                                                ;
                                 db_status[nb_node] = $4                                                                ;

                                while (getline)
                                {
                                        if ($0 ~ /^$/)
                                        {
                                                # A Header
                                                if (type == "db")      {printf("%s\n", center("-- Database Servers",         40,RED))};
                                                if (type == "cel")     {printf("%s\n", center("-- Cells",                    30,RED))};
                                                if (type == "ib")      {printf("%s\n", center("-- Infiniband Switches",      40,RED))};
                                                printf("\n")                                                            ;
                                                version_ref = db_version[1]                                             ;

                                                for (a=0; a<nb_node; a+=NB_PER_LINE)
                                                {
                                                        nb_printed = 0                                                  ;

                                                        # Print the node names
                                                        for (i=a+1; i<=a+NB_PER_LINE; i++)
                                                        {
                                                                COLOR=WHITE                                             ;
                                                                if(db_status[i] == "failure") {COLOR=RED; FAILURES=1}   ;
                                                                if (length(db_node[i]) > 0)
                                                                {
                                                                        printf("%s", center(db_node[i],COL_SIZE,COLOR)) ;
                                                                        nb_printed++                                    ;
                                                                }
                                                        }

                                                        printf("\n")                                                    ;
                                                        print_a_line(COL_SIZE*nb_printed+NB_TO_SHOW)                    ;

                                                        # Print the nodes versions
                                                        for (i=a+1; i<=a+NB_PER_LINE; i++)
                                                        {
                                                                if (length(db_version[i]) > 0)
                                                                {
                                                                        if (db_version[i] == version_ref)
                                                                        {       A_COLOR=BLUE                            ;
                                                                        }
                                                                        else
                                                                        {
                                                                                A_COLOR=TEAL                            ;
                                                                        }
                                                                        printf("%s", center(db_version[i],COL_SIZE,A_COLOR));
                                                                }
                                                        }
                                                        printf("\n")                                                    ;
                                                        print_a_line(COL_SIZE*nb_printed+NB_TO_SHOW)                    ;
                                                        printf("\n\n")                                                  ;
                                                }       # END  for (a=0; a<nb_node; a+=NB_PER_LINE)

                                                nb_node = 0                                                             ;
                                                delete db_node                                                          ;
                                                delete db_version                                                       ;
                                                delete db_status                                                        ;
                                                break                                                                   ;
                                        }       # END if ($0 ~ /^$/)

                                                  nb_node++                                                             ;
                                           db_node[nb_node] = $2                                                        ;
                                        db_version[nb_node] = $3                                                        ;
                                         db_status[nb_node] = $4                                                        ;
                                }       # END while (getline)
                        }       # END  if ($0 !~ /^$/)
                } 
                END 
              { 
              if (FAILURES == 1)
                {       
                  printf("%s\n\n", "Note : Please investigate the hosts in red as they have a status = failure returned by the imageinfo command.")       ;
                }
            }'

# Delete tempfiles

if [ -f ${DBS_GROUP} ]  ; then rm -f ${DBS_GROUP}       ; fi
if [ -f ${CELL_GROUP} ] ; then rm -f ${CELL_GROUP}      ; fi
if [ -f ${IB_GROUP} ]   ; then rm -f ${IB_GROUP}        ; fi
}
#
#
#########################################################################################################
# EXADATA Verify EXADATA LSPATCHES
#########################################################################################################
#
function Func_EXA_007()
{
#!/bin/bash
# Fred Denis -- fred.denis3@gmail.com -- June 22nd 2018
#
# Please have a look at https://unknowndba.blogspot.com/2018/07/lspatchessh-oracle-patch-reporting-tool.html for detailed explanations
#
# Provide information on the installed and missing patches on ORACLE_HOMEs
#       $0 -h for more information
#
# The version of the script is 20191401
#
# 20191401 - Fred Denis - opatchauto report: show Homes with -s option properly, fixed GREP/UNGREP
#                       - Fixed issue with GI HOMe with no olsnodes (non-RAC)
# 20190401 - Fred Denis - Implement opatchauto report instead of lsinventory -all_nodes for versions > 1220112 or  for 11g
# 20180809 - Fred Denis - Add the desription of a patch if available
# 20180704 - Fred Denis - GREP and UNGREP now works when a file is specified
#                       - A new -o option to only get the opatch output on a file
#                       - The -s option is now compatible with the -f one
# 20180626 - Fred Denis - Started the opatch version management by showing a warning when the special 12.2.0.1.13 and 11.2.0.3.18 versions are used
#                       - see https://unknowndba.blogspot.com/2018/06/deprecation-of-opatch-command-option.html for more information
#                       - Shows an error when opatch raises an error (when another user owns the ORACLE_HOME for example)
# 20180625 - Fred Denis - Different OS support : (the script is developed under Linux)
#                       --- Solaris :
#                         -  grep "^[Aa-Zz|+]" does not work on Solaris so I moved to grep -v "^#" | grep -v "^$" when reading oratab
#                         -  default Solaris awk is the original awk and nawk lacks features from gawk (the script definitely does not work with nawk due to array management features)
#                         -  gawk is installed by default with Solaris 11 and is available for Solaris < 11, the script then expects gawk to be here for Solaris and if not it cannot continue
#                       --- HP-UX and AIX :
#                         - The "case" to support other OS is also HP-UX and AIX ready but I have not tested it as I have no such OS handy
# 20180622 - Fred Denis - Initial release
#

#
# Default values
#

 ALL_NODES="Yes"                                         # RAC system
      GREP="."                                           # What we grep                  -- default is everything
    UNGREP="nothing_to_ungrep_unless_v_option_is_used$$" # What we don't grep (grep -v)  -- default is nothing
      FILE=""                                            # No input file
       OUT=""                                            # No output file
       TMP=/tmp/fictemplspatches$$                       # A tempfile
      TMP2=/tmp/fictemplspatches2$$                      # Another tempfile
SHOW_HOMES="NO"                                          # YES or NO we want to show the Homes from /etc/oratab or the input file $FILE ONLY

#
# An usage function
#
usage()
{
printf "\n\033[1;37m%-8s\033[m\n" "NAME"                        ;
cat << END
        $0 -- Provide information on the installed and missing patches on ORACLE_HOMEs
END

printf "\n\033[1;37m%-8s\033[m\n" "SYNOPSIS"                    ;
cat << END
        $0 [-f] [-o] [-g] [-l] [-v] [-s] [-h]
END

printf "\n\033[1;37m%-8s\033[m\n" "DESCRIPTION"                 ;
cat << END
        $0 relies on the content of the /etc/oratab file to look at the installed patch on the ORACLE_HOMEs
        It uses the opatch installed on each Home to list the installed patches and find the missing ones in case of RAC system
        A file containing some opatch outputs can also be provided to $0; it will then not use opatch but rely on the input file
            oraenv has to work as it is used to check if it is a RAC installation with olsnodes
            If olsnodes from the ASM Home returns no rows then we go with local opatch
END

printf "\n\033[1;37m%-8s\033[m\n" "OPTIONS"                     ;
cat << END
        -f      A file containing one or more opatch outputs (no opatch command is performed in this mode)
                        - not compatible with the -o option
                        - compatible with the -g and -v options

        -o      An output file if you just want to generate the opatch output (no patch analysis shown)
                        - not compatible with the -f option
                        - compatible with the -g and -v options

        -l      Run opatch as Local only (default is opatch is run using the -all_nodes option)

        -g      Act as a grep command to grep the Homes you want to have the patches information
                Examples :
                  $0 -g 12                                              # Will only consider the Homes that contain "12" in their name
                  $0 -g /u01/app/oracle/product/12.1.0.2/dbhome_dr2     # Will only consider this home
                  $0 -g dbhome_1                                        # Will only consider the Homes containing "dbhome_1"
                  $0 -g dbhome_1 -f /tmp/opatchoutput                   # Will only consider the Homes containing "dbhome_1" in the /tmp/opatchoutput file

        -v      Act as a grep -v comnmand when selecting the Homes you want the patches information from; it can be combined with the -g option
                Examples :
                  $0 -v 12                                      # Will NOT consider the Homes which have"12" in their name
                  $0 -g dbhome_1 -v 12                          # Will consider the "dbhome_1" Homes BUT those containing "12" in their name
                  $0 -v grid                                    # All the Homes but the "grid" ones

        -s      Show the ORACLE_HOMEs that would be considered by the script, it can be used in conjunction with the -g and -v options
                You can then test your -g and -v combination here
                Examples :
                  $0 -s                                         # Show all Homes from /etc/oratab
                  $0 -g 12 -v oa -s                             # Show all "12" Homes BUT the "oa" ones
                  $0 -f /tmp/opatchoutput -g 12 -s              # Show the Homes from an opatch output file for the "12" Homes only

        -h      Show this help

END
exit 123
}

#
# Parameters management
#
while getopts "lg:v:f:o:hs" OPT; do
        case ${OPT} in
                f)               FILE=${OPTARG}                                 ;;
                o)                OUT=${OPTARG}                                 ;;
                g)               GREP=${OPTARG}                                 ;;
                l)          ALL_NODES=""                                        ;;
                v)             UNGREP=${OPTARG}                                 ;;
                s)         SHOW_HOMES="YES"                                     ;;
                h)              usage                                           ;;
                \?) echo "Invalid option: -$OPTARG" >&2; usage                  ;;
        esac
done

#
# Different OS support
#

OS=$(uname)
case ${OS} 
in
  SunOS)
    ORATAB=/var/opt/oracle/oratab
    AWK=/usr/bin/gawk                        ;;
  Linux)
    ORATAB=/etc/oratab
    AWK=$(which awk)                          ;;
  HP-UX)
    ORATAB=/etc/oratab
    AWK=$(which awk)                          ;;
  AIX)
    ORATAB=/etc/oratab
    AWK=$(which awk)                          ;;
  *) echo "Unsupported OS, cannot continue."
exit 666                                    ;;
esac

if [ ! -f ${ORATAB} ]
then
cat << !
  Unable to find oratab file in ${ORATAB}, cannot continue.
!
  exit 667
fi
if [ ! -f ${AWK} ]
then
cat << !
  Cannot find a modern version of awk in ${AWK}, cannot continue.
!
  exit 668
fi

if [[ -n ${FILE} && -n ${OUT} ]]
then
  cat << END
  The -f and -o options cannot be used together; cannot continue.
  $0 -h for help
END
  exit 669
fi

#
# Show Homes only if -s option specified
#
clear
if [ ${SHOW_HOMES} = "YES" ]
then
  if [[ -f ${FILE} ]]
  then
    printf "\n\033[1;37m%-8s\033[m\n\n" "ORACLE_HOMEs that would be considered (${FILE}) :"                    ;
    cat ${FILE} | grep "^Oracle Home" | awk 'BEGIN {FS=":"} { printf("\t%s\n", $NF)}' | grep ${GREP} | grep -v ${UNGREP} | sort | uniq
    cat ${FILE} | grep "homes path=" | uniq | sed s'/" .*$//' | sed s'/.*"//' | sort | grep ${GREP} | grep -v ${UNGREP}
  else
    printf "\n\033[1;37m%-8s\033[m\n\n" "ORACLE_HOMEs that would be considered (${ORATAB}) :"                    ;
    cat ${ORATAB} | grep -v "^#" | grep -v "^$" | grep -v agent | awk 'BEGIN {FS=":"} { printf("\t%s\n", $2)}' | grep ${GREP} | grep -v ${UNGREP} | sort | uniq
  fi
printf "\n"
exit 0
fi

#
# Check that the file in parameter exists
#
if [ ! -f ${FILE} ]
then
cat << !
 File ${FILE} does not exist, cannot proceed.
!
exit 123
fi

#
# Check if we could write in the out file
#
if [[ -n ${OUT} ]]
then
  if [ -d ${OUT} ]
    then  
      echo "${OUT} is a directory, please specify a regular file; cannot continue."
    exit 670
    fi
  if [ ! -w $(dirname ${OUT}) ]
  then 
    echo "$(dirname ${OUT}) is not writable; cannot continue."
  exit 671
  fi
fi

#
# Set the ASM env to be able to use crsctl commands as well as olsnodes
#
ORACLE_SID=$(ps -ef | grep pmon | grep asm | awk '{print $NF}' | sed s'/asm_pmon_//' | egrep "^[+]")

#
# No ASM then we go local (I would need a RAC config with FS to test)
#
if [ -z ${ORACLE_SID} ]
then
  ALL_NODES=""
else
  export ORAENV_ASK=NO
 . oraenv > /dev/null 2>&1

 #
 # Check if it is a RAC installtion, if not we go Local with opatch
 #
 if [ ! -f ${ORACLE_HOME}/bin/olsnodes ]
 then
   ALL_NODES=""
 else
   if [[ $(olsnodes | wc -l) -eq "0" ]]    # No RAC installed so we go local only
   then
     ALL_NODES=""
   fi
 fi
fi

if [ -z ${FILE} ]       # If a file as parameter we do not do the opatch
then
        cat /dev/null > ${TMP}

        for OH in $(cat ${ORATAB} | grep -v "^#" | grep -v "^$" | grep -v agent | awk 'BEGIN {FS=":"} { print $2}' | grep ${GREP} | grep -v ${UNGREP} | sort | uniq)
        do
                printf "%-80s" "Proceeding with ${OH} . . ."
                if [ -f $OH/OPatch/opatch ] && [ -x $OH/OPatch/opatch ]
                then
                        OPATCH_DOTTED_VERSION=$($OH/OPatch/opatch version | grep Version | awk '{print $NF}')
                        ERR=$?
                        if [ ${ERR} -eq 0 ]
                        then
                                OPATCH_VERSION=$(echo ${OPATCH_DOTTED_VERSION} | sed s'/\.//g')
                                if [[ "${OPATCH_VERSION:0:2}" -eq "12" && "${OPATCH_VERSION}" -gt 1220112 ]] ||
                                   [[ "${OPATCH_VERSION:0:2}" -eq "11" && "${OPATCH_VERSION}" -gt 1120318 ]]
                                then    # remote
                                        if [ "${ALL_NODES}" = "Yes" ]
                                        then
                                                ALL_NODES_OPTION=" -remote "
                                        else
                                                ALL_NODES_OPTION=""
                                        fi
                                        echo "Oracle Interim Patch Installer version "$OPATCH_DOTTED_VERSION               >> ${TMP}
                                        $OH/OPatch/opatchauto report -type patches -format xml ${ALL_NODES_OPTION}         >> ${TMP} 2>${TMP2}
                                        ERR=$?
                                else    # lsinventory
                                        if [ "${ALL_NODES}" = "Yes" ]
                                        then
                                                ALL_NODES_OPTION=" -all_nodes "
                                        else
                                                ALL_NODES_OPTION=""
                                        fi

                                        $OH/OPatch/opatch lsinventory ${ALL_NODES_OPTION} -oh ${OH}                        >> ${TMP} 2>${TMP2}
                                        ERR=$?
                                fi
                                if [ ${ERR} -eq 0 ]
                                then
                                       printf "\t\033[1;32m%-8s\033[m\n" "OK"          ;
                                else
                                       printf "\t\033[1;31m%-8s" "Error $ERR"          ;
                                       cat ${TMP2}                                     ;
                                       printf "\033[m\n" ""                            ;
                                fi
                        else
                                printf "\t\033[1;31m%-8s" "Error "              ;

                        fi
                                #if (((substr(OPATCH_VERSION_NUMERIC,1,2) == 12) && (OPATCH_VERSION_NUMERIC > 1220112)) ||
                                #       ((substr(OPATCH_VERSION_NUMERIC,1,2) == 11) && (OPATCH_VERSION_NUMERIC > 1120318)))

                        #$OH/OPatch/opatch lsinventory ${ALL_NODES} -oh ${OH}  >> ${TMP} 2>${TMP2}
                        #ERR=$?
                        #if [ ${ERR} -eq 0 ]
                        #then
                        #               printf "\t\033[1;32m%-8s\033[m\n" "OK"          ;
                        #else
                        #               printf "\t\033[1;31m%-8s" "Error "              ;
                        #               cat ${TMP2}                                     ;
                        #               printf "\033[m\n" ""                            ;
                        #fi
                else            #if [ -f $OH/OPatch/opatch ] && [ -x $OH/OPatch/opatch ]
                        printf "\t\033[1;31m%-8s" "Cannot find $OH/OPatch/opatch "      ;
                        printf "\033[m\n" ""                                            ;
                fi
        done
else
        cp ${FILE} ${TMP}
fi

#echo $TMP
#exit

#
# An output file is specified, we just want the opatch output so we exit before analyzing the opatch output
#
if [[ -n ${OUT} ]]
then
if [ -f ${TMP} ]
  then
    cp ${TMP} ${OUT}
    if [ $? -ne 0 ]
    then
      cat << END
      Could not copy the tempfile into ${OUT}; the opatch output should be in ${TMP};
END
    fi
    rm -f ${TMP}
    exit $?
  fi
fi

printf "\n"                                                     ;

${AWK}  -v GREP="$GREP" -v UNGREP="$UNGREP" -v OPATCH_DOTTED_VERSION="$OPATCH_DOTTED_VERSION" \
        'BEGIN {              FS =       ":"                    ;
                        # some colors
                     COLOR_BEGIN =       "\033[1;"              ;
                       COLOR_END =       "\033[m"               ;
                             RED =       "31m"                  ;
                           GREEN =       "32m"                  ;
                          YELLOW =       "33m"                  ;
                            BLUE =       "34m"                  ;
                            TEAL =       "36m"                  ;
                           WHITE =       "37m"                  ;

                         UNKNOWN =       "-"                    ;       # Something to print when the status is unknown

                        # Default columns size
                        COL_NODE =       16                     ;
                       COL_PATCH =       12                     ;
                         COL_VER =       14                     ;
}

#
# A function to center the outputs with colors
#
function center( str, n, color, sep)
{       right = int((n - length(str)) / 2)                                                                      ;
        left  = n - length(str) - right                                                                         ;
        return sprintf(COLOR_BEGIN color "%" left "s%s%" right "s" COLOR_END sep, "", str, "" )                 ;
}

#
# A function that just print a "---" white line
#
function print_a_line()
{
        printf("%s", COLOR_BEGIN WHITE)                                                                         ;
        for (k=1; k<=WIDTH; k++) {printf("%s", "-");}                                                           ;       # n = number of nodes
        printf("%s", COLOR_END"\n")                                                                             ;
}
#
# The function that prints the output in nice tables
#
function print_output()
{
        WIDTH = COL_PATCH+COL_NODE*n+n+1                                                ;
        printf(COLOR_BEGIN BLUE"  %s"COLOR_END, OH)                                     ;       # OH as a title
        if (OPATCH_VERSION == "")
        {       OPATCH_VERSION="unknown; opatchauto report does not provide the opatch version";
        }
        printf("  %s\n", "(opatch version " OPATCH_VERSION")")                          ;       # Opatch version
        # A header
        print_a_line()                                                                  ;
        printf("%s", center("Patch ID", COL_PATCH, WHITE, "|"))                         ;
        for (i = 1; i <= n; i++)
        {
               printf("%s", center(nodes[i], COL_NODE, WHITE, "|"))                     ;       # Hostname / nodes
        }
        printf("\n")                                                                    ;
        print_a_line()                                                                  ;

        some_patches=0                                                                  ;
        p=asort(all_patches)                                                            ;
        for (i = 1; i <= p; i++)
        {
                some_patches=1                                                          ;
                printf("%s", center(all_patches[i], COL_PATCH, WHITE, "|"))             ;

                for (j = 1; j <= n; j++)                # for each node
                {
                        if (patch_tab[nodes[j], all_patches[i]] == all_patches[i])      # Patch is here
                        {       printf("%s", center("-", COL_NODE, GREEN, "|"))         ;
                        }
                        else                                                            # Patch is missing
                        {
                                printf("%s", center("Missing", COL_NODE, RED, "|"))     ;
                        }
                }
                printf ("%s", descr[all_patches[i]])                                    ;       # Patch description
                printf "\n"                                                             ;
        }
        if (some_patches == 0)
        {       printf("%s\n", center("No patch installed ", WIDTH-1, TEAL, "|"))       ;
        }

        delete all_patches                                                              ;
        delete patch_tab                                                                ;
        delete nodes                                                                    ;
        delete descr                                                                    ;
        NB_PATCHES_INSTALLED=0                                                          ;
        print_a_line()                                                                  ;
        printf "\n"                                                                     ;
}
#
# Main awk
#
{       if ($0 ~ /^Oracle Interim Patch Installer version/)
        {       gsub(/([aA-zZ])| /, "", $0)                                                                     ;
                OPATCH_VERSION=$0                                                                               ;
                gsub(/\./, "", $0)                                                                              ;
                OPATCH_VERSION_NUMERIC=$0                                                                       ;
        }
        if ($1 ~ /^Oracle Home/)        # opatch lsinventory output
        {
                gsub(" ", "", $2)                                                                               ;
                OH=$2                                                                                           ;
                oh_tab[oh_nb++]=OH                                                                              ;
                if ((OH !~ GREP) || (OH ~ UNGREP))
                {
                        next                                                                                    ;
                }

                while (getline)
                {
                        if ($1 ~ /^Hostname/)                                                                           # The hostname in case it is a local opatch
                        {
                                gsub(" ", "", $2)                                                               ;
                                sub(/\..*$/, "", $2)                                                            ;
                                  SERVER = $2                                                                   ;
                                nodes[1] = $2                                                                   ;
                                       n = 1                                                                    ;
                        }
                        if (($1 ~ /^Rac system comprising/) && (! NB_PATCHES_INSTALLED))                                # RAC Home
                        {
                                cpt=1                                                                           ;
                                while(getline)
                                {       if ($0 ~ /^$/)
                                        {       break                                                           ;
                                        }
                                        gsub(" ", "", $0)                                                       ;
                                        gsub(/^.*=/, "", $0)                                                    ;
                                        nodes[cpt] = $0                                                         ;
                                        cpt++                                                                   ;
                                }
                                n=asort(nodes)                                                                  ;       # sort array nodes

                        }
                        if (($1 ~ /^Patch level status of Cluster node/) && (! NB_PATCHES_INSTALLED))                   # Grid Homes
                        {       getline; getline; getline;
                                nodes_list = ""                                                                 ;
                                while(getline)
                                {
                                        if ($0 ~ /^$/)
                                        {
                                                split(nodes_list, nodes, ",")                                   ;
                                                n=asort(nodes)                                                  ;       # sort array nodes
                                                break                                                           ;
                                        }
                                        if ($1 ~ /^ *[0-9]* /)
                                        {
                                                sub(/^ *[0-9]* /, "", $1);
                                                gsub(" ", "", $1)                                               ;
                                                gsub("\t", "", $1)                                              ;
                                                if (nodes_list == "")
                                                {       nodes_list = $1                                         ;
                                                } else {
                                                        nodes_list=nodes_list","$1                              ;
                                                }
                                        }
                                }
                        }
                        if ($1 ~ /^Node Name/)
                        {
                                gsub(" ", "", $2)                                                               ;
                                SERVER=$2                                                                       ;
                        }
                        if ($1 ~ /^Interim patches/)
                        {
                                gsub(/^.*\(/, "", $1)                                                           ;
                                gsub(/\).*$/, "", $1)                                                           ;
                                NB_PATCHES_INSTALLED = $1                                                       ;
                                    NB_PATCHES_FOUND = 0                                                        ;

                                while(getline)
                                {
                                        if (($1 ~ /^Patch/) && ($0 ~ /applied on/))     # Patch id
                                        {       NB_PATCHES_FOUND++                                              ;
                                                patch_id = $1                                                   ;
                                                sub("Patch", "", patch_id)                                      ;
                                                gsub(" ", "", patch_id)                                         ;
                                                patch_tab[SERVER, patch_id]=patch_id                            ;       # Patches per server
                                                if (patch_id in all_patches)
                                                { cpt++; } else {
                                                        all_patches[patch_id] = patch_id                        ;       # All patches accross all nodes
                                                }
                                                getline; getline ;
                                                if ($1 ~ /^Patch description/)                                          # Get the patch descr if available
                                                {
                                                        sub("Patch description: ", "", $0)                      ;
                                                        gsub("\"", "", $0)                                      ;
                                                        descr[patch_id] = $0                                    ;
                                                }
                                        }
                                        if (NB_PATCHES_FOUND == NB_PATCHES_INSTALLED)
                                        {       break                                                           ;
                                        }
                                }
                        }
                        if (($1 ~ /^OPatch succeeded/) || ($1 ~ /^OPatch completed with warnings/))
                        {
                                print_output()  ;
                                break                                                                           ;
                        }
                }

        }                       # End if ($1 ~ /^Oracle Home/)
        if ($0 ~ /OPatchAuto report result/)            # opatchauto report output
        {
                n=0                                                             ;       # Number of nodes
                while (getline)
                {       if ($0 ~ /host name=/)
                        {       sub(/^.*name="/, "", $0)                        ;
                                sub(/".*$/, "", $0)                             ;
                                SERVER=$0                                       ;
                                n++                                             ;
                                nodes[n]=SERVER                                 ;
                        }
                        if ($0 ~ /homes path/)
                        {       sub(/^.*path="/, "", $0)                        ;
                                sub(/".*$/, "", $0)                             ;
                                OH=$0                                           ;
                                if ((OH !~ GREP) || (OH ~ UNGREP))
                                {
                                        next                                    ;
                                }
                        }
                        if($0 ~ /patch id/)
                        {
                                patch_id = $0                                   ;
                                sub(/^ *<patch id="/, "", patch_id)             ;
                                sub(/".*$/, "", patch_id)                       ;
                                patch_tab[SERVER, patch_id]=patch_id            ;       # Patches per server
                                if (patch_id in all_patches)
                                { cpt++; } else {
                                        all_patches[patch_id] = patch_id        ;       # All patches accross all nodes
                                }

                        }
                        if ($0 ~ /OPatchAuto report end of result/)
                        {       print_output()                                  ;
                                break                                           ;
                        }
                }
        }
} ' ${TMP}

for F in ${TMP} ${TMP2}
do
  if [ -f ${F} ]
  then
    rm -f ${F}
  fi
done
}
#
#########################################################################################################
# EXADATA Verify EXADATA Many LSPATCHES
#########################################################################################################
#
function Func_EXA_008()
{
# Fred Denis -- March 2019
#

LSPATCHES=/tmp/lspatches.sh
OH_LIST=/tmp/oh_list

for X in $(cat $OH_LIST | awk '{print $3"|"$4}')
do
  OH=$(echo $X | awk -F "|" '{print $1}')
  PREV_OWNER=$OWNER
  OWNER=$(echo $X | awk -F "|" '{print $2}')

  if [[ "$OWNER" = "''" ]]
  then
    OWNER=$PREV_OWNER
  fi
# printf "%s%s%s\n" $OH, $OWNER $PREV_OWNER

sudo su - $OWNER << END_SU
$LSPATCHES -g $OH
END_SU
done
}
#
#########################################################################################################
# EXADATA Verify RAC / CLUSTER Status
#########################################################################################################
#
function Func_EXA_009()
{
# Fred Denis -- Jan 2016 -- http://unknowndba.blogspot.com -- fred.denis3@gmail.com
#
# Quickly shows a status of all running instances accross a 12c cluster
# The script just needs to have a working oraenv, if rac-status.sh hangs, you may suffer from http://bit.ly/2IODPJo (alternatively ,see the -e option)
#
# Please have a look at http://bit.ly/2MFkzDw  for some details and screenshots
# The latest version of the script can be downloaded here : http://bit.ly/2XEXa6j
#
# The current script version is 20190626
#
# History :
#
# 20190626 - Fred Denis - Better sorting, better recently restarted legend
# 20190621 - Fred Denis - Fixed a bug on the sorting when version was different as other (12.1 instead of 12.1.0.0)
#                       - Option -w now also supports d for day, w for week, m for month and y for year to specify the delay
# 20190620 - Fred Denis - Fixed an issue with the sorting when there was recently restarted instances
# 20190617 - Fred Denis - New -c option to sort the databases output
# 20190606 - Fred Denis - Show a yellow background when a resource has been restarted less than DIFF_HOURS hours
#                         A new -w option can be use to specify a number of hours through the command line
#                         Owners and groups which contained numbers were ignored, this is fixed
# 20190524 - Fred Denis - Fixed a bug when hostnames had more than 1 "db" pattern in their names
# 20190508 - Fred Denis - Show the whole service name and not only part of it when it contains "."
# 20190426 - Fred Denis - which gawk for AIX
# 20190104 - Fred Denis - A new -r option to Reverse the colors (useful for clear terminal backgrounds)
#                         A new -u option to show an Uncolored output
# 20190325 - Fred Denis - Solaris sed does not support sed -i, use gsed instead
#                         New -e option to NOT use oraenv to set the ASM environment but to use the current manually set environment
#                               (USE_ORAENV="NO" on top of the script to have this permanently)
# 20190318 - Fred Denis - Dont show the owner:group legend about '' menaing same as above if only 1 Home
# 20190307 - Fred Denis - Added owner:group behind the ORACLE_HOME (useful when owner are different) -- thanks Andrey for the feature idea !
#                         Also removed the P for Primary and S for Stanby legend; it looks self explanatory enough already
# 20190204 - Fred Denis - Oracle Restart support
# 20190130 - Fred Denis - 11g support (BREAK_HERE); 11g and 12c crsctl outputs are quite different
#                                               - A new -o option to specify a file to save the crsctl commands output
#                                               - A new -f option to specify an input file (a file generated by the -o option for example)
# 20190122 - Fred Denis - Multi OS support for AWK (especially for Solaris)
# 20190115 - Fred Denis - Fixed minor alignement issues
#                         Add grep (-g) and ungrep (-v) feature
# 20181110 - Fred Denis - Show short names in the tables instead of the whole hostnames if possible for better visibility
#                       - Col 1 and col 2 now align dynamically depending on the largest element to keep all the tables well aligned
#                       - Dynamic calculation of an offser for the status column size depending on the number of nodes
#                       - This can also be fixed by setting a non 0 value to COL_NODE_OFFSET on top of the script
#                       - Better alignements, centered databases and service were not nice, they are now left aligned which is more clear
# 20181010 - Fred Denis - Added the services
#                         Added default value and options to show and hide some resources (./rac-status.sh -h for more information)
# 20181009 - Fred Denis - Show the usual blue "-" when a target is offline on purpose instead of a red "Offline" which was confusing
# 20180921 - Fred Denis - Added the listeners
# 20180227 - Fred Denis - Make the the size of the DB column dynamic to handle very long database names (Thanks Michael)
#                       - Added a (P) for Primary databases and a (S) for Stanby for color blind people who
#                         may not see the difference between white and red (Thanks Michael)
# 20180225 - Fred Denis - Make the multi status like "Mounted (Closed),Readonly,Open Initiated" clear in the table by showing only the first one
# 20180205 - Fred Denis - There was a version alignement issue with more than 10 different ORACLE_HOMEs
#                       - Better colors for the label "White for PRIMARY, Red for STANBY"
# 20171218 - Fred Denis - Modify the regexp to better accomodate how the version can be in the path (cannot get it from crsctl)
# 20170620 - Fred Denis - Parameters for the size of the columns and some formatting
# 20170619 - Fred Denis - Add a column type (RAC / RacOneNode / Single Instance) and color it depending on the role of the database
#                         (WHITE for a PRIMARY database and RED for a STANDBY database)
# 20170616 - Fred Denis - Shows an ORACLE_HOME reference in the Version column and an ORACLE_HOME list below the table
# 20170606 - Fred Denis - A new 12cR2 GI feature now shows the ORACLE_HOME in the STATE_DETAILS column from "crsctl -v"
#                       - Example :     STATE_DETAILS=Open,HOME=/u01/app/oracle/product/11.2.0.3/dbdev_1 instead of STATE_DETAILS=Open in 12cR1
# 20170518 - Fred Denis - Add  a readable check on the ${DBMACHINE} file - it happens that it exists but is only root readable
# 20170501 - Fred Denis - First release
#
#
# Variables
#
        TMP=/tmp/status$$.tmp                                             # A tempfile
       TMP2=/tmp/status2$$.tmp                                            # Another tempfile
  DBMACHINE=/opt/oracle.SupportTools/onecommand/databasemachine.xml       # File where we should find the Exadata model as oracle user
       GREP="."                                                           # What we grep                  -- default is everything
     UNGREP="nothing_to_ungrep_unless_v_option_is_used$$"                 # What we don't grep (grep -v)  -- default is nothing
 USE_ORAENV="YES"                                                         # Use oraenv to set the ASM env (-e changes this to NO)
    REVERSE="NO"                                                          # Revert the colors to make them visible, useful for clear terminal backgrounds
WITH_COLORS="YES"                                                         # Output with colors, (-b changes this to NO); set to NO for permanent no colored output
      WHITE="37m"                                                         # White color code
 DIFF_HOURS="24"                                                          # Nb of hours the instance has been restarted
    SORT_BY=""                                                            # Column to sort by (see the help for possible values)

# Choose the information what you want to see -- the last uncommented value wins
# ./rac-status.sh -h for more information
  SHOW_DB="YES"                 # Databases
SHOW_LSNR="YES"                 # Listeners
 SHOW_SVC="YES"                 # Services

# Number of spaces between the status and the "|" of the column - this applies before and after the status
# A value of 2 would print 2 spaces before and after the status and like |  Open  |
# A value of 8 would print |        Open         |
# A value of 99 means that this parameter is dynamically calculated depending on the number of nodes
# A non 99 value is applied regardless of the number of nodes
COL_NODE_OFFSET=99

#
# Different OS support
#
OS=$(uname)
case ${OS} in
  SunOS)
    AWK=$(which gawk)
    SED=$(which gsed)
    ;;
  Linux)
    AWK=$(which awk)
    SED=$(which sed)
    ;;
  HP-UX)
    AWK=$(which awk)
    SED=$(which sed)
    ;;
  AIX)
    AWK=$(which gawk)
    SED=$(which sed)
    ;;
  *) printf "\n\t\033[1;31m%s\033[m\n\n" "Unsupported OS, cannot continue."
    ;;
esac
# Check if we have an AWK and a SED to continue
if [[ ! -f ${AWK} ]]
then
  printf "\n\t\033[1;31m%s" "No awk found on your system, cannot continue, if you run Solaris, please ensure that gawk is in your path"
  printf "\t%s\033[m\n\n" ${AWK}
  exit 678
fi
if [[ ! -f ${SED} ]]
then
  printf "\n\t\033[1;31m%s" "No sed found on your system, cannot continue, if you run Solaris, please ensure that gsed is in your path"
  printf "\t%s\033[m\n\n" ${SED}
  exit 679
fi

#
# An usage function
#
usage()
{
printf "\n\033[1;37m%-8s\033[m\n" "NAME";
cat << END
  $(basename $0) - A nice overview of databases, listeners and services running across a GI 12c
END

printf "\n\033[1;37m%-8s\033[m\n" "SYNOPSIS";
cat << END
        $0 [-a] [-n] [-d] [-l] [-s] [-o] [-f] [-r] [-u] [-h]
END

printf "\n\033[1;37m%-8s\033[m\n" "DESCRIPTION";
cat << END
  $(basename $0) needs to be executed with a user allowed to query GI using crsctl; oraenv also has to be working
  $(basename $0) will show what is running or not running accross all the nodes of a GI 12c :
                - The databases instances (and the ORACLE_HOME they are running against)
                - The type of database : Primary, Standby, RAC One node, Single
                - The listeners (SCAN Listener and regular listeners)
                - The services
                With no option, $(basename $0) will show what is defined by the variables :
                - SHOW_DB       # To show the databases instances
                - SHOW_LSNR     # To show the listeners
                - SHOW_SVC      # To show the services
                These variables can be modified in the script itself or you can use command line option to revert their value (see below)

END

printf "\n\033[1;37m%-8s\033[m\n" "OPTIONS";
cat << END
        -a        Show everything regardless of the default behavior defined with SHOW_DB, SHOW_LSNR and SHOW_SVC
        -n        Show nothing  regardless of the default behavior defined with SHOW_DB, SHOW_LSNR and SHOW_SVC
        -a and -n are handy to erase the defaults values:
                  $ ./rac-status.sh -n -d                         # Show the databases output only
                  $ ./rac-status.sh -a -s                         # Show everything but the services (then the listeners and the databases)

        -d        Revert the behavior defined by SHOW_DB  ; if SHOW_DB   is set to YES to show the databases by default, then the -d option will hide the databases
        -l        Revert the behavior defined by SHOW_LSNR; if SHOW_LSNR is set to YES to show the listeners by default, then the -l option will hide the listeners
        -s        Revert the behavior defined by SHOW_SVC ; if SHOW_SVC  is set to YES to show the services  by default, then the -s option will hide the services

        -g        Act as a grep command to grep a pattern from the output (key sensitive)
        -v        Act as "grep -v" to ungrep from the output
        -g and -v examples :
                  $ ./rac-status.sh -g Open                       # Show only the lines with "Open" on it
                  $ ./rac-status.sh -g Open                       # Show only the lines with "Open" on it
                  $ ./rac-status.sh -g "Open|Online"              # Show only the lines with "Open" or "Online" on it
                  $ ./rac-status.sh -g "Open|Online" -v 12        # Show only the lines with "Open" or "Online" on it but no those containing 12

        -c      Column to sort by, please have a look at "Sort the database output" in http://bit.ly/2MFkzDw for more details on this -c option

        -o      Specify a file to save the crsctl commands output
                $ ./rac-status.sh -o /tmp/rac-status_output.log
        -f      A file to use as input file (one generated by the -o option for example)
                $ ./rac-status.sh -f /tmp/rac-status_output.log

        -e      Do not use oraenv to set the ASM environment but relies on the current environment
                Set USE_ORAENV="NO" on top of the script to have a permanent -e option

        -r      Reverse the colors (useful for clear terminal backgrounds)

        -u      Shows the Uncolored output (no colors); set WITH_COLORS="NO" on top of the script to have it permanently

        -w      Show a yellow background when a resource has been restarted less than the number of hours in parameter (default is $DIFF_HOURS)
                h for hours (default) d for day, w for week, m for month and y for year can be used to specify the delay:
                $ ./rac-status.sh -w 24         # 24 hours
                $ ./rac-status.sh -w 24h        # 24 hours
                $ ./rac-status.sh -w 2d         # 2 days
                $ ./rac-status.sh -w 3m         # 3 months

        -h      Shows this help

        Note : the options are cumulative and can be combined with a "the last one wins" behavior :
                $ $0 -a -l              # Show everything but the listeners (-a will force show everything then -l will hide the listeners)
                $ $0 -n -d              # Show only the databases           (-n will force hide everything then -d with show the databases)

                Experiment and enjoy  !

END
exit 123
}

# Options
while getopts "andslhg:v:o:f:eruw:c:" OPT; do
        case ${OPT} in
        a)         SHOW_DB="YES"        ; SHOW_LSNR="YES"       ; SHOW_SVC="YES"                ;;
        n)         SHOW_DB="NO"         ; SHOW_LSNR="NO"        ; SHOW_SVC="NO"                 ;;
        d)         if [ "$SHOW_DB"   = "YES" ]; then   SHOW_DB="NO"; else   SHOW_DB="YES"; fi   ;;
        s)         if [ "$SHOW_SVC"  = "YES" ]; then  SHOW_SVC="NO"; else  SHOW_SVC="YES"; fi   ;;
        l)         if [ "$SHOW_LSNR" = "YES" ]; then SHOW_LSNR="NO"; else SHOW_LSNR="YES"; fi   ;;
        g)           GREP=${OPTARG}                                                             ;;
        c)        SORT_BY=${OPTARG}                                                             ;;
        v)         UNGREP=${OPTARG}                                                             ;;
        f)           FILE=${OPTARG}                                                             ;;
        o)            OUT=${OPTARG}                                                             ;;
        e)     USE_ORAENV="NO"                                                                  ;;
        r)        REVERSE="YES"                                                                 ;;
        w)     DIFF_HOURS=${OPTARG}                                                             ;;
        u)    WITH_COLORS="NO"                                                                  ;;
        h)         usage                                                                        ;;
        \?)        echo "Invalid option: -$OPTARG" >&2; usage                                   ;;
        esac
done


#
# Manage the diff hours depending on the unit in the -w option
#
DIFF_HOURS_UNIT=${DIFF_HOURS: -1}

if [[ ! "${DIFF_HOURS_UNIT}" =~ [0-9] ]]
then
        HOURS=$(echo ${DIFF_HOURS} | sed s'/.$//')

        case ${DIFF_HOURS_UNIT} in
        h)      NB_HOURS=1                                                                      ;;
        d)      NB_HOURS=24                                                                     ;;
        w)      NB_HOURS=$((24*7))                                                              ;;
        m)      NB_HOURS=$((24*7*31))                                                           ;;
        y)      NB_HOURS=$((24*7*31*365))                                                       ;;
        esac

        DIFF_HOURS=$(($HOURS * $NB_HOURS))
else
	DIFF_HOURS_UNIT="h"
	          HOURS=${DIFF_HOURS}
fi

#
# Check that the input file is here if specified
#
if [[ "${REVERSE}" == "YES" ]]
then
        WHITE="30m"     ;        # Black
fi
if [ -n "$FILE" ]       # Input file specified, we wont run any crsctl command and rely on the file as input
then
    if  [ ! -f ${FILE} ]
    then
        printf "\n\t\033[1;31m%s\033[m\n\n" "Cannot find the ${FILE} input file; cannot continue"
        exit 222
    else    # we use $FILE as input
        printf "\n\t\033[1;34m%s\033[m\n\n" "Proceeding with the ${FILE} file as input file"
    fi
fi

if [ -z "$FILE" ]     # This is not needed when using an input file
then
        if [[ "${USE_ORAENV}" == "YES" ]]
        then
                #
                # Set the ASM env to be able to use crsctl commands
                #
                ORACLE_SID=$(ps -ef | grep pmon | grep asm | ${AWK} '{print $NF}' | sed s'/asm_pmon_//' | egrep "^[+]")

                export ORAENV_ASK=NO
                . oraenv > /dev/null 2>&1
        fi
        if ! type crsctl > /dev/null 2>&1
        then
                printf "\n\t\033[1;31m%s\033[m\n\n" "Cannot find crsctl, cannot continue, please check if oraenv works or set your environment manually and use the -e option."          ;
                exit 777
        fi

        #
        # List of the nodes of the cluster
        #
        # Try to find if there is "db" in the hostname, if yes we can delete the common "<clustername>" pattern from the hosts for visibility
        SHORT_NAMES="NO"
        if [[ $(olsnodes | head -1 | sed s'/,.*$//g' | tr '[:upper:]' '[:lower:]') == *"db"* ]]
        then
                       NODES=$(olsnodes | sed s'/^.*db/db/g' | ${AWK} '{if (NR<2){txt=$0} else{txt=txt","$0}} END {print txt}')
        #       CLUSTER_NAME=$(olsnodes | head -1 | sed s'/db.*$//g')
                CLUSTER_NAME=$(olsnodes | head -1 | sed s'/\(^.*\)db.*/\1/')
                 SHORT_NAMES="YES"
        else
                       NODES=$(olsnodes | ${AWK} '{if (NR<2){txt=$0} else{txt=txt","$0}} END {print txt}')
                CLUSTER_NAME=$(olsnodes -c)
        fi
        # if oracle restart, olsnodes is here but returns nothing, we then set the NODES with the current hostname
        if [ -z "${NODES}" ]
        then
                NODES=$(hostname -s)
        fi

        if [[ "$WITH_COLORS" == "YES" ]]
        then
                COLOR_FOR_CLUSTER="\e[1;"${WHITE}
        else
                COLOR_FOR_CLUSTER=""
        fi
        printf "\n\t\t%s"${COLOR_FOR_CLUSTER}"%s\e[m" "Cluster " "$CLUSTER_NAME"

        #
        # Show the Exadata model if possible (if this cluster is an Exadata)
        #
        if [ -f ${DBMACHINE} ] && [ -r ${DBMACHINE} ]
        then
                        MODEL=$(grep -i MACHINETYPES ${DBMACHINE} | sed -e s':</*MACHINETYPES>::g' -e s'/^ *//' -e s'/ *$//')
                        printf "%s"${COLOR_FOR_CLUSTER}"%s\e[m\n" " is a " "$MODEL"
        else
                        printf "\n"
        fi
        printf "\n"

        # Get the info we want
        cat /dev/null                                                   >  $TMP
        if [ "$SHOW_DB" = "YES" ]
        then
                        crsctl stat res -p -w "TYPE = ora.database.type"                >> $TMP
                        crsctl stat res -v -w "TYPE = ora.database.type"                >> $TMP
        fi
        if [ "$SHOW_LSNR" = "YES" ]
        then
                        crsctl stat res -v -w "TYPE = ora.listener.type"                >> $TMP
                        crsctl stat res -p -w "TYPE = ora.listener.type"        >> $TMP
                        crsctl stat res -v -w "TYPE = ora.scan_listener.type"   >> $TMP
                        crsctl stat res -p -w "TYPE = ora.scan_listener.type"   >> $TMP
        fi
        if [ "$SHOW_SVC" = "YES" ]
        then
                        crsctl stat res -v -w "TYPE = ora.service.type"                 >> $TMP
                        #crsctl stat res -p -w "TYPE = ora.service.type"                >> $TMP         # not used, in case we need it one day
        fi

        # Easiest way to manage the different versions of crsctl outputs
        awk '{if ($1 ~ /^NAME=/) {print "BREAK_HERE"; print  $0} else {print $0}}' $TMP > $TMP2
        cp ${TMP2} ${TMP}

        if [ "$SHORT_NAMES" = "YES" ]
        then
                        ${SED} -i "s/$CLUSTER_NAME//g" $TMP
        fi
        NB_NODES=$(olsnodes | wc -l)
else            # If we use an input file
        cp ${FILE} ${TMP}
           NODES=$(grep LAST_SERVER $TMP | awk -F"=" '{print $2}' | sort | uniq | grep -v "^$" | awk '{if (NR<2){txt=$0} else{txt=txt","$0}} END {print txt}')
        NB_NODES=$(grep LAST_SERVER $TMP | awk -F"=" '{print $2}' | sort | uniq | wc -l)
fi      # End if [ -z "$FILE" ]


#
# Define the offset to apply to the status column depending on the number of nodes to make the tables visible for big implementations
#
if [ "$COL_NODE_OFFSET" = "99" ]
then
  COL_NODE_OFFSET=3;
  if [ "$NB_NODES" -eq "2" ]; then COL_NODE_OFFSET=6; fi ;
  if [ "$NB_NODES" -eq "4" ]; then COL_NODE_OFFSET=5; fi ;
  if [ "$NB_NODES" -gt "4" ]; then COL_NODE_OFFSET=3; fi ;
fi
  ${AWK} -v NODES="$NODES" -v col_node_offset="$COL_NODE_OFFSET" \
         -v         REVERSE="$REVERSE"		\
    	 -v      DIFF_HOURS="$DIFF_HOURS"	\
	     -v           HOURS="$HOURS" 		\
	     -v DIFF_HOURS_UNIT="$DIFF_HOURS_UNIT"  \
	'BEGIN\
        { FS = "=";
           n = split(NODES, nodes, ",");       # Make a table with the nodes of the cluster
           # some colors
           COLOR_BEGIN="\033[1;";
           #COLOR_BEGIN="\033[";
           COLOR_END="\033[m";
           RED="31m";
           GREEN="32m";
           YELLOW="33m";
           BLUE="34m";
           TEAL="36m";
           WHITE="37m";
           WITH_BACK="43m";
           if (REVERSE == "YES")
             {
               WHITE="30m";           # Black
               TEAL="34m";            # Blue
               COLOR_BEGIN="\033[2;"; # Bold
                }
           UNKNOWN="-";               # Something to print when the status is unknown
           # Default columns size
                COL_NODE=0                     ;
         COL_NODE_OFFSET=col_node_offset * 2   ;       # Defined on top the script, have a look for explanations on this
                  COL_DB=12                    ;
                 COL_VER=15                    ;
                COL_TYPE=14                    ;
                  COL_OH=24                    ;       # to print the ORACLE_HOMEs
               COL_OWNER=6                     ;       # to print owner:group
               COL_GROUP=3                     ;       # to print owner:group
             COL_DEFAULT=BLUE                  ;       # for the "-"
        RECENT_RESTARTED=0                     ;       # To show a legend if we found a recent restarted
        }

        #
        # A function to center the outputs with colors
        #
        function center( str, n, color)
        {       right = int((n - length(str)) / 2)                                                              ;
                left  = n - length(str) - right                                                                 ;
                return sprintf(COLOR_BEGIN color "%" left "s%s%" right "s" COLOR_END "|", "", str, "" )         ;
        }
        #
        # Get a date in format MM/DD/YYYY HH24:MI:SS and return the rounded number hours difference
        # between this date and the current date
        function diff_hours(a_date)
        {       split(a_date, temp, /[\/ :]/)                                                                   ;
                #return sprintf("%d",(systime()-mktime (temp[3]" "temp[1]" "temp[2]" "temp[4]" "temp[5]" "temp[6]))/(60*60))     ;
                return (systime()-mktime (temp[3]" "temp[1]" "temp[2]" "temp[4]" "temp[5]" "temp[6]))/(60*60)     ;
        }
        #
        # Print a legend for the recent restarted instances, listeners and services
        #
        function print_legend_recent_restarted()
        {
                if (RECENT_RESTARTED == 1)
                {       #IN_DAYS=sprintf("%.2f", DIFF_HOURS/24)                                  ;       # Round nb of days
                        printf ("\n")                                                           ;
                        printf(COLOR_BEGIN WITH_BACK " %-"3"s" COLOR_END, " ")                  ;
                        #printf(COLOR_BEGIN WHITE " %-"12"s\n " COLOR_END, ": Has been restarted less than "DIFF_HOURS" hours ago ("IN_DAYS" days ago)")              ;
			if (DIFF_HOURS_UNIT == "h")	{ UNIT="hour"		}
			if (DIFF_HOURS_UNIT == "d")	{ UNIT="day"		}	
			if (DIFF_HOURS_UNIT == "w")	{ UNIT="week"		}	
			if (DIFF_HOURS_UNIT == "m")	{ UNIT="month"		}	
			if (DIFF_HOURS_UNIT == "y")	{ UNIT="year"		}	
			if (HOURS > 1)			{ UNIT=UNIT"s"		}	
                        printf(COLOR_BEGIN WHITE " %-"12"s\n " COLOR_END, ": Has been restarted less than "HOURS" "UNIT" ago.")             ;
                }
        }
        #
        # A function that just print a "---" white line
        #
        function print_a_line(size)
        {
                if ( ! size)
                {       size = COL_DB+COL_VER+(COL_NODE*n)+COL_TYPE+n+3                                         ;
                }
                printf("%s", COLOR_BEGIN WHITE)                                                                 ;
                for (k=1; k<=size; k++) {printf("%s", "-");}                                                    ;       # n = number of nodes
                printf("%s", COLOR_END"\n")                                                                     ;
        }
        {
               # Fill 2 tables with the OH and the version from "crsctl stat res -p -w "TYPE = ora.database.type""
               if ($1 == "NAME")
               {
                        sub("^ora.", "", $2)                                                                    ;
                        sub(".db$",  "", $2)                                                                    ;
                        if ($2 ~ ".lsnr"){sub(".lsnr$", "", $2); tab_lsnr[$2] = $2;}                            ;       # Listeners
                        if ($2 ~ ".svc")                                                                                # Services
                        {       sub(".svc$", "", $2)                                                            ;
                                tab_svc[$2]=$2                                                                  ;
                                    service=$2                                                                  ;
                                sub(/^[^.]*\./, "", service)                                                    ;       # Remove the DB name
                                if (length(service) > COL_VER-1)                                                        # To adapt the column size
                                {     COL_VER = length(service) +1                                              ;
                                }
                        }
                        DB=$2                                                                                   ;
                        split($2, temp, ".")                                                                    ;
                        if (length(temp[1]) > COL_DB-1)                                                                   # To adapt the 1st column size
                        {     COL_DB = length(temp[1]) +1                                                       ;
                        }

                        getline; getline                                                                        ;
                        if ($1 == "ACL")                        # crsctl stat res -p output
                        {
                                if ((DB in version == 0) && (DB in tab_lsnr == 0) && (DB in tab_svc == 0))
                                {
                                        # Get the owner and the group
                                        match($2, /owner:([[:alnum:]]*):.*/, OWNER)                             ;
                                        match($2, /^.*pgrp:([[:alnum:]]*):.*/, GROUP)                           ;

                                        while (getline)
                                        {
                                                if ($1 == "ORACLE_HOME")
                                                {                    OH = $2                                    ;
                                                        match($2, /1[0-9]\.[0-9]\.?[0-9]?\.?[0-9]?/)            ;       # Grab the version from the OH path)
                                                                VERSION = substr($2,RSTART,RLENGTH)             ;
                                                }
                                                if ($1 == "DATABASE_TYPE")                                              # RAC / RACOneNode / Single Instance are expected here
                                                {
                                                             dbtype[DB] = $2                                    ;
                                                }
                                                if ($1 == "ROLE")                                                       # Primary / Standby expected here
                                                {              role[DB] = $2                                    ;
                                                }
                                                if ($0 ~ /^$/)
                                                {           version[DB] = VERSION                               ;
                                                                 oh[DB] = OH                                    ;

                                                        if (!(OH in oh_list))
                                                        {
                                                                oh_ref++                                        ;
                                                            oh_list[OH] = oh_ref                                ;
                                                            o_list[OH] = OWNER[1]                               ;
                                                            g_list[OH] = GROUP[1]                               ;
                                                                if (length(OH)       > COL_OH)    {        COL_OH = length(OH)                  ; }
                                                                if (length(OWNER[1]) > COL_OWNER) {     COL_OWNER = length(OWNER[1])            ; }
                                                                if (length(GROUP[1]) > COL_GROUP) {     COL_GROUP = length(GROUP[1])            ; }
                                                        }
                                                        break                                                   ;
                                                }
                                        }
                                }
                                if (DB in tab_lsnr == 1)
                                {
                                        while(getline)
                                        {
                                                if ($1 == "ENDPOINTS")
                                                {
                                                        port[DB] = $2                                           ;
                                                        break                                                   ;
                                                }
                                        }
                                }
                        }
                        if ($1 == "LAST_SERVER")        # crsctl stat res -v output
                        {           NB = 0      ;       # Number of instance as CARDINALITY_ID is sometimes irrelevant
                                SERVER = $2     ;
                                if (length(SERVER) > COL_NODE)
                                {       COL_NODE = length(SERVER) + COL_NODE_OFFSET     ;
                                }
                                while (getline)
                                {
                                        if ($1 == "LAST_SERVER")        {       SERVER = $2                             ; }
                                        if ($1 == "STATE")              {       gsub(" on .*$", "", $2)                 ;
                                                                                if ($2 ~ /ONLINE/ ) {STATE="Online"     ;
                                                                                                     if (length(STATE) > COL_NODE) { COL_NODE = length(STATE) + COL_NODE_OFFSET;}
                                                                                                    }
                                                                                if ($2 ~ /OFFLINE/) {STATE=""           ;}
                                                                        }
                                        if ($1 == "TARGET")             {       TARGET = $2                             ;}
                                        if ($1 == "LAST_RESTART")       {       started[DB,SERVER]=diff_hours($2" "$3)  ;}
                                        if ($1 == "STATE_DETAILS")      {       NB++                                    ;       # Number of instances we came through
                                                                                sub("STATE_DETAILS=", "", $0)           ;
                                                                                sub(",HOME=.*$", "", $0)                ;       # Manage the 12cR2 new feature, check 20170606 for more details
                                                                                sub("),.*$", ")", $0)                   ;       # To make clear multi status like "Mounted (Closed),Readonly,Open Initiated"
                                                                                if ($0 == "")
                                                                                {       status[DB,SERVER] = STATE       ;}
                                                                                else {
                                                                                        if ($0 == "Instance Shutdown")  {  status[DB,SERVER] = "Shutdown"       ;       } else
                                                                                        if ($0 ~  "Readonly")           {  status[DB,SERVER] = "Readonly"       ;       } else
                                                                                        if ($0 ~  /Mount/)              {  status[DB,SERVER] = "Mounted"        ;       } else
                                                                                                                        {  status[DB,SERVER] = $0               ;       }
                                                                                        if (length(status[DB,SERVER]) > COL_NODE)
                                                                                        {       COL_NODE = length(status[DB,SERVER]) + COL_NODE_OFFSET  ;
                                                                                        }
                                                                                }
                                                                        }
                                                                        if ($1 == "BREAK_HERE") { break;}
                                }
                        }
                }       # End of if ($1 ~ /^NAME/)
            }
            END {       if (length(tab_lsnr) > 0)                # We print only if we have something to show
                        {
                                # A header for the listeners
                                printf("%s", center("Listener" ,  COL_DB, WHITE))                               ;
                                printf("%s", center("Port"     , COL_VER, WHITE))                               ;
                                n=asort(nodes)                                                                  ;       # sort array nodes
                                for (i = 1; i <= n; i++) {
                                        printf("%s", center(nodes[i], COL_NODE, WHITE))                         ;
                                }
                                printf("%s", center("Type"    , COL_TYPE, WHITE))                               ;
                                printf("\n")                                                                    ;

                                # a "---" line under the header
                                print_a_line()                                                                  ;

                                # print the listeners
                                x=asorti(tab_lsnr, lsnr_sorted)                                                 ;
                                for (j = 1; j <= x; j++)
                                {
                                        printf(COLOR_BEGIN WHITE " %-"COL_DB-1"s" COLOR_END"|", lsnr_sorted[j], WHITE);     # Listener name
                                        # It may happen that listeners listen on many ports then it wont fit this column
                                        # We then print it outside of the table after the last column
                                        if (length(port[lsnr_sorted[j]]) > COL_VER)
                                        {
                                                printf(COLOR_BEGIN WHITE " %-"COL_VER-1"s" COLOR_END"|", "See -->", WHITE);       # "See -->"
                                                print_port_later = 1                                            ;
                                        } else {
                                                printf(COLOR_BEGIN WHITE " %-"COL_VER-1"s" COLOR_END"|", port[lsnr_sorted[j]], WHITE);      # Port
                                        }

                                        for (i = 1; i <= n; i++)
                                        {
                                                dbstatus = status[lsnr_sorted[j],nodes[i]]                      ;
                                                if ((started[lsnr_sorted[j],nodes[i]] < DIFF_HOURS) && (started[lsnr_sorted[j],nodes[i]]))
                                                {         COL_ONLINE=WITH_BACK                          ;
                                                           COL_OTHER=WITH_BACK                          ;
                                                    RECENT_RESTARTED=1                                  ;
                                                } else {
                                                          COL_ONLINE=GREEN                              ;
                                                           COL_OTHER=RED                                ;
                                                }
                                                if (dbstatus == "")             {printf("%s", center(UNKNOWN , COL_NODE, COL_DEFAULT    ))      ;}      else
                                                if (dbstatus == "Online")       {printf("%s", center(dbstatus, COL_NODE, COL_ONLINE     ))      ;}
                                                else                            {printf("%s", center(dbstatus, COL_NODE, COL_OTHER      ))      ;}
                                        }
                                        if (toupper(lsnr_sorted[j]) ~ /SCAN/)
                                        {       LSNR_TYPE = "SCAN"                                              ;
                                        } else {
                                                LSNR_TYPE = "Listener"                                          ;
                                        }
                                        printf("%s", center(LSNR_TYPE, COL_TYPE, WHITE))                        ;
                                        if (print_port_later)
                                        {       print_port_later = 0                                            ;
                                                printf(COLOR_BEGIN WHITE " %-"COL_VER-1"s" COLOR_END, port[lsnr_sorted[j]], WHITE);      # Port
                                        }
                                        printf("\n")                                                            ;
                                }
                                # a "---" line under the header
                                print_a_line()                                                                  ;
                                printf("\n")                                                                    ;
                        }

                        if (length(tab_svc) > 0)                # We print only if we have something to show
                        {
                                # A header for the services
                                printf("%s", center("DB"      ,  COL_DB, WHITE))                                ;
                                printf("%s", center("Service" ,  COL_VER, WHITE))                               ;
                                n=asort(nodes)                                                                  ;       # sort array nodes
                                for (i = 1; i <= n; i++) {
                                        printf("%s", center(nodes[i], COL_NODE, WHITE))                         ;
                                }
                                printf("\n")

                                # a "---" line under the header
                                print_a_line(COL_DB+COL_NODE*n+COL_VER+n+2)                                    ;

                                # Print the Services
                                x=asorti(tab_svc, svc_sorted)                                                   ;
                                for (j = 1; j <= x; j++)
                                {       split(svc_sorted[j], to_print, ".")                                     ;       # The service we have is <db_name>.<service_name>
                                        service = svc_sorted[j]                                                 ;
                                        sub(/^[^.]*\./, "", service)                                            ;       # Remove the DB name only
                                        if (previous_db != to_print[1])                                                 # Do not duplicate the DB names on the output
                                        {
                                                printf(COLOR_BEGIN WHITE " %-"COL_DB-1"s" COLOR_END"|", to_print[1], WHITE);     # Database
                                                previous_db = to_print[1]                                       ;
                                        }else {
                                                printf("%s", center("",  COL_DB, WHITE))                        ;
                                        }
                                        #printf(COLOR_BEGIN WHITE " %-"COL_VER-1"s" COLOR_END"|", to_print[2], WHITE);     # Service
                                        printf(COLOR_BEGIN WHITE " %-"COL_VER-1"s" COLOR_END"|", service, WHITE);     # Service

                                        for (i = 1; i <= n; i++)
                                        {
                                                dbstatus = status[svc_sorted[j],nodes[i]]               ;
                                                if ((started[svc_sorted[j],nodes[i]] < DIFF_HOURS) && (started[svc_sorted[j],nodes[i]] < DIFF_HOURS))
                                                {         COL_ONLINE=WITH_BACK                          ;
                                                           COL_OTHER=WITH_BACK                          ;
                                                    RECENT_RESTARTED=1                                  ;
                                                } else {
                                                          COL_ONLINE=GREEN                              ;
                                                           COL_OTHER=RED                                ;
                                                }
                                                if (dbstatus == "")             {printf("%s", center(UNKNOWN , COL_NODE, COL_DEFAULT   ))      ;}      else
                                                if (dbstatus == "Online")       {printf("%s", center(dbstatus, COL_NODE, COL_ONLINE    ))      ;}
                                                else                            {printf("%s", center(dbstatus, COL_NODE, COL_OTHER     ))      ;}
                                        }
                                        printf("\n")                                                             ;
                                }
                                # a "---" line under the header
                                print_a_line(COL_DB+COL_NODE*n+COL_VER+n+2)                                      ;
                                printf("\n")                                                                     ;
                        }

                        if (length(version) > 0)                # We print only if we have something to show
                        {
                                # A header for the databases
                                printf("%s", center("DB"        , COL_DB, WHITE))                                ;
                                printf("%s", center("Version"   , COL_VER, WHITE))                               ;
                                n=asort(nodes)                                                                   ;       # sort array nodes
                                for (i = 1; i <= n; i++) {
                                        printf("%s", center(nodes[i], COL_NODE, WHITE))                          ;
                                }
                                printf("%s", center("DB Type"    , COL_TYPE, WHITE))                             ;
                                printf("\n")                                                                     ;

                                # a "---" line under the header
                                print_a_line()                                                                   ;

                                # Print the databases
                                m=asorti(version, version_sorted)                                                ;
                                for (j = 1; j <= m; j++)
                                {
                                        printf(COLOR_BEGIN WHITE " %-"COL_DB-1"s" COLOR_END"|", version_sorted[j], WHITE);     # Database
                                        #printf(COLOR_BEGIN WHITE " %-"COL_VER-7"s" COLOR_END, version[version_sorted[j]], COL_VER, WHITE)         ;       # Version
                                        #printf(COLOR_BEGIN WHITE "%6s" COLOR_END"|"," ("oh_list[oh[version_sorted[j]]] ") ")            ;       # OH id
                                        printf(COLOR_BEGIN WHITE " %-"COL_VER-6"s" COLOR_END, version[version_sorted[j]], COL_VER, WHITE)         ;       # Version
                                        printf(COLOR_BEGIN WHITE "%6s" COLOR_END"|"," ("oh_list[oh[version_sorted[j]]] ") ")            ;       # OH id

                                        for (i = 1; i <= n; i++) {
                                                dbstatus = status[version_sorted[j],nodes[i]]                    ;
                                                #
                                                # Print the status here, all that are not listed in that if ladder will appear in RED
                                                #
                                                if ((started[version_sorted[j],nodes[i]] < DIFF_HOURS) && (started[version_sorted[j],nodes[i]]))
                                                {           COL_OPEN=WITH_BACK                          ;
                                                        COL_READONLY=WITH_BACK                          ;
                                                            COL_SHUT=WITH_BACK                          ;
                                                           COL_OTHER=WITH_BACK                          ;
                                                    RECENT_RESTARTED=1                                  ;
                                                } else {
                                                            COL_OPEN=GREEN                              ;
                                                        COL_READONLY=WHITE                              ;
                                                            COL_SHUT=YELLOW                             ;
                                                           COL_OTHER=RED                                ;
                                                }
                                                if (dbstatus == "")                     {printf("%s", center(UNKNOWN , COL_NODE, COL_DEFAULT ))  ;}      else
                                                if (dbstatus == "Open")                 {printf("%s", center(dbstatus, COL_NODE, COL_OPEN    ))  ;}      else
                                                if (dbstatus ~  /Readonly/)             {printf("%s", center(dbstatus, COL_NODE, COL_READONLY))  ;}      else
                                                if (dbstatus ~  /Shut/)                 {printf("%s", center(dbstatus, COL_NODE, COL_SHUT    ))  ;}      else
                                                                                        {printf("%s", center(dbstatus, COL_NODE, COL_OTHER   ))  ;}

                                        }
                                        #
                                        # Color the DB Type column depending on the ROLE of the database (20170619)
                                        #
                                        if (role[version_sorted[j]] == "PRIMARY") { ROLE_COLOR=WHITE ; ROLE_SHORT=" (P)"; } else { ROLE_COLOR=RED ; ROLE_SHORT=" (S)" }
                                        printf("%s", center(dbtype[version_sorted[j]] ROLE_SHORT, COL_TYPE, ROLE_COLOR))           ;

                                        printf("\n")                                                            ;
                                }

                                # a "---" line as a footer
                                print_a_line()                                                                  ;

                                # Print the OH list and a legend for the DB Type colors underneath the table
                                printf ("%s", "ORACLE_HOME references listed in the Version column ")         ;
                                if (oh_ref > 1)
                                {
                                        printf ("(%s)", "\"" sprintf(COLOR_BEGIN TEAL "%s" COLOR_END, "\47\47") "\" means \"same as above\"")     ;
                                }
                                printf ("\n\n")                                                                 ;

                                previous_group = ""                     ;
                                previous_owner = ""                     ;
                                if (COL_OWNER%2) { COL_OWNER++  }
                                if (COL_GROUP%2) { COL_GROUP++  }
                                g_same_as_above=sprintf(COLOR_BEGIN TEAL "%"(COL_GROUP/2)-1"s%s" COLOR_END, "", "\47\47");
                                o_same_as_above=sprintf(COLOR_BEGIN TEAL "%"(COL_OWNER/2)-1"s%s%"(COL_OWNER/2)-1"s" COLOR_END, "", "\47\47", "");

                                # to ease the ORACLE_HOME sorting
                                for (x in oh_list)
                                {
                                        to_print[oh_list[x]] = x        ;
                                }
                                for (i=1; i<=oh_ref; i++)
                                {
                                        # to ease the naming
                                        the_oh=to_print[i]              ;
                                         owner=o_list[to_print[i]]      ;
                                         group=g_list[to_print[i]]      ;
                                        if (group == previous_group) {  group_to_print = g_same_as_above        ;       } else {        group_to_print = group  ;       }
                                        if (owner == previous_owner) {  owner_to_print = o_same_as_above        ;       } else {        owner_to_print = owner  ;       }

                                        printf("\t%2d : %-"COL_OH"s\t%-"COL_OWNER"s %s\n", i, the_oh, owner_to_print, group_to_print) ;
                                        previous_group = group          ;
                                        previous_owner = owner          ;
                                }
                        }
        }
        END {   print_legend_recent_restarted();
        } ' $TMP | ${AWK} -v GREP="$GREP" -v UNGREP="$UNGREP" ' BEGIN {FS="|"}                                              # AWK used to grep and ungrep
                      {         if ((NF >= 3) && ($(NF-1) !~ /Type/) && ($2 !~ /Service/))
                                {       if (($0 ~ GREP) && ($0 !~ UNGREP))
                                        {
                                                print $0                                                          ;
                                        }
                                } else {
                                        print  $0                                                                 ;
                                }
                        }' | sed s'/^/  /'              > ${TMP2}                       # We can reuse TMP2 here

        #
        # Special sort order (option -c)
        #
        if [[ -n ${SORT_BY} ]]                                                          # Special sort order
        then
                  SORT_COL="${SORT_BY:0:1}"                                             # First character
                 SORT_NODE="${SORT_BY:1:1}"                                             # Second character
                SORT_ORDER="${SORT_BY: -1}"                                             # Last character

		if [[ "${SORT_COL}" =~ [1-9] ]]
		then	SORT_NODE=${SORT_COL}
			 SORT_COL="c"
		fi

                # Sort order can only be "r" for reverse or "" for normal
                if [[ "${SORT_ORDER}" != "r" ]]
                then    SORT_ORDER=""
                else    SORT_ORDER="r"
                fi

                # Column or node number
                if [[ ! "${SORT_NODE}" =~ [1-9] ]]
                then    SORT_NODE=1
                fi


                # Assign the column  number depending of what we want to sort by
                 SORT_NUM=1
                SORT_NUM2=2                                                                                                    # Second column to sort by
                SORT_NUM3=2                                                                                                    # Third column to sort by
                case ${SORT_COL} in
                c )     if [[ "${SORT_NODE}" -gt "2" ]]
                        then
                                SORT_NUM=$(((${SORT_NODE}*2)+2))
                                SORT_NUM2=$((${SORT_NUM}-1))
                        else    SORT_NUM=$(( ${SORT_NODE}*2   ))
                        fi                                                                                      ;;              # Sort by column number
                d )     SORT_NUM=2                                                                              ;;              # Sort by DB name
                v )     SORT_NUM=4                                                                              ;;              # Sort by version
                s )     SORT_NUM=$(((${SORT_NODE}*2)+6))                                                        ;               # Sort by status (Shutdown, Open)
                        SORT_NUM2=$((${SORT_NUM}-1))                                                            ;;
                t )     TYPE_COL=$(cat ${TMP2} | awk 'BEGIN {FS="|"}{if ($2 ~ "Version"){print (NF-1); exit}}')  ;
                        SORT_NUM=$(((${TYPE_COL}*2)+1))                                                         ;;              # Sort by Type
                esac

		SORT_K_1=" -k"${SORT_NUM}${SORT_ORDER}" "
                SORT_K_2=" -k"${SORT_NUM2}" "
                SORT_K_3=" -k"${SORT_NUM3}" "

                cat ${TMP2} | awk 'BEGIN {FS="|"} {print $0; if ($2 ~ "Version"){getline; print $0; exit;}}' > ${TMP}
                cat ${TMP2} | awk 'BEGIN {FS="|"}{if ($2 ~ "Version"){getline; while(getline){if ($0 ~ /---------------/){break}; print $0; }}}' | sort -i ${SORT_K_1} ${SORT_K_2} ${SORT_K_3} >> ${TMP}
                tac ${TMP2} | awk '{print $0; if ($0 ~ /---------------/){exit;}}' | tac >> ${TMP}

                cp ${TMP} ${TMP2}
        fi

        if [[ "$WITH_COLORS" == "YES" ]]
        then
                cat ${TMP2}
        else
                cat ${TMP2} | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"      # Remove the colors
        fi

        printf "\n"

if [ -f ${TMP} ]
then
  if [ -n "$OUT" ]
  then
    cp $TMP $OUT
    printf "\n\t\033[1;34m%s\033[m\n\n" "Output file $OUT has been generated"
  fi
rm -f ${TMP}
fi
if [ -f ${TMP2} ]
then
  rm -f ${TMP2}
fi
}
#
#########################################################################################################
# EXADATA Verify EXADATA RAC / CLUSTER Monitor
#########################################################################################################
#
function Func_EXA_010()
{
# Fred Denis -- Jan 2019 -- http://unknowndba.blogspot.com -- fred.denis3@gmail.com
#
# A script to monitor a RAC / GI 12c using rac-status.sh (https://goo.gl/LwQC1N)
# More information on the script on https://goo.gl/EwDeKn
# See the usage function or use the -h option for more details
#
# The current version of the script is 20190118
#
# 20190118 - Fred Denis - Initial Release
#

#
# Variables
#
       REFERENCE=~/rac-status_reference                 # The reference file where is saved the good status of your cluster
       RACSTATUS=~/rac-status.sh                        # The rac-status.sh script location
             TMP="/tmp/racmontempfile$$"                # A tempfile
            TMP2="/tmp/racmontempfile2$$"               # Another tempfile
 AUTO_CREATE_REF="Yes"                                  # If yes, create the reference file if it does not exist (for first execution)
                                                        # If not yes, prompt about this and exit
#
# Email alerting
#
         EMAILTO="youremail@company.com"                # The email to send the alert to
EMAIL_ON_FAILURE="No"                                   # Default behavior to send an email if an error is detected (-e option) - put Yes to always send emails
EMAIL_ON_SUCCESS="No"                                   # Default behavior to send an email even if no error is detected (-s option) - put Yes to always send emails
FAILURE_SUBJECT="Error : Cluster status at "$(date)      # Subject of the email sent
SUCCESS_SUBJECT="OK : Cluster status at "$(date)         # Subject of the email sent

#
# usage function
#
usage()
{
printf "\n\033[1;37m%-8s\033[m\n" "NAME"                ;
cat << END
  $(basename $0) - A quick and efficient RAC/GI 12c monitoring tool based on rac-status.sh (https://goo.gl/LwQC1N)
END

printf "\n\033[1;37m%-8s\033[m\n" "SYNOPSIS"            ;
cat << END
  $0 [-e] [-s] [-h]
END

printf "\n\033[1;37m%-8s\033[m\n" "DESCRIPTION"         ;
cat << END
  $(basename $0) needs the rac-status.sh script to be downloaded and working (https://goo.gl/LwQC1N)

  $(basename $0) executes rac-status.sh -a and compares its output with a previously saved good status of your cluster
  If no reference file exists, $(basename $0) will create it for you at the location pointed by the REFERENCE variable.

  If $(basename $0) finds differences betwen the current status of the cluster and the good status from the reference file,
  you will be prompted about it and $(basename $0) will exit 1. If no difference found, you will be prompted about it and $(basename $0) will exit 0.

  $(basename $0) can also send emails about this depending on the -e and -s option as well as the EMAIL_ON_FAILURE and EMAIL_ON_SUCCESS variables.
END

printf "\n\033[1;37m%-8s\033[m\n" "OPTIONS"             ;
cat << END
  -e      Sends an email to the email(s) defined in the EMAILTO parameter if an issue has been detected in the cluster
  -s      Sends an email to the email(s) defined in the EMAILTO parameter on success (even if no error has been detected)

  If you want to modify the script default to always send emails and not have to specify -e or -s,
  just change the values of these parameters on top of the script like this:
    EMAIL_ON_FAILURE="Yes"
    EMAIL_ON_SUCCESS="Yes"

  -h      Show this help

END

exit 567
}

#
# Command line options
#
while getopts "esh" OPT; do
        case ${OPT} in
        e)         EMAIL_ON_FAILURE="Yes"                               ;;
        s)         EMAIL_ON_SUCCESS="Yes"                               ;;
        h)         usage                                                ;;
        \?)        echo "Invalid option: -$OPTARG" >&2; usage           ;;
        esac
done

#
# Variables verification
#
if [ ! -x ${RACSTATUS} ]
then
  cat << !
  Cannot find $RACSTATUS or $RACSTATUS is not executable; the rac-status.sh script is needed and needs to be executable to run this script, to fix this issue:
  - Please have a look at https://goo.gl/LwQC1N and downloada rac-status.sh
  - Adjust the RACSTATUS variable on top of this script to point to the location you saved rac-status.sh
  - Make $RACSTATUS executable:
  $ chmod u+x $RACSTATUS
!
  exit 456
fi
if [ ! -f ${REFERENCE} ]                                                                # No reference file, we cannot continue
then
        if [ "${AUTO_CREATE_REF}" = "Yes" ]
        then    # Reference file does not exist, we create it
                printf "\t%s" "No reference file found at $REFERENCE, creating it . . ."
                $RACSTATUS -a > $REFERENCE
                if [ $? -eq 0 ]
                then
                        printf "\t\033[1;32m%-8s\033[m\n" "OK"          ;
                else
                        printf "\t\033[1;31m%-8s\n" "Error $ERR"          ;
                        printf "%s\033[m\n" "Could not create $REFERENCE using $RACSTATUS -a > $REFERENCE; cannot continue."
                        exit 444
                fi
        else
        cat << !
                Cannot find the ${REFERENCE} file. A status reference file is needed to be able to compare the current status of the cluster with
                Please initialize this reference file as below:
                $ $RACSTATUS -a > $REFERENCE
!
                exit 123
        fi
fi

#
# Check the current status of the cluster
#
${RACSTATUS} -a > ${TMP}
if [ $? -ne 0 ]
then
        cat << !
        There was an error executing ${RACSTATUS}, please try executing it manually first and reach out to the author if it doesn't work.
!
fi

#
# Check for any difference between the reference file $REFERENCE and the current status from $TMP
#
diff ${REFERENCE} ${TMP} > ${TMP2} 2>&1
if [ $? -eq 0 ]
then                            # All good
        cat << !
        No change has been identified across the cluster, all good !
!
        if [ "${EMAIL_ON_SUCCESS}" = "Yes" ]
        then
                printf "\t%s" "Sending en email to " ${EMAILTO} " . . ."
                echo "No change has been identified across the cluster, all good !" | mailx -s "${SUCCESS_SUBJECT}" ${EMAILTO}
                if [ $? -eq 0 ]
                then
                        printf "\t\033[1;32m%-8s\033[m\n" "OK"          ;
                else
                        printf "\t\033[1;31m%-8s\n" "Error $ERR"          ;
                        printf "%s\033[m\n" "There was an issue sending an email using mailx -s ${SUCCESS_SUBJECT} ${EMAILTO}"
                        exit 555
                fi
        fi
        RET=0
else                            # Something is wrong, we send an email about it
        cat << !
        The below changes have been identified across the cluster:
!
        cat ${TMP2}
        if [ "${EMAIL_ON_FAILURE}" = "Yes" ]
        then
                printf "\t%s" "Sending en email to " ${EMAILTO} " . . ."
                # Remove colors from the file before sending the email
                cat ${TMP2} | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" | mailx -s "${FAILURE_SUBJECT}" ${EMAILTO}
                if [ $? -eq 0 ]
                then
                        printf "\t\033[1;32m%-8s\033[m\n" "OK"          ;
                else
                        printf "\t\033[1;31m%-8s\n" "Error $ERR"          ;
                        printf "%s\033[m\n" "There was an issue sending an email using mailx -s ${FAILURE_SUBJECT} ${EMAILTO}"
                        exit 666
                fi
        fi
        RET=1
fi

#
# Delete the tempfiles
#
for F in ${TMP} ${TMP2}
do
  if [ -f ${F} ]
  then
    rm -f ${F}
  fi
done
exit ${RET}
}
#
#
#########################################################################################################
# EXADATA Verify Exadata RAC on All DB
#########################################################################################################
#
function Func_EXA_011()
{
#
# Fred Denis -- Nov 2017 -- http://unknowndba.blogspot.com -- fred.denis3@gmail.com
#
# Execute a SQL command on all databases wherever they have an instance opened
# -- The node where this script is executed should have ssh key deployed to all the other database nodes
# -- oraenv should be working on every server
# -- Look for "Query customization" to customize your query
#
# More information here : https://unknowndba.blogspot.com.au/2018/04/rac-onalldbsh-easily-execute-query-on.html
#
# Version of the script is 20180318
#

#
# Set the default output to 90% of the screen size
#
COLS=$(printf %.f $(bc <<< "$(tput cols)*.9"))

#
# If for any reason we couldn't get the number of cols, we set it to 120
#
if ! [[ $COLS =~ ^[0-9]+$ ]]
then
        COLS=120         # Size of the output
fi

COLS=120        # Not sure the above dynamic output is useful here, set COLS to 120 for now
                # Comment this line if you want the output to be dynamic

#
# Set the ASM env to be able to use crsctl commands
#
ORACLE_SID=$(ps -ef | grep pmon | grep asm | awk '{print $NF}' | sed s'/asm_pmon_//' | egrep "^[+]")

export ORAENV_ASK=NO
. oraenv > /dev/null 2>&1


for X in $(crsctl stat res -v -w "TYPE = ora.database.type" | awk ' BEGIN {FS="="}
   {
      if (($1 ~ /^NAME/) && ($0 ~ //))
      {
              sub("^ora.", "", $2)                                                            ;
              sub(".db$" , "", $2)                                                            ;
              DB=$2                                                                           ;
              while(getline)
              {
                      if (($1 ~ /STATE/) && ($2 ~/ONLINE/))
                      {
                              gsub (".*on ",  "", $2)                                         ;
                              print DB"|"$2                                                   ;
                              next                                                            ;
                      }
              }
      }
  }')
do
              DB=$(echo $X | awk -F "|" '{print $1}')
          SERVER=$(echo $X | awk -F "|" '{print $2}')
        INSTANCE=${DB}$(echo "${SERVER: -1}")

        printf "\n\n\t\t\033[1;37m%30s\033[m\n" "Query Result on $INSTANCE@$SERVER"

        (ssh -q -o batchmode=yes oracle@${SERVER}  << END_SSH 2> /dev/null
                . oraenv <<< ${DB} > /dev/null 2>&1
                export ORACLE_SID=${INSTANCE}
                sqlplus -S / as sysdba << END_SQL
                set lines       $COLS                                                                   ;

                --------------------------------
                -- Query customization        --
                --------------------------------

                set echo        off                                                                     ;
                set term        off                                                                     ;
                set wrap        on                                                                      ;
                col name        for a50                                                                 ;
                col value       for a60                                                                 ;
                col host_name   for a26                                                                 ;
                col instance_name for a18                                                               ;
                set pages       5000                                                                    ;
                alter session set nls_date_format='DD/MM/YYYY HH24:MI:SS'                               ;
                select instance_name, host_name, version, sysdate from v\\\$instance                    ;
                -- select name, value from v\\\$parameter where name like '%exafusion%'                 ;
                select name, value from v\\\$parameter order by name                                    ;

                --------------------------------
                -- End of query customization --
                --------------------------------
END_SQL
END_SSH
) | grep -v logout | grep -v altered | grep -v profile | tail -n +3 | awk -v COLS="$COLS"    ' BEGIN \
      {  # some colors
         COLOR_BEGIN =       "\033[1;"                                      ;
           COLOR_END =       "\033[m"                                       ;
                 RED =       "31m"                                          ;
               GREEN =       "32m"                                          ;
              YELLOW =       "33m"                                          ;
                BLUE =       "34m"                                          ;
                TEAL =       "36m"                                          ;
               WHITE =       "37m"                                          ;

            print_a_line()                                                  ;
      }
      function print_a_line()
      {
            printf("%s", COLOR_BEGIN BLUE)                                  ;
            for (k=1; k<3    ; k++) {printf("%s", " ")}                     ;
            for (k=3; k<=COLS; k++) {printf("%s", "-")}                     ;
            printf("%s\n", COLOR_END)                                       ;
      }
      {
            printf(COLOR_BEGIN BLUE " %1s" COLOR_END "%-118s\n", "|\t", $0) ;
      }
      END\
      {     
        print_a_line()                                                  ;
      }
    '
done
}









27 oracle dba scripts for Oracle Database for Administration and Monitoring
July 2, 2022 by techgoeasy 2 Comments

We often need to monitor the oracle database session for performance reason, check for locks,get location of datafiles, redo files , get the information about db_links .Here are Top oracle dba scripts  for Oracle  Database for Administrative and Monitoring purpose

Script to find the sid of the session you are logged in as

select distinct(sid) from v$mystat;
Script to see all active session

select username,osuser,sid,serial#, program,sql_hash_value,module from v$session where username is not null
and status ='ACTIVE' and module is not null;
Script to see waiters

set linesize 1000
column waiting_session heading ‘WAITING|SESSION’
column holding_session heading ‘HOLDING|SESSION’
column lock_type format a15
column mode_held format a15
column mode_requested format a15select
waiting_session,
holding_session,
lock_type,
mode_held,
mode_requested,
lock_id1,
lock_id2
from
dba_waiters
/
Script to how active transaction in the database

col RBS format a15 trunc
col SID format 9999
col USER format a15 trunc
col COMMAND format a60 trunc
col status format a8 trunc
select r.name "RBS", s.sid, s.serial#, s.username "USER", t.status,
t.cr_get, t.phy_io, t.used_ublk, t.noundo,
substr(s.program, 1, 78) "COMMAND"
from v$session s, v$transaction t, v$rollname r
where t.addr = s.taddr
and t.xidusn = r.usn
order by t.cr_get, t.phy_io
/
Script to monitor the long running queries

set linesize 1000
select
OPNAME,
sid,SOFAR/TOTALWORK*100,
to_char(start_time,'dd-mon-yy hh:mi') started,
elapsed_seconds/60,time_remaining/60
from
v$session_longops
where
sid =&sid
Script to see all lock objects

set term on;
set lines 130;
column sid_ser format a12 heading 'session,|serial#';
column username format a12 heading 'os user/|db user';
column process format a9 heading 'os|process';
column spid format a7 heading 'trace|number';
column owner_object format a35 heading 'owner.object';
column locked_mode format a13 heading 'locked|mode';
column status format a8 heading 'status';
select
substr(to_char(l.session_id)||','||to_char(s.serial#),1,12) sid_ser,
substr(l.os_user_name||'/'||l.oracle_username,1,12) username,
l.process,
p.spid,
substr(o.owner||'.'||o.object_name,1,35) owner_object,
decode(l.locked_mode,
1,'No Lock',
2,'Row Share',
3,'Row Exclusive',
4,'Share',
5,'Share Row Excl',
6,'Exclusive',null) locked_mode,
substr(s.status,1,8) status
from
v$locked_object l,
all_objects o,
v$session s,
v$process p
where
l.object_id = o.object_id
and l.session_id = s.sid
and s.paddr = p.addr
and s.status != 'KILLED'
/
Script to see waits events

set linesize 1000
column sid format 999
column username format a15 wrapped
column spid format a8
column event format a30 wrapped
column osuser format a12 wrapped
column machine format a25 wrapped
column program format a30 wrapped
select sw.sid sid
, p.spid spid
, s.username username
, s.osuser osuser
, sw.event event
, s.machine machine
, s.program program
from v$session_wait sw
, v$session s
, v$process p
where s.paddr = p.addr
and event not in ('pipe get','client message')
and sw.sid = s.sid
/
Script to see particular session waits

select sid,seq#,wait_time,event,seconds_in_wait,state from v$session_wait where sid in (&sid);
Script to see all user accessing that objects

column object format a30
column owner format a10
select * from v$access where object='&object_name'
/
Script gives information about the user sessions locking a particular object

set linesize 1000
column program format a15
column object format a15
select substr(username||'('|| se0.sid||')',1,5) "User Session",
substr(owner,1,5) "Object Owner",
substr(object,1,15) "Object",
se0.sid,
substr(serial#,1,6) "Serial#",
substr(program,1,15) "Program",
logon_time "Logon Time",
process "Unix Process"
from v$access ac, v$session se0
where ac.sid = se0.sid
and Object = '&PACKAGE'
order by logon_time,"Object Owner","Object"
/
Script to see the explain plan in Oracle for the statement in the library cache

set linesize 9999
column QUERY format a999
set pages 250
set head off
set verify off
select id,lpad(' ',2*(depth-1)) || depth ||'.' || nvl(position,0) || ' '|| operation || ' '|| options || ' '|| object_name ||' '
||'cost= '|| to_char(cost)||' '|| optimizer "QUERY"
from v$sql_plan
where hash_value = &sql_hash_value
order by child_number,id
/
Script to find server location

select nvl(username,'ORACLE SHADOW PROCESS'),
machine from
v$session where username is null
and rownum < 2
/
Script to see the top sort segment usage

col sid format 999999
col spid format a6
col tablespace format a10
col username format a25
col noexts format 9999 head EXTS
col proginfo format a25 trunc
col mbused format 999,999.90
col status format a1 trunc
set verify off
select * from (
select s.sid,
s.status,
b.spid,
s.sql_hash_value sesshash,
u.SQLHASH sorthash,
s.username,
u.tablespace,
sum(u.blocks*p.value/1024/1024) mbused ,
sum(u.extents) noexts,
u.segtype,
s.module || ' - ' || s.program proginfo
from v$sort_usage u, v$session s, v$parameter p, v$process b
where u.session_addr = s.saddr
and p.name = 'db_block_size'
and b.addr = s.paddr
group by s.sid,s.status,b.spid,s.sql_hash_value,u.sqlhash,s.username,u.tablespace,
u.segtype,
s.module || ' - ' || s.program
order by 8 desc,4)
where rownum < 11;
Script to check the last analyzed for the tables in sql statement

set lin 1000
set verify off
col owner format a15
col object_name format a25
col object_type format a12
col "LAST ANALYZED" format a13

 

select do.OWNER,do.OBJECT_NAME,OBJECT_TYPE,
decode (OBJECT_TYPE,'TABLE'  , (Select LAST_ANALYZED from dba_tables where owner=do.owner and TABLE_NAME=do.object_name)  ,'INDEX'  , (Select LAST_ANALYZED from dba_indexes where owner=do.owner and INDEX_NAME=do.object_name) ,'UNKNOWN') "LAST ANALYZED",STATUS
from   DBA_OBJECTS do
where  OBJECT_TYPE in ('TABLE','INDEX')
and    (OWNER,OBJECT_NAME) in (select OBJECT_OWNER,OBJECT_NAME from V$SQL_PLAN where HASH_VALUE=&1)
/
To check Library Cache locks and pin

select /*+ all_rows */ w1.sid waiting_session,
h1.sid holding_session,
w.kgllktype lock_or_pin,
w.kgllkhdl address,
decode(h.kgllkmod, 0, 'None', 1, 'Null', 2, 'Share', 3, 'Exclusive',
'Unknown') mode_held,
decode(w.kgllkreq, 0, 'None', 1, 'Null', 2, 'Share', 3, 'Exclusive',
'Unknown') mode_requested
from dba_kgllock w, dba_kgllock h, v$session w1, v$session h1
where
(((h.kgllkmod != 0) and (h.kgllkmod != 1)
and ((h.kgllkreq = 0) or (h.kgllkreq = 1)))
and
(((w.kgllkmod = 0) or (w.kgllkmod= 1))
and ((w.kgllkreq != 0) and (w.kgllkreq != 1))))
and w.kgllktype = h.kgllktype
and w.kgllkhdl = h.kgllkhdl
and w.kgllkuse = w1.saddr
and h.kgllkuse = h1.saddr
/
To check Control File location

col name  format a60 heading "Control Files"
select name
from   sys.v_$controlfile
/
To check redo log location

col Grp format 9999
col member format a50 heading "Online REDO Logs"
col File# format 9999
col name format a50 heading "Online REDO Logs"
break on Grp
select group#,member
from sys.v_$logfile
/
To check datafile location

col Tspace format a25
col status format a3 heading Sta
col Id format 9999
col Mbyte format 999999999
col name format a50 heading "Database Data Files"
col Reads format 99,999,999
col Writes format 99,999,999

break on report
compute sum label 'Total(MB)' of Mbyte on report

select F.file_id Id,
F.file_name name,
F.bytes/(1024*1024) Mbyte,
decode(F.status,'AVAILABLE','OK',F.status) status,
F.tablespace_name Tspace
from sys.dba_data_files F
order by tablespace_name;
Checking autoextend on/off for Tablespaces:

select substr(file_name,1,50), AUTOEXTENSIBLE from dba_data_files
(OR)
SQL> select tablespace_name,AUTOEXTENSIBLE from dba_data_files;
How to check Underscore parameters

SELECT X.KSPPINM NAME, DECODE(BITAND(KSPPIFLG/256, 1), 1, 'TRUE', 'FALSE') SESMOD,
DECODE( BITAND(KSPPIFLG/65536, 3), 1, 'IMMEDIATE', 2, 'DEFERRED', 3, 'IMMEDIATE', 'FALSE' ) SYSMOD,
KSPPDESC DESCRIPTION
FROM SYS.X_$KSPPI X WHERE X.INST_ID = USERENV('INSTANCE') AND
TRANSLATE(KSPPINM,'_','#') LIKE '#%' ORDER BY 1 ;
How to show DBA links

set linesize 128 pages 1000
col owner format a15
col db_link format a15
col username format a20
col host format a15
col name format a30
Prompt Database Links:
select owner, db_link, username, host from dba_db_links order by owner,db_link,username
/
Prompt Synonym Links:
select distinct owner, db_link from dba_synonyms where db_link is not null
/
Prompt Snapshot Links:
select owner, name, replace(master_link,'@','') db_link from dba_snapshots
where master_link is not null
/
Identifying the segment by DBA_extents using file-id and block

SELECT segment_name, segment_type
FROM dba_extents
WHERE file_id = < file> AND
<block> BETWEEN block_id and block_id + blocks - 1;
Listing jobs running from DBMS_SCHEDULER

SET HEADING ON
SET LINESIZE 300
SET PAGESIZE 60COLUMN owner FORMAT A20
SELECT owner,
job_name,
running_instance,
elapsed_time
FROM dba_scheduler_running_jobs
ORDER BY owner, job_name
/
Listing DBMS_SCHEDULER JOB information

SET HEADING ON
SET LINESIZE 300
SET PAGESIZE 60
COLUMN owner FORMAT A20
COLUMN next_run_date FORMAT A35
SELECT owner,
job_name,
enabled,
job_class,
next_run_date
FROM dba_scheduler_jobs
ORDER BY owner, job_name
/
How to get Historical plan for the SQL_ID from AWR

SET PAGESIZE 60
SET LINESIZE 300
SELECT * FROM TABLE(dbms_xplan.display_awr('&SQL_ID'))
/
How to do wait analysis of the database

select event, state, count(*) from v$session_wait group by event, state order by 3 desc;
How to find High Buffer gets sql 

select * from (SELECT address, hash_value,
buffer_gets, executions, buffer_gets/executions "Gets/Exec",
sql_text
FROM v$sqlarea
WHERE buffer_gets > 500000 and executions>0
ORDER BY 3 desc) where rownum <20
;
This list of oracle dba scripts for oracle database for monitoring purpose is not complete. There are many more scripts for monitoring.I will be presenting them in subsequent posts














column owner format a16
column object_name format a36
column start_day format a11
column block_increase_bytes 9999999999
select obj.owner
  , obj.object_name
  , to_char(sn.BEGIN_INTERVAL_TIME,'RRRR-MON-DD') start_day
  , sum(a.SPACE_USED_DELTA) block_increase_bytes
from dba_hist_seg_stat a,
     dba_hist_snapshot sn,
     dba_objects obj
where sn.snap_id = a.snap_id
and  obj.object_id = a.obj#
and  obj.owner in ('SYS','SYSTEM')
-- and  obj.owner not in ('SYS','SYSTEM')
-- and  end_interval_time between to_timestamp('01-JAN-2012','DD-MON-RRRR') 
-- and  to_timestamp('02-FEB-2012','DD-MON-RRRR')
group by obj.owner, obj.object_name, to_char(sn.BEGIN_INTERVAL_TIME,'RRRR-MON-DD')
order by obj.owner, obj.object_name;






select so.owner
  , so.object_name
  , ss.space_allocated_total/1024/1024
  , ss.space_allocated_delta/1024/1024
  , i.begin_interval_time
from dba_hist_Seg_stat ss, dba_hist_snapshot i, dba_hist_seg_stat_obj so
where ss.snap_id = i.snap_id
and so.object_type = 'TABLE'
and i.begin_interval_time >= trunc(sysdate -7)
and ss.obj# = so.obj#
and ss.dataobj# = so.dataobj#
and ss.space_allocated_delta <> 0
order by 1, 2, 5;




select * from
(SELECT o.OWNER , o.OBJECT_NAME , o.SUBOBJECT_NAME , o.OBJECT_TYPE ,
    t.NAME "Tablespace", s.growth/(1024*1024) "Growth in MB",
    (SELECT sum(bytes)/(1024*1024*1024)
    FROM dba_segments
    WHERE segment_name=o.object_name) "Total Size(GB)"
FROM DBA_OBJECTS o,
    ( SELECT TS#,OBJ#, SUM(SPACE_USED_DELTA) growth
   FROM DBA_HIST_SEG_STAT
    GROUP BY TS#,OBJ#
    HAVING SUM(SPACE_USED_DELTA) > 0
    ORDER BY 2 DESC ) s,
    v$tablespace t
WHERE s.OBJ# = o.OBJECT_ID
AND s.TS#=t.TS# 
and o.owner='SYS' 
and o.object_type='TABLE'
ORDER BY 6 DESC) where rownum<20;





select so.owner
  , so.object_name
--  , so.subobject_name
  , so.object_type
  , so.tablespace_name
  , round(sum(ss.space_used_delta)/1024/1024) growth_mb
from dba_hist_seg_stat ss
  , dba_hist_seg_stat_obj so
where ss.obj# = so.obj#
and ss.dataobj# = so.dataobj#
and so.owner != '** MISSING **' -- segments already gone
and so.object_name not like 'BIN$%' -- recycle-bin
and so.object_type = 'TABLE'
and ss.snap_id > (select min(sn.snap_id) from dba_hist_snapshot sn where sn.dbid = (select dbid from v$database) and sn.end_interval_time > trunc(sysdate) - &DAYS_BACK)
group by so.owner
  , so.object_name
-- , so.subobject_name
  , so.object_type
  , so.tablespace_name
order by 5 desc;












col ts_mb for 999,999,999,999.90
col max_mb for 999,999,999,999.90
col used_mb for 999,999,999,999.90
col last_mb for 999,999,999,999.90
col incr for 999,999.90
  select * from (
  select v.name
,        v.ts#
,        s.instance_number
,        h.tablespace_size
       * p.value/1024/1024              ts_mb
,        h.tablespace_maxsize
       * p.value/1024/1024              max_mb
,        h.tablespace_usedsize
       * p.value/1024/1024              used_mb
,        to_date(h.rtime, 'MM/DD/YYYY HH24:MI:SS') resize_time
,        lag(h.tablespace_usedsize * p.value/1024/1024, 1, h.tablespace_usedsize * p.value/1024/1024)
         over (partition by v.ts# order by h.snap_id) last_mb
,        (h.tablespace_usedsize * p.value/1024/1024)
       - lag(h.tablespace_usedsize * p.value/1024/1024, 1, h.tablespace_usedsize * p.value/1024/1024)
         over (partition by v.ts# order by h.snap_id) incr
    from dba_hist_tbspc_space_usage     h
,        dba_hist_snapshot              s
,        v$tablespace                   v
,        dba_tablespaces                t
,        v$parameter                    p
   where h.tablespace_id                = v.ts#
     and v.name                         = t.tablespace_name
     and t.contents                not in ('UNDO', 'TEMPORARY')
     and p.name                         = 'db_block_size'
     and h.snap_id                      = s.snap_id
         /* For a specific time */
     and s.begin_interval_time          > sysdate - 1/12
         /* For a specific tablespace */
     and v.ts# = 1
order by v.name, h.snap_id asc)
   where incr > 0;











break on resized
    with ts_history as (
  select * from (
  select v.name
,        v.ts#
,        s.instance_number
,        h.tablespace_size
       * p.value/1024/1024              ts_mb
,        h.tablespace_maxsize
       * p.value/1024/1024              max_mb
,        h.tablespace_usedsize
       * p.value/1024/1024              used_mb
,        to_date(h.rtime, 'MM/DD/YYYY HH24:MI:SS') resize_time
,        lag(h.tablespace_usedsize * p.value/1024/1024, 1, h.tablespace_usedsize * p.value/1024/1024)
         over (partition by v.ts# order by h.snap_id) last
,        (h.tablespace_usedsize * p.value/1024/1024)
       - lag(h.tablespace_usedsize * p.value/1024/1024, 1, h.tablespace_usedsize * p.value/1024/1024)
         over (partition by v.ts# order by h.snap_id) incr
    from dba_hist_tbspc_space_usage     h
,        dba_hist_snapshot              s
,        v$tablespace                   v
,        dba_tablespaces                t
,        v$parameter                    p
   where h.tablespace_id                = v.ts#
     and v.name                         = t.tablespace_name
     and t.contents                not in ('UNDO', 'TEMPORARY')
     and p.name                         = 'db_block_size'
     and h.snap_id                      = s.snap_id
order by v.name, h.snap_id asc)
   where incr > 0)
  select to_char(resize_time, 'YYYY-MM') as resized
,        name
,        sum(incr)                      incr
    from ts_history
group by name
,        to_char(resize_time, 'YYYY-MM')
order by 1, 3 desc;








column "Percent of Total Disk Usage" justify right format 999.99 
column "Space Used (MB)" justify right format 9,999,999.99 
column "Total Object Size (MB)" justify right format 9,999,999.99 
select * from 
  (select to_char(end_interval_time
     , 'MM/DD/YY') mydate
     , sum(space_used_delta)/1024/1024 "Space used (MB)"
     , avg(c.bytes)/1024/1024 "Total Object Size (MB)"
     , round(sum(space_used_delta)/sum(c.bytes) * 100, 2) "Percent of Total Disk Usage" 
   from dba_hist_snapshot sn
     ,  dba_hist_seg_stat a
     ,  dba_objects b
     ,  dba_segments c 
where begin_interval_time > trunc(sysdate) - 7
and sn.snap_id = a.snap_id 
and b.object_id = a.obj# 
and b.owner = c.owner 
and b.object_name = c.segment_name 
and c.segment_name = 'RIBAS'   -- HERE CAME THE NAME OF THE TABLE
group by to_char(end_interval_time, 'MM/DD/YY')) 
order by to_date(mydate, 'MM/DD/YY');





set feedback on 
select * from (select c.TABLESPACE_NAME,c.segment_name "Object Name", b.object_type, sum(space_used_delta) / 1024 / 1024 "Growth (MB)" from dba_hist_snapshot sn, 
dba_hist_seg_stat a, 
dba_objects b, 
dba_segments c 
where begin_interval_time > trunc(sysdate) – &days_back 
and sn.snap_id = a.snap_id 
and b.object_id = a.obj# 
and b.owner = c.owner 
and b.object_name = c.segment_name 
and c.owner ='SYS'
group by c.TABLESPACE_NAME,c.segment_name,b.object_type) 
order by 3 asc;







col nm for a30
SELECT to_char(s.end_interval_time,'dd/mm/yyyy hh24:mi:ss') as time
  , t.snap_id
  , obj#
  , (select object_name from user_objects where object_id = obj#) as nm
  , space_used_delta
  , space_allocated_delta/1024/1024 as mb
FROM dba_hist_seg_stat t
  , dba_hist_snapshot s
  , dba_objects o
WHERE t.snap_id = s.snap_id
AND s.snap_id = (select max(snap_id) from dba_hist_snapshot)
AND obj#=o.object_id
AND object_id IN (select object_id from user_objects where object_name in ('RIBAS','RIBAS_2','RIBAS_3','TESTE'));








SELECT LAST_DDL_TIME
  , TIMESTAMP
  , OBJECT_NAME
  , object_type
FROM DBA_OBJECTS 
WHERE OBJECT_TYPE NOT IN ('TABLE', 'INDEX', 'TABLE PARTITION', 'INDEX PARTITION', 'JOB', 'TABLE SUBPARTITION', 'LOB', 'INDEX SUBPARTITION', 'LOB PARTITION') 
ORDER BY TIMESTAMP;






























/*
 Script para gerar uma matriz com a contagem de execucoes do SQL ID por dia e hora
 Sintaxe: SQL>@execs <SQL_ID> <Qtd. Dias> <Inst ID> (Onde Inst ID = 0 soma todas as instancias do cluster)
 Exemplo: SQL>@execs @execs c3bpu9sapxhpw 10 1 
 
 Maicon Carneiro | Salvador-BA, 11/11/2022
*/
set verify off
set feedback off
alter session set nls_date_format='dd/mm Dy';
set sqlformat 
set pages 999 lines 400
col snap_date heading "Date" format a10
col h0  format 999,999
col h1  format 999,999
col h2  format 999,999
col h3  format 999,999
col h4  format 999,999
col h5  format 999,999
col h6  format 999,999
col h7  format 999,999
col h8  format 999,999
col h9  format 999,999
col h10 format 999,999
col h11 format 999,999
col h12 format 999,999
col h13 format 999,999
col h14 format 999,999
col h15 format 999,999
col h16 format 999,999
col h17 format 999,999
col h18 format 999,999
col h19 format 999,999
col h20 format 999,999
col h21 format 999,999
col h22 format 999,999
col h23 format 999,999
set feedback ON
-- obtem o nome da instancia
column NODE new_value VNODE 
SET termout off
SELECT CASE WHEN &3 = 0 THEN 'Cluster' ELSE instance_name || ' / ' || host_name END AS NODE FROM GV$INSTANCE WHERE (&3 = 0 or inst_id = &3);
SET termout ON
-- resumo do relatorio
PROMP
PROMP Metrica...: Executions
PROMP SQL ID....: &1
PROMP Qt. Dias..: &2 
PROMP Instance..: &VNODE
PROMP
-- query
with awr as (
  select a.sql_id, a.snap_id, b.begin_interval_time as begin_snap,
         sum(executions_delta)                                            as execs,
         sum(elapsed_time_delta/1000) / greatest(sum(executions_delta),1) as Elapsed_Time
    from dba_hist_sqlstat a
    join dba_hist_snapshot b on (a.snap_id = b.snap_id and a.instance_number = b.instance_number)
    where 1=1
    and sql_id in ('&1')
    --and executions_delta > 0
    and (&3 = 0 or b.instance_number = &3)
    and b.begin_interval_time >= trunc(sysdate) - &2
    group by a.sql_id, a.snap_id, b.begin_interval_time
)
SELECT TRUNC(begin_snap) snap_date,
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '00', execs, null)) "h0",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '01', execs, null)) "h1",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '02', execs, null)) "h2",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '03', execs, null)) "h3",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '04', execs, null)) "h4",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '05', execs, null)) "h5",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '06', execs, null)) "h6",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '07', execs, null)) "h7",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '08', execs, null)) "h8",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '09', execs, null)) "h9",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '10', execs, null)) "h10",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '11', execs, null)) "h11",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '12', execs, null)) "h12",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '13', execs, null)) "h13",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '14', execs, null)) "h14",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '15', execs, null)) "h15",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '16', execs, null)) "h16",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '17', execs, null)) "h17",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '18', execs, null)) "h18",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '19', execs, null)) "h19",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '20', execs, null)) "h20",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '21', execs, null)) "h21",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '22', execs, null)) "h22",
 SUM (DECODE (TO_CHAR (begin_snap, 'hh24'), '23', execs, null)) "h23"
FROM awr
GROUP BY TRUNC(begin_snap)
order by 1;
Exemplo de uso:

SQL> @execs <SQL ID> <days> <inst_id>




Em inst_id, deve ser informando um número de instância do RAC (1,2,3,4, etc). Para considerar todas as instâncias do cluster (equivalente a um AWR Global), informe o valor 0.

Demonstração abaixo com imagem cortada para melhorar visualização no blog:

Neste exemplo, estou gerando uma matriz para o SQL ID 2a5z3x7187rxz com os últimos 30 dias de AWR, considerando as métricas globais do RAC (inst_id = 0)


Com a visão acima, é possível observar rapidamente que o SQL_ID é executado praticamente durante todas as 24h do dia, mas tem um volume muito maior a partir das 7h da manhã, e aumento ainda mais a partir das 10h.

2) Matriz com o tempo médio de execução do SQL por Data e Hora

script: elap.sql

/*
 Script para gerar uma matriz com o tempo medio de execucoes do SQL ID por dia e hora
 Sintaxe: SQL>@elap <SQL_ID> <Qtd. Dias> <Inst ID> <medida> (Onde Inst ID = 0 soma todas as instancias do cluster)
 "medida" pode ser 'ms' para Milisegundos, 'sec' para segundos ou 'min' para minutos
 Exemplo: SQL>@execs c3bpu9sapxhpw 10 1 ms
 
 Maicon Carneiro | Salvador-BA, 11/11/2022
*/
set feedback off
alter session set nls_date_format='dd/mm Dy';
set sqlformat 
set pages 999 lines 400
col snap_date heading "Date" format a10
col h0  format 999.99
col h1  format 999.99
col h2  format 999.99
col h3  format 999.99
col h4  format 999.99
col h5  format 999.99
col h6  format 999.99
col h7  format 999.99
col h8  format 999.99
col h9  format 999.99
col h10 format 999.99
col h11 format 999.99
col h12 format 999.99
col h13 format 999.99
col h14 format 999.99
col h15 format 999.99
col h16 format 999.99
col h17 format 999.99
col h18 format 999.99
col h19 format 999.99
col h20 format 999.99
col h21 format 999.99
col h22 format 999.99
col h23 format 999.99
set feedback ON
-- obtem o nome da instancia
column NODE new_value VNODE 
SET termout off
SELECT CASE WHEN &3 = 0 THEN 'Cluster' ELSE instance_name || ' / ' || host_name END AS NODE FROM GV$INSTANCE WHERE (&3 = 0 or inst_id = &3);
SET termout ON
DEFINE vMedida = "'&4'";
-- resumo do relatorio
PROMP
PROMP Metrica...: Average Elapsed Time (&vMedida)
PROMP SQL ID....: &1
PROMP Qt. Dias..: &2 
PROMP Instance..: &VNODE
PROMP
-- query
with awr as (
 select sql_id,
        snap_id,
        begin_snap,
        hora,
        sum(elapsed_time)/greatest(sum(executions),1) as elapsed_time_avg        
 from (
   select a.sql_id,
          a.snap_id,         
          trunc(b.begin_interval_time)           as begin_snap,
          to_char(b.begin_interval_time, 'hh24') as hora,
           sum(executions_delta)                  as executions,
          sum(case when  &vMedida = 'ms'  then elapsed_time_delta/1000 
                   when  &vMedida = 'sec' then elapsed_time_delta/1000000 
                   when  &vMedida = 'min' then elapsed_time_delta/1000000/60
                   else elapsed_time_delta
              end
            ) as elapsed_time
      from dba_hist_sqlstat a
      join dba_hist_snapshot b on (a.snap_id = b.snap_id and a.dbid = b.dbid and a.instance_number = b.instance_number)
     where 1=1
       and sql_id in ('&1')
       and executions_delta > 0
       and (&3 = 0 or b.instance_number = &3)
       and b.begin_interval_time >= trunc(sysdate) - &2
 group by a.sql_id,
          a.snap_id,         
          trunc(b.begin_interval_time),
          TO_CHAR (b.begin_interval_time, 'hh24')
 )
 group by sql_id,
          snap_id,
          begin_snap,
          hora
)
SELECT TRUNC(begin_snap) snap_date,
       max (DECODE (hora, '00', elapsed_time_avg, null)) "h0",
       max (DECODE (hora, '01', elapsed_time_avg, null)) "h1",
       max (DECODE (hora, '02', elapsed_time_avg, null)) "h2",
       max (DECODE (hora, '03', elapsed_time_avg, null)) "h3",
       max (DECODE (hora, '04', elapsed_time_avg, null)) "h4",
       max (DECODE (hora, '05', elapsed_time_avg, null)) "h5",
       max (DECODE (hora, '06', elapsed_time_avg, null)) "h6",
       max (DECODE (hora, '07', elapsed_time_avg, null)) "h7",
       max (DECODE (hora, '08', elapsed_time_avg, null)) "h8",
       max (DECODE (hora, '09', elapsed_time_avg, null)) "h9",
       max (DECODE (hora, '10', elapsed_time_avg, null)) "h10",
       max (DECODE (hora, '11', elapsed_time_avg, null)) "h11",
       max (DECODE (hora, '12', elapsed_time_avg, null)) "h12",
       max (DECODE (hora, '13', elapsed_time_avg, null)) "h13",
       max (DECODE (hora, '14', elapsed_time_avg, null)) "h14",
       max (DECODE (hora, '15', elapsed_time_avg, null)) "h15",
       max (DECODE (hora, '16', elapsed_time_avg, null)) "h16",
       max (DECODE (hora, '17', elapsed_time_avg, null)) "h17",
       max (DECODE (hora, '18', elapsed_time_avg, null)) "h18",
       max (DECODE (hora, '19', elapsed_time_avg, null)) "h19",
       max (DECODE (hora, '20', elapsed_time_avg, null)) "h20",
       max (DECODE (hora, '21', elapsed_time_avg, null)) "h21",
       max (DECODE (hora, '22', elapsed_time_avg, null)) "h22",
       max (DECODE (hora, '23', elapsed_time_avg, null)) "h23"
 FROM awr
GROUP BY TRUNC(begin_snap)
order by 1;



Para simplificar o uso do script “elap.sql”, criei mais 3 scripts auxiliares para usar separatemente quando preciso de uma visualização em milisegundos, segundos ou minutos.

elapms.sql

-- executa o script elap.sql com os parametros <SQL_ID> <DIAS> <INST_ID> ms
@elap &1 &2 &3 ms
elapsec.sql

-- executa o script elap.sql com os parametros <SQL_ID> <DIAS> <INST_ID> sec
@elap &1 &2 &3 sec
elapmin.sql

-- executa o script elap.sql com os parametros <SQL_ID> <DIAS> <INST_ID> min
@elap &1 &2 &3 min
Exemplos de uso.

Em Milisegundos (ms):

SQL> @elapms <SQL_ID> <days> <inst_id>
Em segundos:

SQL> @elapsec <SQL_ID> <days> <inst_id>
Em minutos:

SQL> @elapmin <SQL_ID> <days> <inst_id>
O exemplo abaixo é uma demonstração da visualização para o SQL ID 2a5z3x7187rxz em segundos, com 30 dias de AWR, considerando todas as instâncias do cluster (inst_id = 0):


Com a visão acima, é possivel observar rapidamente que o SQL_ID teve um tempo médio de execução menor a partir das 7h da manhã nos últimos dias, e que este comportamento começou a partir do dia 25/02/2023.

Tendo identificado um padrão como este não explica o que aconteceu em si, mas dá uma direção sobre quais períodos eu precisaria analisar com mais detalhes, por exemplo: Comparar um AWR do dia 03/03/2023 de 07 à 08h com um AWR do dia 24/02/2023 no mesmo periodo.
