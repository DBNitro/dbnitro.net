#
Author="Andre Augusto Ribas"
SoftwareVersion="1.0.3"
DateCreation="18/08/2021"
DateModification="03/03/2022"
EMAIL_1="dba.ribas@gmail.com"
EMAIL_2="andre.ribas@icloud.com"
WEBSITE="http://dbnitro.net"
#
function SepLine() 
{
  printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -  
}
#
function SetClear()
{
  printf "\033c"
}
#
function DBA_HELP() {
SetClear
SepLine
echo -e "\
|#[ DBA_001 ] DBA: VERIFY DATABASE VERSION                            |#|[ DBA_002 ] DBA: VERIFY INSTALLED PATCHES - DETAILS      |#|
|#[ DBA_003 ] DBA: INSTANCE INFORMATION + PGA & SGA                   |#|[ DBA_004 ] DBA: GENERAL TUNING VIEW                     |#|
|#[ DBA_005 ] DBA: DATABASE GROWN ON LASTS MONTHS                     |#|[ DBA_006 ] DBA: CONNECTIONS AVERAGE PER HOUR            |#|
|#[ DBA_007 ] DBA: TOP 20 DB-CPU ACTIVITY                             |#|[ DBA_008 ] DBA: VERIFY SESSIONS PER MEMORY              |#|
|#[ DBA_009 ] DBA: DATABASE SIZE                                      |#|[ DBA_010 ] DBA: VERIFY SESSIONS PER I/O                 |#|
|#[ DBA_011 ] DBA: HIT RATIO THE LASTS 30 DAYS                        |#|[ DBA_012 ] DBA: VERIFY LONG OPERATIONS                  |#|
|#[ DBA_013 ] DBA: INVALIDS OBJECTS [ @ ]                             |#|[ DBA_014 ] DBA: JOBS CONTROL OF THE CLIENT [ @ ]        |#|
|#[ DBA_015 ] DBA: MATERIALIZEDS VIEWS DISABLED                       |#|[ DBA_016 ] DBA: VERIFY RUNNING JOBS                     |#| 
|#[ DBA_017 ] DBA: KILL A RUNNING SESSION [ @ ]                       |#|[ DBA_018 ] DBA: VERIFY PROFILE INFORMATION              |#| 
|#[ DBA_019 ] DBA: BACKUP STATISTICS                                  |#|[ DBA_020 ] DBA: QTD OF ARCHIVES PER HOUR                |#| 
|#[ DBA_021 ] DBA: LAST FILE OF LAST BACKUP ARCH - RMAN               |#|[ DBA_022 ] DBA: LAST FILE OF LAST BACKUP FULL - RMAN    |#| 
|#[ DBA_023 ] DBA: ARCHIVES GENERATED PER DAY                         |#|[ DBA_024 ] DBA: BACKUP LOG OF LAST BACKUP FULL - RMAN   |#| 
|#[ DBA_025 ] DBA: BACKUP LOG OF LASTS ARCHIVES - RMAN                |#|[ DBA_026 ] DBA: ERRORS ON ALERT LOG FILE                |#| 
|#[ DBA_027 ] DBA: ORACLE ENTERPRISE MANAGER ALERT                    |#|[ DBA_028 ] DBA: CAPTURE STATISTICS OF DATA DICTIONARY   |#| 
|#[ DBA_029 ] DBA: CAPTURE STATISTICS OF ALL DATABASE                 |#|[ DBA_030 ] DBA: BLOCKING LOCKS                          |#| 
|#[ DBA_031 ] DBA: LOCKED OBJECTS                                     |#|[ DBA_032 ] DBA: BLOCKING LOCKS [ SUMARY ]               |#| 
|#[ DBA_033 ] DBA: BLOCKING LOCKS [ USER DETAILS ]                    |#|[ DBA_034 ] DBA: BLOCKING LOCKS [ WAITING SQL ]          |#| 
|#[ DBA_035 ] DBA: LOCKED OBJECTS [ DETAILS ]                         |#|[ DBA_036 ] DBA: DML AND DDL LOCKS                       |#| 
|#[ DBA_037 ] DBA: DML TABLE LOCKS TIME                               |#|[ DBA_038 ] DBA: VERIFY SESSIONS [ @ ]                   |#| 
|#[ DBA_039 ] DBA: TOP 20 DATABASE SESSIONS                           |#|[ DBA_040 ] DBA: VERIFY TABLESPACES                      |#| 
|#[ DBA_041 ] DBA: VERIFY STATISTICS - TABLES [ @ ]                   |#|[ DBA_042 ] DBA: VERIFY STATISTICS - INDEXES [ @ ]       |#| 
|#[ DBA_043 ] DBA: CAPTURE STATISTICS - OWNER [ @ ]                   |#|[ DBA_044 ] DBA: VALIDATE OBJECTS FROM ONE OWNER [ @ ]   |#| 
|#[ DBA_045 ] DBA: VERIFY TABLES SIZE, VALIDATE OBJ - OWNERS [ @ ]    |#|[ DBA_046 ] DBA: OWNER X OBJECTS X TYPE X QTD            |#| 
|#[ DBA_047 ] DBA: VERIFY INSTANCE CHARACTERSET                       |#|[ DBA_048 ] DBA: CACHE HIT RATIO [ GOOD: > 90% ]         |#| 
|#[ DBA_049 ] DBA: VERIFY INSTANCE INSTALLED PRODUCTS                 |#|[ DBA_050 ] DBA: INSTANCE PROPERTIES                     |#| 
|#[ DBA_051 ] DBA: INSTANCE OPTIONS                                   |#|[ DBA_052 ] DBA: INSTANCE DIFFERENTS PARAMETERS          |#| 
|#[ DBA_053 ] DBA: INSTANCE MODIFICABLES PARAMETERS                   |#|[ DBA_054 ] DBA: VERIFY DEAD LOCKS                       |#| 
|#[ DBA_055 ] DBA: VERIFY SESSIONS PER I/O CONSUME                    |#|[ DBA_056 ] DBA: VERIFY FREE SEGMENTS ON DATAFILES       |#| 
|#[ DBA_057 ] DBA: VERIFY WHICH DATAFILE CAN BE RESIZED [ @ ]         |#|[ DBA_058 ] DBA: VERIFY RECYCLEBIN                       |#| 
|#[ DBA_059 ] DBA: CLEAR REYICLEBIN                                   |#|[ DBA_060 ] DBA: VERIFY DATABASE SESSIONS                |#| 
|#[ DBA_061 ] DBA: VERIFY ACTIVES SESSIONS PER OWNER                  |#|[ DBA_062 ] DBA: UNLOCKING A USER [ @ ]                  |#| 
|#[ DBA_063 ] DBA: LOCKING A USER [ @ ]                               |#|[ DBA_064 ] DBA: REDO GROUPS INFORMATIONS                |#| 
|#[ DBA_065 ] DBA: SHOW ALL CORRUPTED OBJECTS                         |#|[ DBA_066 ] DBA: VERIFY SPACE OF FLASH RECOVERY AREA     |#| 
|#[ DBA_067 ] DBA:                                                    |#|[ DBA_068 ] DBA: VERIFY CONTROLFILES                     |#| 
|#[ DBA_069 ] DBA: VERIFY CONSUME PER CPU                             |#|[ DBA_070 ] DBA: QUICK TUNE                              |#| 
|#[ DBA_071 ] DBA: VERIFY RECOMENDATIONS TUNING TOP 20 [ @ ]          |#|[ DBA_072 ] DBA: VERIFY TOP 20 TUNING HISTORY [ @ ]      |#| 
|#[ DBA_073 ] DBA: VERIFY BACKGROUND PROCESSESS                       |#|[ DBA_074 ] DBA: TOP 100 QUERY RECOMMENDATIONS           |#| 
|#[ DBA_075 ] DBA: VERIFY DYNAMICS PARAMETERS [ SPFILE ]              |#|[ DBA_076 ] DBA: VERIFY DBA FEATURES USAGE STATISTICS    |#| 
|#[ DBA_077 ] DBA: VERIFY DBA HIGH WATER MARK STATISTICS              |#|[ DBA_078 ] DBA: GLOBAL INFORMATION ABOUT I/O            |#| 
|#[ DBA_079 ] DBA: WHICH SEG. HAVE TOP LOGICAL I/O - PHYSICAL I/O     |#|[ DBA_080 ] DBA: VERIFY DBLINKS & FOLDERS INFO           |#| 
|#[ DBA_081 ] DBA: IDENTIFYING WHEN A PASSWORD WAS LAST CHANGED       |#|[ DBA_082 ] DBA: VERIFY UNDO SEGMENTS                    |#| 
|#[ DBA_083 ] DBA: VERIFY ALL SQL STATEMENTS                          |#|[ DBA_084 ] DBA: CLONE USER COMMANDS [ @ ]               |#| 
|#[ DBA_085 ] DBA: VERIFY ALL INFOS ABOUT SYSAUX                      |#|[ DBA_086 ] DBA: VERIFY ALL INFOS ABOUT I/O + LATENCY    |#| 
|#[ DBA_087 ] DBA: VERIFY MAIN TOP WAIT EVENTS PER WEEK               |#|[ DBA_088 ] DBA: VERIFY OBJECTS SIZE                     |#| 
|#[ DBA_089 ] DBA: GENERAL DATABASE OVERVIEW                          |#|[ DBA_090 ] DBA: DATABASE DASHBOARD                      |#| 
|#[ DBA_091 ] DBA: VERIFY ALL SQL IDS STATEMENTS                      |#|[ DBA_092 ] DBA: VERIFY NLS CONFIGURATION                |#| 
|#[ DBA_093 ] DBA: VERIFY DATABASE ENCREASY PER DAY / WEEK / MONTH    |#|[ DBA_094 ] DBA: VERIFY ALL SQL IDS STATEMENTS           |#|
|#[ DBA_095 ] DBA: VERIFY ALL PATCHES APPLIED                         |#|[ DBA_096 ] DBA: VERIFY CPU USAGE BY MINUTE              |#|
|#[ DBA_097 ] DBA: VERIFY STANDBY CONFIGURATION                       |#|[ DBA_098 ] DBA: VERIFY GRANTS AND PERMISSIONS BY OWNER  |#|
|#[ DBA_099 ] DBA:                                                    |#|[ DBA_100 ] DBA: VERIFY BACKUP RUNNING ON REAL TIME      |#|
|#[ DBA_101 ] DBA: VERIFY DATABASE COMPONENTS FROM REGISTRY           |#|[ DBA_102 ] DBA: Dataguard Health Check                  |#|"
SepLine
}
#
#########################################################################################################
#
# DATABASE Funtions
#
#########################################################################################################
# DATABASE: VERIFY DATABASE VERSION
#########################################################################################################
#
function DBA_001() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY DATABASE VERSION                                    #
prompt ##############################################################
col INSTANCE for a10
col SERVER for a50
col VERSION for a20
col STATUS for a8
col active_state for a12
col "STARTUP TIME" for a20
select INSTANCE_NAME AS INSTANCE
  , HOST_NAME AS SERVER
  , VERSION
  , STATUS
  , active_state
  , to_char(startup_time,'dd/mm/yyyy hh24:mi') as "STARTUP TIME"
  , case when startup_time < sysdate then 'Status OK' when startup_time < sysdate - 7 then 'DB Restarted' else 'Verify Restarted DB' end as "Status DB"
from gv\$instance;
quit;
EOF
}
#
#########################################################################################################
# VERIFY INSTALLED PATCHES - DETAILS
#########################################################################################################
#
# ### begin dbms_qopatch.get_sqlpatch_status; end; /
#
function DBA_002() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # Patches Status                                             #
prompt # Registry History                                           #
prompt ##############################################################
col time for a25
col Target for a35
col Action for a100
col action_time for a40
col product for a50
col version for a30
col status for a30
col comments for a30
select to_char(action_time,'dd/mm/yyyy HH24:MI:SS') time
  , namespace || ' ' || version as Target
  , action || ' ' || comments as Action
  , version
  , case when action_time < sysdate - 120 then 'Need Patch Apply' else 'Updated Recently' end as "Patch Info"
from dba_registry_history
order by action_time;
prompt ##############################################################
prompt # PSU History                                                #
prompt ##############################################################
col action for a20
col namespace for a20
col version for a30
col comments for a100
select to_char(action_time,'dd/mm/yyyy HH24:MI:SS') as TIME
  , ACTION
  , NAMESPACE
  , VERSION
--  , BUNDLE_SERIES
  , COMMENTS
from sys.registry\$history
-- where bundle_series = 'PSU'
order by action_time;
prompt ##############################################################
prompt # Product Components                                         #
prompt ##############################################################
select PRODUCT
  , VERSION
  , status
FROM SYS.PRODUCT_COMPONENT_VERSION;
quit;
EOF
echo "##############################################################"
echo "# OPatch Version with Details                                #"
echo "##############################################################"
${ORACLE_HOME}/OPatch/opatch version
echo "##############################################################"
echo "# OPatch List Patches                                        #"
echo "##############################################################"
${ORACLE_HOME}/OPatch/opatch lspatches | sort
echo "##############################################################"
echo "# OPatch LSINVENTORY with Details                            #"
echo "##############################################################"
${ORACLE_HOME}/OPatch/opatch lsinventory
}
#
#########################################################################################################
# INSTANCE INFORMATION + PGA & SGA
#########################################################################################################
#
function DBA_003() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
Prompt # INSTANCE INFORMATION + PGA + SGA                           #
prompt ##############################################################
col name for a60
col host_name for a30
col SERVER for a40
col "INSTANCE NAME" for a15
col version for a20
col "STARTUP TIME" for a20
col status for a15
select inst_id AS "INSTANCE ID"
   , a.instance_name AS "INSTANCE NAME"
   , a.host_name AS "SERVER"
   , a.version
   , a.status
   , a.instance_role as INST_ROLE
   , b.DATABASE_ROLE as DBA_ROLE
   , a.active_state
   , to_char(a.startup_time,'dd/mm/yyyy hh24:mi') as "STARTUP TIME"
   , case when a.startup_time < sysdate then 'Status OK' when a.startup_time < sysdate - 7 then 'DB Restarted' else 'Verify Restarted DB' end as "Status DB"
from gv\$instance a, v\$database b
order by 1;
prompt
prompt ##############################################################
Prompt # PGA                                                        #
prompt ##############################################################
show parameter pga;
prompt
prompt ##############################################################
Prompt # SGA                                                        #
prompt ##############################################################
show parameter sga;
prompt
prompt ##############################################################
PROMPT # SHARED POOL                                                #
prompt ##############################################################
col name for a50
col SIZE_KB for a20
col SIZE_MB for a20
col SIZE_GB for a20
col SIZE_TB for a20
select name
  , to_char(bytes/1024, '999G999G999G999D999') as SIZE_KB
  , to_char(bytes/1024/1024, '999G999G999G999D999') as SIZE_MB
  , to_char(bytes/1024/1024/1024, '999G999G999G999D999') as SIZE_GB
  , to_char(bytes/1024/1024/1024/1024, '999G999G999G999D999') as SIZE_TB
  , RESIZEABLE
from v\$sgainfo
order by name;
prompt
prompt ##############################################################
Prompt # SUM SGA                                                    #
prompt ##############################################################
SET SERVEROUTPUT ON
SET PAGESIZE 1000
SET LINESIZE 500
SET FEEDBACK OFF
select round(tot.bytes/1024/1024 ,2) total_mb
  , round(used.bytes/1024/1024 ,2) used_mb
  , round(free.bytes/1024/1024 ,2) free_mb
  , round(tot.bytes/1024/1024/1024 ,2) total_GB
  , round(used.bytes/1024/1024/1024 ,2) used_GB
  , round(free.bytes/1024/1024/1024 ,2) free_GB
  , round(tot.bytes/1024/1024/1024/1024 ,2) total_TB
  , round(used.bytes/1024/1024/1024/1024 ,2) used_TB
  , round(free.bytes/1024/1024/1024/1024 ,2) free_TB
from (select sum(bytes) bytes from v\$sgastat where name != 'free memory') used
   , (select sum(bytes) bytes from v\$sgastat where name = 'free memory') free
   , (select sum(bytes) bytes from v\$sgastat) tot;
prompt
prompt ##############################################################
Prompt # CPU and Memory Info                                        #
prompt ##############################################################
col name for a21 
col stat_name for a25 
col value for a15
col comments for a70
select STAT_NAME
  , to_char(VALUE) as VALUE 
  , comments 
from v\$osstat 
where stat_name in ('NUM_CPUS','NUM_CPU_CORES','NUM_CPU_SOCKETS') 
union 
select STAT_NAME
  , round(VALUE/1024/1024/1024, 2) || ' GB' 
  , comments 
from v\$osstat 
where stat_name in ('PHYSICAL_MEMORY_BYTES');
prompt
prompt ##############################################################
prompt # TOTAL USED MEMORY                                          #
prompt ##############################################################
select decode(grouping(nm), 1, 'total', nm) nm
  , round(sum(val/1024/1024)) mb
from (select 'sga' nm, sum(value) val from v\$sga union all select 'pga', sum(a.value) from v\$sesstat a, v\$statname b where b.name = 'session pga memory' and a.statistic# = b.statistic#)
group by rollup(nm);
quit;
EOF
}
#
#########################################################################################################
# GENERAL TUNING VIEW
#########################################################################################################
#
function DBA_004() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # GENERAL OVERVIEW                                           #
prompt ##############################################################
DECLARE
  v_value  NUMBER;
  FUNCTION Format(p_value in NUMBER)
    RETURN VARCHAR2 IS
  BEGIN
    RETURN LPad(to_char(Round(p_value,2),'990.00') || '%',8,' ') || '  ';
  END;
BEGIN
  -- --------------------------
  -- Dictionary Cache Hit Ratio
  -- --------------------------
  select (1 - (Sum(getmisses)/(Sum(gets) + Sum(getmisses)))) * 100
  INTO v_value
  FROM v\$rowcache;
  DBMS_Output.Put('Dictionary Cache Hit Ratio       : ' || Format(v_value));
  IF v_value < 90 THEN
    DBMS_Output.Put_Line('Increase SHARED_POOL_SIZE parameter to bring value above 90%');
  ELSE
    DBMS_Output.Put_Line('Value Acceptable.');
  END IF;
  -- -----------------------
  -- Library Cache Hit Ratio
  -- -----------------------
  select (1 -(Sum(reloads)/(Sum(pins) + Sum(reloads)))) * 100
  INTO v_value
  FROM v\$librarycache;
  DBMS_Output.Put('Library Cache Hit Ratio          : ' || Format(v_value));
  IF v_value < 99 THEN
  DBMS_Output.Put_Line('Increase SHARED_POOL_SIZE parameter to bring value above 99%');
  ELSE
    DBMS_Output.Put_Line('Value Acceptable.');
  END IF;
  -- -------------------------------
  -- DB Block Buffer Cache Hit Ratio
  -- -------------------------------
  select (1 - (phys.value / (db.value + cons.value))) * 100
  INTO v_value
  FROM v\$sysstat phys,v\$sysstat db, v\$sysstat cons
  WHERE phys.name = 'physical reads' AND db.name = 'db block gets' AND cons.name = 'consistent gets';
  DBMS_Output.Put('DB Block Buffer Cache Hit Ratio  : ' || Format(v_value));
  IF v_value < 89 THEN
    DBMS_Output.Put_Line('Increase DBA_BLOCK_BUFFERS parameter to bring value above 89%');
  ELSE
    DBMS_Output.Put_Line('Value Acceptable.');
  END IF;
  -- ---------------
  -- Latch Hit Ratio
  -- ---------------
  select (1 - (Sum(misses) / Sum(gets))) * 100
  INTO v_value
  FROM v\$latch;
  DBMS_Output.Put('Latch Hit Ratio                  : ' || Format(v_value));
  IF v_value < 98 THEN
    DBMS_Output.Put_Line('Increase number of latches to bring the value above 98%');
  ELSE
    DBMS_Output.Put_Line('Value acceptable.');
  END IF;
  -- -----------------------
  -- Disk Sort Ratio
  -- -----------------------
  select (disk.value/mem.value) * 100
  INTO v_value
  FROM v\$sysstat disk, v\$sysstat mem
  WHERE disk.name = 'sorts (disk)'
  AND mem.name  = 'sorts (memory)';
  DBMS_Output.Put('Disk Sort Ratio                  : ' || Format(v_value));
  IF v_value > 5 THEN
    DBMS_Output.Put_Line('Increase SORT_AREA_SIZE parameter to bring value below 5%');
  ELSE
    DBMS_Output.Put_Line('Value Acceptable.');
  END IF;
  -- ----------------------
  -- Rollback Segment Waits
  -- ----------------------
  select (Sum(waits)/Sum(gets))*100
  INTO v_value
  FROM v\$rollstat;
  DBMS_Output.Put('Rollback Segment Waits           : ' || Format(v_value));
  IF v_value > 5 THEN
    DBMS_Output.Put_Line('Increase number of Rollback Segments to bring the value below 5%');
  ELSE
    DBMS_Output.Put_Line('Value acceptable.');
  END IF;
  -- -------------------
  -- Dispatcher Workload
  -- -------------------
  select NVL((Sum(busy)/(Sum(busy)+Sum(idle))) * 100,0)
  INTO v_value
  FROM v\$dispatcher;
  DBMS_Output.Put('Dispatcher Workload              : ' || Format(v_value));
  IF v_value > 50 THEN
    DBMS_Output.Put_Line('Increase MTS_DISPATCHERS to bring the value below 50%');
  ELSE
    DBMS_Output.Put_Line('Value acceptable.');
  END IF;
END;
/
SET FEEDBACK ON
prompt
prompt ##############################################################
prompt # Waits by Class                                             #
prompt ##############################################################
col waits for a50
select 'Waits by Class | ' || wait_class as Waits, time_waited
FROM v\$system_wait_class
WHERE wait_class != 'Idle'
ORDER BY time_waited DESC;
prompt ##############################################################
Prompt # Wait Class Breakdown                                       #
prompt ##############################################################
col waits for a50
select 'Wait Class Breakdown | ' || wait_class as Waits, ROUND(aas, 2)
FROM (select n.wait_class, m.time_waited/m.INTSIZE_CSEC AAS
FROM v\$waitclassmetric m, v\$system_wait_class n
WHERE m.wait_class_id = n.wait_class_id
AND n.wait_class != 'Idle'
UNION ALL
select 'CPU', value/100 AAS
FROM v\$sysmetric
WHERE metric_name = 'CPU Usage Per Sec'
AND group_id = 2);
prompt
prompt ##############################################################
prompt # High-Level View                                            #
prompt ##############################################################
select  wait_class
  , total_waits
  , round(100 * (total_waits / sum_waits),2) pct_waits
  , time_waited, round(100 * (time_waited / sum_time),2) pct_time
from (select wait_class, total_waits, time_waited from v\$system_wait_class where wait_class != 'idle'),
     (select sum(total_waits) sum_waits, sum(time_waited) sum_time from v\$system_wait_class where wait_class != 'idle')
order by 5 desc;
prompt
prompt ##############################################################
prompt # Top Wait Events                                            #
prompt ##############################################################
select h.event "wait event"
  , sum(h.wait_time + h.time_waited) "total wait time"
from v\$active_session_history h
  , v\$event_name e
where h.sample_time between sysdate - 1/24 and sysdate
and h.event_id = e.event_id
and e.wait_class = 'idle'
group by h.event
order by 2 desc;
prompt
prompt ##############################################################
prompt # Table Scans                                                #
prompt ##############################################################
select to_char(sn.begin_interval_time,'YYYYMMDD hh24:mi:ss') start_date
  , to_char(sn.end_interval_time,'YYYYMMDD hh24:mi:ss') end_date
  , newmem.value-oldmem.value fts
from dba_hist_sysstat oldmem
  , dba_hist_sysstat newmem
  , dba_hist_snapshot sn
where sn.snap_id = (select max(snap_id) from dba_hist_snapshot)
and newmem.snap_id = sn.snap_id
and oldmem.snap_id = sn.snap_id-1
and oldmem.stat_name = 'table scans (long tables)'
and newmem.stat_name = 'table scans (long tables)';
prompt
prompt ##############################################################
prompt # Top SQL                                                    #
prompt ##############################################################
select h.user_id
  , u.username
  , sql.sql_text
  , sum(h.wait_time + h.time_waited) "total wait time"
from v\$active_session_history h
  , v\$sqlarea sql
  , dba_users u
  , v\$event_name e
where h.sample_time between sysdate - 1/24 and sysdate
and h.sql_id = sql.sql_id
and h.user_id = u.user_id
and h.sql_id is not null
and e.event_id = h.event_id
and e.wait_class = 'idle'
group by h.user_id,sql.sql_text, u.username order by 4 desc;
quit;
EOF
}
#
#########################################################################################################
# DATABASE GROWN ON LASTS MONTHS
#########################################################################################################
#
function DBA_005() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
exec dbms_application_info.set_action('DB growth');
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col month for a20
col GROWTH_MB format 999,999,999,999,999
col GROWTH_GB format 999,999,999,999,999
col GROWTH_TB format 999,999,999,999,999
col GROWTH_MB for a25
col GROWTH_GB for a25
col GROWTH_TB for a25
prompt ##############################################################
prompt # DATABASE GROWN ON LASTS MONTHS                             #
prompt ##############################################################
select trunc(creation_time, 'MM') month
  , to_char(round(sum(bytes/1024/1024)), '9G999G999') growth_mb
  , to_char(round(sum(bytes/1024/1024/1024)), '9G999G999') growth_gb
  , to_char(round(sum(bytes/1024/1024/1024/1024)), '9G999G999') growth_tb
FROM v\$datafile
GROUP BY trunc(creation_time, 'MM')
ORDER BY trunc(creation_time, 'MM');
prompt
prompt ##############################################################
prompt # VERIFY DATABASE ENCREASY PER DAY / WEEK / MONTH
prompt ##############################################################
COL "Database Size" FORMAT a13
COL "Used Space" FORMAT a11
COL "Used in %" FORMAT a11
COL "Free in %" FORMAT a11
COL "Database Name" FORMAT a13
COL "Free Space" FORMAT a12
COL "Growth DAY" FORMAT a11
COL "Growth WEEK" FORMAT a12
COL "Growth MONTH" FORMAT a12
COL "Growth DAY in %" FORMAT a16
COL "Growth WEEK in %" FORMAT a16
COL "Growth MONTH in %" FORMAT a16
SELECT (select min(to_char(creation_time, 'dd/mm/yyyy HH24:mm:ss')) from v\$datafile)                                                                                                        "Create Time"
  , (select name from v\$database)                                                                                                                                                           "Database Name"
  , ROUND((SUM(USED.BYTES)/1024/1024/1024),2)                                                                                                                                      || ' GB'  "Database Size"
  , ROUND((SUM(USED.BYTES)/1024/1024/1024) - ROUND(FREE.K/1024/1024/1024),2)                                                                                                       || ' GB'  "Used Space"
  , ROUND(((SUM(USED.BYTES)/1024/1024/1024) - (FREE.K/1024/1024/1024))/ROUND(SUM(USED.BYTES)/1024/1024/1024,2)*100,2)                                                              || '% GB' "Used in %"
  , ROUND((FREE.K/1024/1024/1024),2)                                                                                                                                               || ' GB'  "Free Space"
  , ROUND(((SUM(USED.BYTES)/1024/1024/1024) - ((SUM(USED.BYTES)/1024/1024/1024) - ROUND(FREE.K/1024/1024/1024)))/ROUND(SUM(USED.BYTES)/1024/1024/1024,2 )*100,2)                   || '% GB' "Free in %"
  , ROUND(((SUM(USED.BYTES)/1024/1024/1024) - (FREE.K/1024/1024/1024))/(select sysdate-min(creation_time) from v\$datafile),2)                                                     || ' GB'  "Growth DAY"
  , ROUND(((SUM(USED.BYTES)/1024/1024/1024) - (FREE.K/1024/1024/1024))/(select sysdate-min(creation_time) from v\$datafile)/ROUND((SUM(USED.BYTES)/1024/1024/1024),2)*100,3)       || '% GB' "Growth DAY in %"
  , ROUND(((SUM(USED.BYTES)/1024/1024/1024) - (FREE.K/1024/1024/1024))/(select sysdate-min(creation_time) from v\$datafile)*7,2)                                                   || ' GB'  "Growth WEEK"
  , ROUND((((SUM(USED.BYTES)/1024/1024/1024) - (FREE.K/1024/1024/1024))/(select sysdate-min(creation_time) from v\$datafile)/ROUND((SUM(USED.BYTES)/1024/1024/1024),2)*100)*7,3)   || '% GB' "Growth WEEK in %"
  , ROUND(((SUM(USED.BYTES)/1024/1024/1024) - (FREE.K/1024/1024/1024))/(select sysdate-min(creation_time) from v\$datafile)*30,2)                                                  || ' GB'  "Growth MONTH"
  , ROUND((((SUM(USED.BYTES)/1024/1024/1024) - (FREE.K/1024/1024/1024))/(select sysdate-min(creation_time) from v\$datafile)/ROUND((SUM(USED.BYTES)/1024/1024/1024),2)*100)*30,3)  || '% GB' "Growth MONTH in %"
FROM (SELECT BYTES FROM V\$DATAFILE
UNION ALL
SELECT BYTES FROM V\$TEMPFILE
UNION ALL
SELECT BYTES FROM V\$LOG) USED, (SELECT SUM(BYTES) AS K FROM dba_free_space) FREE
GROUP BY FREE.K;
quit;
EOF
}
#
#########################################################################################################
# CONNECTIONS AVERAGE PER HOUR
#########################################################################################################
#
function DBA_006() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # CONNECTIONS AVERAGE PER HOUR                               #
prompt ##############################################################
prompt 
select to_char(TRUNC(s.begin_interval_time,'HH24'),'DD/MM/YYYY HH24:MI:SS') snap_begin
  , sum(r.current_utilization) sessions
FROM dba_hist_resource_limit r, dba_hist_snapshot s
WHERE (TRUNC(s.begin_interval_time,'HH24'), s.snap_id ) IN
(--select the Maximum of the Snapshot IDs within an hour if more than one snapshot IDs
--have the same number of sessions within that hour , so then picking one of the snapIds
select TRUNC(sn.begin_interval_time,'HH24'),MAX(rl.snap_id)
FROM dba_hist_resource_limit rl,dba_hist_snapshot sn
WHERE TRUNC(sn.begin_interval_time) >= TRUNC(sysdate-1)
AND rl.snap_id = sn.snap_id
AND rl.resource_name = 'sessions'
AND rl.instance_number = sn.instance_number
AND (TRUNC(sn.begin_interval_time,'HH24'),rl.CURRENT_UTILIZATION ) IN
(--select the Maximum no.of sessions for a given begin interval time
-- All the snapshots within a given hour will have the same begin interval time when TRUNC is used
-- for HH24 and we are selecting the Maximum sessions for a given one hour
select TRUNC(s.begin_interval_time,'HH24'),MAX(r.CURRENT_UTILIZATION) "no_of_sess"
FROM dba_hist_resource_limit r,dba_hist_snapshot s
WHERE r.snap_id = s.snap_id
AND TRUNC(s.begin_interval_time) >= TRUNC(sysdate-1)
AND r.instance_number=s.instance_number
AND r.resource_name = 'sessions'
GROUP BY TRUNC(s.begin_interval_time,'HH24'))
GROUP BY TRUNC(sn.begin_interval_time,'HH24'),CURRENT_UTILIZATION)
AND r.snap_id = s.snap_id
AND r.instance_number = s.instance_number
AND r.resource_name = 'sessions'
GROUP BY to_char(TRUNC(s.begin_interval_time,'HH24'),'DD/MM/YYYY HH24:MI:SS')
ORDER BY snap_begin;
quit;
EOF
}
#
#########################################################################################################
# TOP 20 DB-CPU ACTIVITY
#########################################################################################################
#
function DBA_007() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col STAT_NAME for a50
col "% PERC" for a10
prompt ##############################################################
prompt # TOP 20 DB-CPU ACTIVITY                                     #
prompt ##############################################################
select STAT_NAME
  , TIME_WAITED
  , case when pct_waited >= 0.5 then 'Critical' when pct_waited >= 0.2 then 'Warning' end as "Status"
  , to_char(round(pct_waited*100,1), '999D00') || '%' as "% PERC"
from (select STAT_NAME, time_waited, TIME_WAITED/sum(time_waited) over () pct_waited
from (select STAT_NAME, round(sum(VALUE)/(1000*1000)) AS time_waited
from GV\$SYS_TIME_MODEL
group by STAT_NAME)
order by 2 desc)
where rownum <= 20;
quit;
EOF
}
#
#########################################################################################################
# VERIFY SESSIONS PER MEMORY
#########################################################################################################
#
function DBA_008() {
sqlplus -S / as sysdba <<EOF
set pages 1000 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY SESSIONS PER MEMORY                                 #
prompt ##############################################################
col name for a25
col program for a60
COL username for A20
COL module for A20
col machine for a50
select se.sid
  , n.name
  , s.program
  , s.machine
  , s.username
  , round(max(se.value)/(1024*1024),2) "MEM (MB)"
from v\$sesstat se, v\$statname n, v\$session s
where n.statistic# = se.statistic#
and s.sid = se.sid
and s.username != 'SYSTEM'
and n.name in ('session pga memory','session uga memory')
group by s.username, s.machine, se.sid,n.name, s.program
order by 6;
quit;
EOF
}
#
#########################################################################################################
# DATABASE SIZE
#########################################################################################################
#
function DBA_009() {
sqlplus -S / as sysdba <<EOF
set pages 1000 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # DATABASE SIZE                                              #
prompt ##############################################################
col "SIZE MB" for a20
col "SIZE GB" for a20
col "SIZE TB" for a20
select to_char(sum(bytes)/1024/1024, '9G999G999D99') "SIZE MB"
  , to_char(sum(bytes)/1024/1024/1024, '9G999G999D99') "SIZE GB"
  , to_char(sum(bytes)/1024/1024/1024/1024, '9G999G999D999') "SIZE TB"
from (select sum(bytes) bytes from dba_data_files
union all
select sum(bytes) bytes from dba_temp_files
union all
select sum(bytes * members) from v\$log
union all
select sum(block_size * file_size_blks) from v\$controlfile);
quit;
EOF
}
#
#########################################################################################################
# VERIFY SESSIONS PER I/O
#########################################################################################################
#
function DBA_010() {
sqlplus -S / as sysdba <<EOF
set pages 2000 lines 2000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY SESSIONS PER I/O
prompt ##############################################################
col username for a25
col osuser for a25
select NVL(s.username, '(oracle)') AS username
  , s.osuser
  , s.sid
  , s.serial#
  , si.block_gets
  , si.consistent_gets
  , si.physical_reads
  , si.block_changes
  , si.consistent_changes
FROM v\$session s, v\$sess_io si
WHERE s.sid = si.sid
and s.osuser not in ('GRID','grid','ORACLE','oracle')
ORDER BY s.username, s.osuser, si.physical_reads;
quit;
EOF
}
#
#########################################################################################################
# HIT RATIO THE LASTS 30 DAYS
#########################################################################################################
#
# NON PDB
function DBA_011() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
exec dbms_application_info.set_action('latches');
set pages 2000 lines 2000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # HIT RATIO THE LASTS 30 DAYS
prompt ##############################################################
col name for a60
col instance_name for a30
select instance_name
   , name
   , case when hit_ratio < 95 then 'Warning' when hit_ratio < 99 then 'Critical' end as hit_ratio
   , sleep_miss
from (select i.instance_name, l.name, round((gets-misses)/decode(gets,0,1,gets),3)*100 hit_ratio, round(sleeps/decode(misses,0,1,misses),3) sleep_miss
from gv\$latch l, gv\$instance i
where l.gets != 0
and l.inst_id = i.inst_id)
where hit_ratio < 100
order by hit_ratio;
quit;
EOF
}
#
#########################################################################################################
# VERIFY LONG OPERATIONS
#########################################################################################################
#
function DBA_012() {
sqlplus -S / as sysdba <<EOF
set pages 2000 lines 2000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # ACTIVE SESSIONS AND SQL STATEMENTS                         #
prompt ##############################################################
col USERNAME for a15
col "SID/SERIAL" for a15
col SQL_TEXT for a90
col machine for a35
col osuser for a15
select S.USERNAME
  , '( ' || s.sid || ',' || s.serial# || ' )' as "SID/SERIAL"
  , s.machine
  , s.osuser
  , s.seconds_in_wait as "waiting seg"
  , t.sql_id
  , sql_text
from v\$sqltext_with_newlines t, V\$SESSION s
where t.address = s.sql_address and t.hash_value = s.sql_hash_value and s.status = 'ACTIVE'
order by s.sid, t.piece;
prompt
prompt ##############################################################
prompt # LOCKED OBJECT ON LONG OPERATIONS                           #
prompt ##############################################################
col OBJECT_NAME for a30
select object_name
  , object_type
  , session_id
  , type
  , lmode
  , request
  , block
  , ctime
from v\$locked_object, all_objects, v\$lock
where v\$locked_object.object_id = all_objects.object_id 
and v\$lock.id1 = all_objects.object_id 
and v\$lock.sid = v\$locked_object.session_id
order by session_id, ctime desc, object_name;
prompt
prompt ##############################################################
prompt # OPERATION NAME, HOW LONG ARE RUNNING, MESSAGE              #
prompt ##############################################################
col OPNAME for a35
col TARGET for a20
col UNITS for a10
col MESSAGE for a100
col sql_id for a15
select distinct * from (select opname
              , target
						  , sofar
						  , sql_id
						  , totalwork
						  , units
						  , elapsed_seconds
						  , message 
						from v\$session_longops 
						order by start_time desc) 
where rownum <= 10;
prompt
prompt ##############################################################
prompt # ??? #
prompt ##############################################################
col OPNAME for a35
col TARGET for a30
select opname
  , target
  , osuser
  , sl.sql_id
  , sl.sql_hash_value
  , elapsed_seconds
  , time_remaining
FROM v\$session_longops sl
inner join v\$session s ON sl.SID = s.SID AND sl.SERIAL# = s.SERIAL# WHERE time_remaining > 0;
prompt
prompt ##############################################################
prompt # ??? #
prompt ##############################################################
col username for a15
col sql_fulltext for a75
col TARGET for a20
select s.username
  , sl.sid
  , sq.executions
  , sl.last_update_time
  , sl.sql_id
  , sl.sql_hash_value
  , opname
  , target
  , elapsed_seconds
  , time_remaining
  , sq.sql_fulltext
FROM v\$session_longops sl
INNER JOIN v\$sql sq ON sq.sql_id = sl.sql_id
INNER JOIN v\$session s ON sl.SID = s.SID AND sl.serial# = s.serial#
WHERE time_remaining > 0;
prompt
prompt ##############################################################
prompt #  #
prompt ##############################################################
col sql_id for a15
col units for a15
col opname for a35
col started for a20
col now for a20
select sql_id
  , opname
  , to_char(start_time, 'DD/MM/YYYY HH24:MI:SS') as started
  , to_char(sysdate, 'DD/MM/YYYY HH24:MI:SS') as now
--  , trunc(((((86400*(sysdate-start_time))/60)/60)/24)/7) weeks
  , trunc((((86400*(sysdate-start_time))/60)/60)/24) days
  , trunc(((86400*(sysdate-start_time))/60)/60)-24*(trunc((((86400*(sysdate-start_time))/60)/60)/24)) hours
  , trunc((86400*(sysdate-start_time))/60)-60*(trunc(((86400*(sysdate-start_time))/60)/60)) minutes
  , trunc(86400*(sysdate-start_time))-60*(trunc((86400*(sysdate-start_time))/60)) seconds
  , sofar
  , totalwork
  , units
--  , round(elapsed_seconds/60/60,2) as seconds
  , round(time_remaining/60/60,2) as remaining
FROM v\$session_longops
WHERE sofar != totalwork;
quit;
EOF
}
#
#########################################################################################################
# INVALIDS OBJECTS [ @ ]
#########################################################################################################
#
function DBA_013() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # INVALIDS OBJECTS [ @ ]
prompt ##############################################################
col owner for a25
col OBJECT_TYPE for a25
col "Total of invalids objects." for a30
select owner
   , decode(object_type,null,'========================>', object_type) as "OBJECT_TYPE"
   , count(object_type) as "TOTAL"
   , decode(grouping(owner),0,null,1,'Total of invalids objects.') as " "
from dba_objects where status <> 'VALID'
group by rollup (owner, object_type)
order by owner, object_type desc;
quit;
EOF
}
#
#########################################################################################################
# JOBS CONTROL OF THE CLIENT [ @ ]
#########################################################################################################
#
function DBA_014() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # JOBS CONTROL OF THE CLIENT [ @ ]
prompt ##############################################################
col COMMENTS for a100
col JOB_NAME for a40
-- col RUN_COUNT for a20
col owner for a10
col state for a12
col SCHEDULE_TYPE for a16
col LAST_EXEC for a20
col enabled for a8
select JOB_NAME
 , STATE
 , ENABLED
 , PROGRAM_OWNER as OWNER
 , SCHEDULE_TYPE
 , RUN_COUNT
 , to_char(LAST_START_DATE, 'dd/mm/yyyy HH:MM:SS') as LAST_EXEC
 , substr(COMMENTS,1,100) as COMMENTS
FROM DBA_SCHEDULER_JOBS
ORDER BY 1,2,3,4,5,6,7;
prompt
prompt ##############################################################
prompt # Show All Submited RDBMS Jobs
prompt ##############################################################
col proc format a50    heading 'Proc'
col job  format 99999  heading 'job#'
col subu format a10    heading 'Submiter' trunc
col lsd  format a10    heading 'Last|OK|Date'
col lst  format a5     heading 'Last|OK|Time'
col nrd  format a10    heading 'Next|Run|Date'
col nrt  format a5     heading 'Next|Run|Time'
col fail format 999    heading 'Errors'
col ok   format a2     heading 'OK'
select job
  , log_user as subu
  , what as proc
  , to_char(last_date,'MM/DD/YYYY') as lsd
  , substr(last_sec,1,5) as lst
  , to_char(next_date,'MM/DD/YYYY') as nrd
  , substr(next_sec,1,5) as nrt
  , failures as fail
  , decode(broken,'Y','N','Y') ok
from sys.dba_jobs;
quit;
EOF
}
#
#########################################################################################################
# MATERIALIZEDS VIEWS DISABLED
#########################################################################################################
#
function DBA_015() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # MATERIALIZEDS VIEWS DISABLED
prompt ##############################################################
col owner for a20
col type for a20
select owner
   , type
   , tablespace_name
   , round(sum(mb)) as mb
from (select owner,'mview' as type, tablespace_name, round(sum(bytes)/1024/1024) as mb from dba_segments where (owner,segment_name) in
     (select owner, mview_name from dba_mviews) group by owner, segment_type, tablespace_name
union
select owner
  , 'mview_log' as type
  , tablespace_name
  , round(sum(bytes)/1024/1024) as mb
from dba_segments
where (owner, segment_name) in
(select log_owner, log_table from dba_snapshot_logs)
group by owner, segment_type, tablespace_name
union
select owner
  , 'mview_index' as type
  , tablespace_name
  , round(sum(bytes)/1024/1024) as mb
from dba_segments
where (owner,segment_name) in
(select owner, index_name from dba_indexes where (owner,table_name) in
(select owner, mview_name from dba_mviews))
group by owner, segment_type, tablespace_name) t1
group by owner,type,tablespace_name;
quit;
EOF
}
#
#########################################################################################################
# VERIFY RUNNING JOBS
#########################################################################################################
#
function DBA_016() {
sqlplus -S / as sysdba <<EOF
set pages 1000 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
set on verify off
prompt ##############################################################
prompt # VERIFY RUNNING JOBS
prompt ##############################################################
prompt
col "Last Date" for a30
col "This Date" for a30
select a.job "Job"
  , a.sid
  , a.failures "Failures"
  , Substr(To_Char(a.last_date,'DD/MM/YYYY HH24:MI:SS'),1,20) "Last Date"
  , Substr(To_Char(a.this_date,'DD/MM/YYYY HH24:MI:SS'),1,20) "This Date"
FROM dba_jobs_running a;
SET VERIFY ON
quit;
EOF
}
#
#########################################################################################################
# KILL A RUNNING SESSION [ @ ]
#########################################################################################################
#
function DBA_017() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # KILL A RUNNING SESSION [ @ ]
prompt ##############################################################
col MACHINE for a30
col username for a25
col OSUSER for a30
col PROGRAM for a60
col "SID,SERIAL,@INST" for a20
select OSUSER
  , MACHINE
  , SID || ',' || SERIAL# || ',@' || INST_ID as "SID,SERIAL,@INST"
  , USERNAME
  , PROGRAM
from gv\$session
where osuser not in ('GRID','grid','ORACLE','oracle')
order by 1,2,3,5;
quit;
EOF
}
#
#########################################################################################################
# VERIFY PROFILE INFORMATION
#########################################################################################################
#
function DBA_018() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY PROFILE INFORMATION
prompt ##############################################################
prompt
COL RESOURCE_NAME FOR A40
COL LIMIT FOR A40
select resource_name, limit
from dba_profiles
order by 1,2;
quit;
EOF
}
#
#########################################################################################################
# BACKUP STATISTICS
#########################################################################################################
#
function DBA_019() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col STATUS format a30
col DURATION format a10
col INPUT_TYPE for a20
col OPTIMIZED for a10
col BACKUP_SIZE for a20
col BEGIN for a20
col END for a20
prompt ##############################################################
prompt # BACKUP STATISTICS
prompt ##############################################################
prompt
select * from (select INPUT_TYPE
    , STATUS
    , OPTIMIZED
    , to_char(START_TIME,'DD/MM/YYYY hh24:mi') as BEGIN
    , to_char(END_TIME,'DD/MM/YYYY hh24:mi') as END
    , TIME_TAKEN_DISPLAY as DURATION
    , d.OUTPUT_BYTES_DISPLAY as BACKUP_SIZE
from V\$RMAN_BACKUP_JOB_DETAILS d
where START_TIME > sysdate-30
-- and INPUT_TYPE = '${SRMAN_TYPE}'
-- and INPUT_TYPE in ('DB FULL', 'RECVR AREA', 'DB INCR', 'DATAFILE FULL', 'DATAFILE INCR', 'ARCHIVELOG', 'CONTROLFILE', 'SPFILE')
order by session_key, BEGIN desc);
quit;
EOF
}
#
#########################################################################################################
# QTD OF ARCHIVES PER HOUR
#########################################################################################################
#
function DBA_020() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col 00 for a5
col 01 for a5
col 02 for a5
col 03 for a5
col 04 for a5
col 05 for a5
col 06 for a5
col 07 for a5
col 08 for a5
col 09 for a5
col 10 for a5
col 11 for a5
col 12 for a5
col 13 for a5
col 14 for a5
col 15 for a5
col 16 for a5
col 17 for a5
col 18 for a5
col 19 for a5
col 20 for a5
col 21 for a5
col 22 for a5
col 23 for a5
prompt ##############################################################
prompt # QTD OF ARCHIVES PER HOUR
prompt ##############################################################
select trunc(first_time) day
  , to_char(sum(decode(to_char(first_time,'HH24'),'00',1,0)), '9999') "00"
  , to_char(sum(decode(to_char(first_time,'HH24'),'01',1,0)), '9999') "01"
  , to_char(sum(decode(to_char(first_time,'HH24'),'02',1,0)), '9999') "02"
  , to_char(sum(decode(to_char(first_time,'HH24'),'03',1,0)), '9999') "03"
  , to_char(sum(decode(to_char(first_time,'HH24'),'04',1,0)), '9999') "04"
  , to_char(sum(decode(to_char(first_time,'HH24'),'05',1,0)), '9999') "05"
  , to_char(sum(decode(to_char(first_time,'HH24'),'06',1,0)), '9999') "06"
  , to_char(sum(decode(to_char(first_time,'HH24'),'07',1,0)), '9999') "07"
  , to_char(sum(decode(to_char(first_time,'HH24'),'08',1,0)), '9999') "08"
  , to_char(sum(decode(to_char(first_time,'HH24'),'09',1,0)), '9999') "09"
  , to_char(sum(decode(to_char(first_time,'HH24'),'10',1,0)), '9999') "10"
  , to_char(sum(decode(to_char(first_time,'HH24'),'11',1,0)), '9999') "11"
  , to_char(sum(decode(to_char(first_time,'HH24'),'12',1,0)), '9999') "12"
  , to_char(sum(decode(to_char(first_time,'HH24'),'13',1,0)), '9999') "13"
  , to_char(sum(decode(to_char(first_time,'HH24'),'14',1,0)), '9999') "14"
  , to_char(sum(decode(to_char(first_time,'HH24'),'15',1,0)), '9999') "15"
  , to_char(sum(decode(to_char(first_time,'HH24'),'16',1,0)), '9999') "16"
  , to_char(sum(decode(to_char(first_time,'HH24'),'17',1,0)), '9999') "17"
  , to_char(sum(decode(to_char(first_time,'HH24'),'18',1,0)), '9999') "18"
  , to_char(sum(decode(to_char(first_time,'HH24'),'19',1,0)), '9999') "19"
  , to_char(sum(decode(to_char(first_time,'HH24'),'20',1,0)), '9999') "20"
  , to_char(sum(decode(to_char(first_time,'HH24'),'21',1,0)), '9999') "21"
  , to_char(sum(decode(to_char(first_time,'HH24'),'22',1,0)), '9999') "22"
  , to_char(sum(decode(to_char(first_time,'HH24'),'23',1,0)), '9999') "23"
from gv\$log_history
where first_time > trunc(sysdate - 30)
and first_time < sysdate + 1
group by trunc(first_time)
order by 1;
quit;
EOF
}
#
#########################################################################################################
# LAST FILE OF LAST BACKUP ARCH - RMAN
#########################################################################################################
#
function DBA_021() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy hh24:mi';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # LAST FILE OF LAST BACKUP ARCH - RMAN
prompt ##############################################################
col PATH format a100
col tag format a30
col DEVICE format a10
col SIZE_BYTES_DISPLAY for a15
col BEGIN for a20
col END for a20
col STATUS for a20
select /*+ rule */ tag
  , device_type as DEVICE
  , handle as PATH
  , START_TIME as BEGIN
  , COMPLETION_TIME as END
  , rtrim(SIZE_BYTES_DISPLAY) as SIZE_BYTES_DISPLAY 
-- , status
from v\$backup_piece_details
where session_recid > (select max(session_recid) -10000 from V\$RMAN_BACKUP_JOB_DETAILS where START_TIME > sysdate-30 and input_type in('ARCHIVELOG') and status in ('COMPLETED','COMPLETED WITH WARNINGS'))
and START_TIME > sysdate-30
order by START_TIME;
quit;
EOF
}
#
#########################################################################################################
# LAST FILE OF LAST BACKUP FULL - RMAN
#########################################################################################################
#
function DBA_022() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy hh24:mi';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # LAST FILE OF LAST BACKUP FULL - RMAN
prompt ##############################################################
col PATH format a100
col tag format a30
col DEVICE format a10
col SIZE_BYTES_DISPLAY for a10
col BEGIN for a20
col END for a20
select /*+ rule */ tag
  , device_type as DEVICE
  , handle as PATH
  , START_TIME as BEGIN
  , COMPLETION_TIME as END
  , SIZE_BYTES_DISPLAY
from v\$backup_piece_details
where session_recid > (select max(session_recid) -10000 from V\$RMAN_BACKUP_JOB_DETAILS where START_TIME > sysdate-30 and input_type in('DB FULL', 'DB INCR') and status in ('COMPLETED','COMPLETED WITH WARNINGS'))
and START_TIME > sysdate-30
order by START_TIME;
quit;
EOF
}
#
#########################################################################################################
# ARCHIVES GENERATED PER DAY
#########################################################################################################
#
function DBA_023() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # ARCHIVES GENERATED PER DAY
prompt ##############################################################
col day for a20
col SIZE_MB for a20
col SIZE_GB for a20
col SIZE_TB for a20
select trunc(first_time) as day
  , to_char(sum(blocks * block_size)/1024/1024,'9G999G999D999') SIZE_MB
  , to_char(sum(blocks * block_size)/1024/1024/1024,'9G999G999D999') SIZE_GB
  , to_char(sum(blocks * block_size)/1024/1024/1024/1024,'9G999G999D999') SIZE_TB
from gv\$archived_log
where trunc(first_time) > sysdate -30
and trunc(first_time) < sysdate +1
group by trunc(first_time)
order by 1;
quit;
EOF
}
#
#########################################################################################################
# BACKUP LOG OF LAST BACKUP FULL - RMAN
#########################################################################################################
#
function DBA_024() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # BACKUP LOG OF LAST BACKUP FULL - RMAN
prompt ##############################################################
select decode(status, 'COMPLETED', 0,1) as STATUS
  , case when decode(status, 'COMPLETED', 0,1) = 0 then 'Backup Not Running' else 'Backup Running' end as "Running Y/N"
from v\$RMAN_BACKUP_JOB_DETAILS
where session_key = (select max(session_key) from v\$RMAN_BACKUP_JOB_DETAILS where START_TIME > sysdate - 30 and input_type in('DB FULL', 'DB INCR','CONTROLFILE'));
quit;
EOF
echo ">------------------------------------------------------------------------------------------------------------"
echo " -- RMAN PROCESSES --"
echo ">------------------------------------------------------------------------------------------------------------"
ps -ef | grep rman | grep -v grep
}
#
#########################################################################################################
# BACKUP LOG OF LASTS ARCHIVES - RMAN
#########################################################################################################
#
function DBA_025() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # BACKUP LOG OF LASTS ARCHIVES - RMAN
prompt ##############################################################
select decode(status, 'COMPLETED', 0,1) as STATUS
  , case when decode(status, 'COMPLETED', 0,1) = 0 then 'Backup Not Running' else 'Backup Running' end as "Running Y/N"
from v\$RMAN_BACKUP_JOB_DETAILS
where session_key = (select max(session_key) from v\$RMAN_BACKUP_JOB_DETAILS where START_TIME > sysdate - 30 and input_type in('ARCHIVELOG','CONTROLEFILE'));
quit;
EOF
echo ">------------------------------------------------------------------------------------------------------------"
echo " -- RMAN PROCESSES --"
echo ">------------------------------------------------------------------------------------------------------------"
ps -ef | grep rman | grep -v grep
}
#
#########################################################################################################
# ERRORS ON ALERT LOG FILE
#########################################################################################################
#
function DBA_026() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
var days_back number;
exec :days_back := 15;
set pages 3000 lines 3000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
set feedback off
prompt ##############################################################
prompt # ERRORS ON ALERT LOG FILE
prompt ##############################################################
col "DATE_TIME" for a20
col host_address for a16
col MESSAGE_TEXT for a140
select to_char(ORIGINATING_TIMESTAMP, 'DD/MM/YYYY HH24:MI:SS') as "DATE_TIME", host_address, MESSAGE_TEXT
from sys.X\$DBGALERTEXT
where (lower(MESSAGE_TEXT) like '%ora-%' or lower(MESSAGE_TEXT) like '%error%' or lower(MESSAGE_TEXT) like '%checkpoint not complete%' or lower(MESSAGE_TEXT) like '%fail%')
and ORIGINATING_TIMESTAMP > sysdate-:days_back
order by ORIGINATING_TIMESTAMP;
col total for a80
prompt
prompt ##############################################################
select '[ GENERAL ERRORS ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where (lower(MESSAGE_TEXT) like '%error%' or lower(MESSAGE_TEXT) like '%checkpoint not complete%' or lower(MESSAGE_TEXT) like '%fail%')
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
select '[ ORACLE ERRORS ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where (lower(MESSAGE_TEXT) like '%ora-%' or lower(MESSAGE_TEXT) like '%error%' or lower(MESSAGE_TEXT) like '%fail%')
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
select '[ ORA-00600 ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where MESSAGE_TEXT like '%ORA-00600%'
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
select '[ ORA-00700 ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where MESSAGE_TEXT like '%ORA-00700%'
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
select '[ ORA-07445 ] Total of Occurrences on The Lasts ' || :days_back || ' Days: ' || count(*) as "Total"
from sys.X\$DBGALERTEXT
where MESSAGE_TEXT like '%ORA-07445%'
and ORIGINATING_TIMESTAMP > sysdate-:days_back;
prompt
prompt ##############################################################
quit;
EOF
}
#
#########################################################################################################
# ORACLE ENTERPRISE MANAGER ALERT
#########################################################################################################
#
function DBA_027() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # ORACLE ENTERPRISE MANAGER ALERT
prompt ##############################################################
col message_type for a30
col reason for a110
col date_alert for a20
col SUGGESTED_ACTION for a30
select to_char(TIME_SUGGESTED, 'dd/mm/yyyy hh24:mi') DATE_ALERT
  , message_type
  , reason
  , SUGGESTED_ACTION
FROM dba_outstanding_alerts
order by DATE_ALERT;
quit;
EOF
}
#
#########################################################################################################
# CAPTURE STATISTICS OF DATA DICTIONARY
#########################################################################################################
#
function DBA_028() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # CAPTURE STATISTICS OF DATA DICTIONARY                      #
prompt # WAIT A MOMENT PLEASE, THE STATISTICS COLLECTION IS RUNNING #
prompt ##############################################################
-- begin
   exec DBMS_STATS.GATHER_DICTIONARY_STATS;
-- end;
-- /
quit;
EOF
}
#
# exec DBMS_STATS.SET_PARAM(AUTOSTATS_TARGET,'ORACLE');
# exec dbms_stats.gather_system_stats();
# exec dbms_stats.gather_system_stats('start');
# exec dbms_stats.gather_system_stats('stop');
# exec dbms_stats.gather_system_stats('interval',60);
# exec DBMS_STATS.GATHER_SCHEMA_STATS ('SYS');
#
#########################################################################################################
# CAPTURE STATISTICS OF ALL DATABASE
#########################################################################################################
#
function DBA_029() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # CAPTURE STATISTICS OF ALL DATABASE                         #
Prompt # WAIT A MOMENT PLEASE, THE STATISTICS COLLECTION IS RUNNING #
prompt ##############################################################
-- begin
   exec DBMS_STATS.GATHER_DATABASE_STATS;
-- end;
-- /
quit;
EOF
}
#
#########################################################################################################
# BLOCKING LOCKS
#########################################################################################################
#
function DBA_030() {
sqlplus -S / as sysdba <<EOF
SET TERMOUT OFF TERMOUT ON ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 180 PAGESIZE 50000 TRIMSPOOL ON VERIFY OFF serveroutput ON FORMAT WRAPPED feedback OFF timing on
prompt ##############################################################
prompt # BLOCKING LOCKS
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
DECLARE
  CURSOR cur_BlockingLocks IS
    select iw.instance_name AS waiting_instance
      , sw.status AS waiting_status
      , lw.sid AS waiting_sid
      , sw.serial# AS waiting_serial_num
      , sw.username AS waiting_oracle_username
      , sw.osuser AS waiting_os_username
      , sw.machine AS waiting_machine
      , pw.spid AS waiting_spid
      , SUBSTR(sw.terminal,0, 39) AS waiting_terminal
      , SUBSTR(sw.program,0, 39) AS waiting_program
      , ROUND(lw.ctime/60) AS waiting_lock_time_min
      , DECODE (lh.type, 'CF', 'Control File', 'DX', 'Distributed Transaction', 'FS', 'File Set', 'IR', 'Instance Recovery', 'IS', 'Instance State', 'IV', 'Libcache Invalidation', 'LS', 'Log Start or Log Switch', 'MR', 'Media Recovery', 'RT', 'Redo Thread', 'RW', 'Row Wait', 'SQ', 'Sequence Number', 'ST', 'Diskspace Transaction', 'TE', 'Extend Table', 'TT', 'Temp Table', 'TX', 'Transaction', 'TM', 'DML', 'UL', 'PLSQL User_lock', 'UN', 'User Name', 'Nothing-'  ) AS waiter_lock_type
      , DECODE (lw.request, 0, 'None' /* Mon Lock equivalent */ , 1, 'NoLock' /* N */, 2, 'Row-Share (SS)' /* L */ , 3, 'Row-Exclusive (SX)' /* R */ , 4, 'Share-Table' /* S */ , 5, 'Share-Row-Exclusive (SSX)' /* C */ , 6, 'Exclusive' /* X */ , '[Nothing]' ) AS waiter_mode_request
      , ih.instance_name AS locking_instance
      , sh.status AS locking_status
      , lh.sid AS locking_sid
      , sh.serial# AS locking_serial_num
      , sh.username AS locking_oracle_username
      , sh.osuser AS locking_os_username
      , sh.machine AS locking_machine
      , ph.spid AS locking_spid
      , SUBSTR(sh.terminal,0, 39) AS locking_terminal
      , SUBSTR(sh.program,0, 39) AS locking_program
      , ROUND(lh.ctime/60) AS locking_lock_time_min
      , aw.sql_text AS waiting_sql_text
    FROM gv\$lock     lw
      , gv\$lock     lh
      , gv\$instance iw
      , gv\$instance ih
      , gv\$session  sw
      , gv\$session  sh
      , gv\$process  pw
      , gv\$process  ph
      , gv\$sqlarea  aw
    WHERE iw.inst_id  = lw.inst_id
    AND ih.inst_id  = lh.inst_id
    AND sw.inst_id  = lw.inst_id
    AND sh.inst_id  = lh.inst_id
    AND pw.inst_id  = lw.inst_id
    AND ph.inst_id  = lh.inst_id
    AND aw.inst_id  = lw.inst_id
    AND sw.sid      = lw.sid
    AND sh.sid      = lh.sid
    AND lh.id1      = lw.id1
    AND lh.id2      = lw.id2
    AND lh.request  = 0
    AND lw.lmode    = 0
    AND (lh.id1, lh.id2) IN ( select id1, id2 FROM gv\$lock WHERE request = 0 INTERSECT select id1, id2 FROM gv\$lock WHERE  lmode = 0)
    AND sw.paddr  = pw.addr (+)
    AND sh.paddr  = ph.addr (+)
    AND sw.sql_address  = aw.address
    ORDER BY iw.instance_name, lw.sid;
    TYPE t_BlockingLockRecord IS RECORD (
        WaitingInstanceName       VARCHAR2(16)
      , WaitingStatus             VARCHAR2(8)
      , WaitingSid                NUMBER
      , WaitingSerialNum          NUMBER
      , WaitingOracleUsername     VARCHAR2(30)
      , WaitingOSUsername         VARCHAR2(30)
      , WaitingMachine            VARCHAR2(64)
      , WaitingSpid               VARCHAR2(12)
      , WaitingTerminal           VARCHAR2(30)
      , WaitingProgram            VARCHAR2(48)
      , WaitingLockTimeMinute     NUMBER
      , WaiterLockType            VARCHAR2(30)
      , WaiterModeRequest         VARCHAR2(30)
      , LockingInstanceName       VARCHAR2(16)
      , LockingStatus             VARCHAR2(8)
      , LockingSid                NUMBER
      , LockingSerialNum          NUMBER
      , LockingOracleUsername     VARCHAR2(30)
      , LockingOSUsername         VARCHAR2(30)
      , LockingMachine            VARCHAR2(64)
      , LockingSpid               VARCHAR2(12)
      , LockingTerminal           VARCHAR2(30)
      , LockingProgram            VARCHAR2(48)
      , LockingLockTimeMinute     NUMBER
      , SQLText                   VARCHAR2(1000));
    TYPE t_BlockingLockRecordTable IS TABLE OF t_BlockingLockRecord INDEX BY BINARY_INTEGER;
    v_BlockingLockArray             t_BlockingLockRecordTable;
    v_BlockingLockRec               cur_BlockingLocks%ROWTYPE;
    v_NumBlockingLocksIncidents     BINARY_INTEGER := 0;
BEGIN
    DBMS_OUTPUT.ENABLE(1000000);
    OPEN cur_BlockingLocks;
    LOOP
        FETCH cur_BlockingLocks INTO v_BlockingLockRec;
        EXIT WHEN cur_BlockingLocks%NOTFOUND;
        v_NumBlockingLocksIncidents := v_NumBlockingLocksIncidents + 1;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingInstanceName      := v_BlockingLockRec.waiting_instance;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingStatus            := v_BlockingLockRec.waiting_status;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingSid               := v_BlockingLockRec.waiting_sid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingSerialNum         := v_BlockingLockRec.waiting_serial_num;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingOracleUsername    := v_BlockingLockRec.waiting_oracle_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingOSUsername        := v_BlockingLockRec.waiting_os_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingMachine           := v_BlockingLockRec.waiting_machine;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingSpid              := v_BlockingLockRec.waiting_spid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingTerminal          := v_BlockingLockRec.waiting_terminal;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingProgram           := v_BlockingLockRec.waiting_program;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingLockTimeMinute    := v_BlockingLockRec.waiting_lock_time_min;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaiterLockType           := v_BlockingLockRec.waiter_lock_type;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaiterModeRequest        := v_BlockingLockRec.waiter_mode_request;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingInstanceName      := v_BlockingLockRec.locking_instance;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingStatus            := v_BlockingLockRec.locking_status;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingSid               := v_BlockingLockRec.locking_sid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingSerialNum         := v_BlockingLockRec.locking_serial_num;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingOracleUsername    := v_BlockingLockRec.locking_oracle_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingOSUsername        := v_BlockingLockRec.locking_os_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingMachine           := v_BlockingLockRec.locking_machine;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingSpid              := v_BlockingLockRec.locking_spid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingTerminal          := v_BlockingLockRec.locking_terminal;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingProgram           := v_BlockingLockRec.locking_program;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingLockTimeMinute    := v_BlockingLockRec.locking_lock_time_min;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).SQLText                  := v_BlockingLockRec.waiting_sql_text;
    END LOOP;
    CLOSE cur_BlockingLocks;
    DBMS_OUTPUT.PUT_LINE('Number of blocking lock incidents: ' || v_BlockingLockArray.COUNT);
    DBMS_OUTPUT.PUT(chr(10));
    FOR RowIndex IN 1 .. v_BlockingLockArray.COUNT
    LOOP
        DBMS_OUTPUT.PUT_LINE('Incident ' || RowIndex);
        DBMS_OUTPUT.PUT_LINE('---');
        DBMS_OUTPUT.PUT_LINE('                        WAITING                                  BLOCKING');
        DBMS_OUTPUT.PUT_LINE('                        ---------------------------------------- ----------------------------------------');
        DBMS_OUTPUT.PUT_LINE('Instance Name         : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingInstanceName, 41)   || v_BlockingLockArray(RowIndex).LockingInstanceName);
        DBMS_OUTPUT.PUT_LINE('Oracle SID            : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingSid, 41)            || v_BlockingLockArray(RowIndex).LockingSid);
        DBMS_OUTPUT.PUT_LINE('Serial#               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingSerialNum, 41)      || v_BlockingLockArray(RowIndex).LockingSerialNum);
        DBMS_OUTPUT.PUT_LINE('Oracle User           : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingOracleUsername, 41) || v_BlockingLockArray(RowIndex).LockingOracleUsername);
        DBMS_OUTPUT.PUT_LINE('O/S User              : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingOSUsername, 41)     || v_BlockingLockArray(RowIndex).LockingOSUsername);
        DBMS_OUTPUT.PUT_LINE('Machine               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingMachine, 41)        || v_BlockingLockArray(RowIndex).LockingMachine);
        DBMS_OUTPUT.PUT_LINE('O/S PID               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingSpid, 41)           || v_BlockingLockArray(RowIndex).LockingSpid);
        DBMS_OUTPUT.PUT_LINE('Terminal              : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingTerminal, 41)       || v_BlockingLockArray(RowIndex).LockingTerminal);
        DBMS_OUTPUT.PUT_LINE('Lock Time             : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingLockTimeMinute      || ' minutes', 41) || v_BlockingLockArray(RowIndex).LockingLockTimeMinute ||' minutes');
        DBMS_OUTPUT.PUT_LINE('Status                : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingStatus, 41)         || v_BlockingLockArray(RowIndex).LockingStatus);
        DBMS_OUTPUT.PUT_LINE('Program               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingProgram, 41)        || v_BlockingLockArray(RowIndex).LockingProgram);
        DBMS_OUTPUT.PUT_LINE('Waiter Lock Type      : ' || v_BlockingLockArray(RowIndex).WaiterLockType);
        DBMS_OUTPUT.PUT_LINE('Waiter Mode Request   : ' || v_BlockingLockArray(RowIndex).WaiterModeRequest);
        DBMS_OUTPUT.PUT_LINE('Waiting SQL           : ' || v_BlockingLockArray(RowIndex).SQLText);
        DBMS_OUTPUT.PUT(chr(10));
    END LOOP;
END;
/
quit;
EOF
}
#
#########################################################################################################
# LOCKED OBJECTS
#########################################################################################################
#
function DBA_031() {
sqlplus -S / as sysdba <<EOF
SET ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 500 PAGESIZE 50000 TERMOUT ON TIMING OFF TRIMOUT ON TRIMSPOOL ON VERIFY OFF timing on
prompt ##############################################################
prompt # LOCKED OBJECTS
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
COLUMN instance_name                FORMAT a9           HEADING 'Instance'
COLUMN sid                          FORMAT 999999       HEADING 'SID'
COLUMN sid_serial                   FORMAT a20          HEADING 'SID / Serial#'
COLUMN session_status               FORMAT a9           HEADING 'Status'
COLUMN locking_oracle_user          FORMAT a20          HEADING 'Locking Oracle User'
COLUMN object_owner                 FORMAT a20          HEADING 'Object Owner'
COLUMN object_name                  FORMAT a30          HEADING 'Object Name'
COLUMN object_type                  FORMAT a25          HEADING 'Object Type'
COLUMN locked_mode                  FORMAT a35          HEADING 'Locked Mode'
CLEAR BREAKS
select i.instance_name                    instance_name
  , l.session_id || ' / ' || s.serial#    sid_serial
  , s.status                              session_status
  , l.oracle_username                     locking_oracle_user
  , o.owner                               object_owner
  , o.object_name                         object_name
  , o.object_type                         object_type
  , DECODE (   l.locked_mode
             , 0, 'None'                        /* Mon Lock equivalent */
             , 1, 'NoLock'                      /* N */
             , 2, 'Row-Share (SS)'              /* L */
             , 3, 'Row-Exclusive (SX)'          /* R */
             , 4, 'Share-Table'                 /* S */
             , 5, 'Share-Row-Exclusive (SSX)'   /* C */
             , 6, 'Exclusive'                   /* X */
             ,    '[Nothing]' )                 locked_mode
FROM dba_objects       o
  , gv\$session        s
  , gv\$locked_object  l
  , gv\$instance       i
WHERE i.inst_id     = l.inst_id
  AND s.inst_id     = l.inst_id
  AND s.sid         = l.session_id
  AND o.object_id   = l.object_id
ORDER BY i.instance_name, l.session_id;
quit;
EOF
}
#
#########################################################################################################
# BLOCKING LOCKS [ SUMARY ]
#########################################################################################################
#
function DBA_032() {
sqlplus -S / as sysdba <<EOF
SET TERMOUT OFF TERMOUT ON ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 256 PAGESIZE 50000 TERMOUT ON TIMING ON TRIMOUT ON TRIMSPOOL ON VERIFY OFF timing on
prompt ##############################################################
prompt # BLOCKING LOCKS [ SUMARY ]
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
COLUMN waiting_instance_sid_serial  FORMAT a24          HEADING '[WAITING]|Instance - SID / Serial#'
COLUMN waiting_oracle_username      FORMAT a20          HEADING '[WAITING]|Oracle User'
COLUMN waiting_pid                  FORMAT a11          HEADING '[WAITING]|PID'
COLUMN waiting_machine              FORMAT a15          HEADING '[WAITING]|Machine'   TRUNC
COLUMN waiting_os_username          FORMAT a15          HEADING '[WAITING]|O/S User'
COLUMN waiter_lock_type_mode_req    FORMAT a35          HEADING 'Waiter Lock Type / Mode Requested'
COLUMN waiting_lock_time_min        FORMAT a10          HEADING '[WAITING]|Lock Time'
COLUMN waiting_instance_sid         FORMAT a15          HEADING '[WAITING]|Instance - SID'
COLUMN waiting_sql_text             FORMAT a105         HEADING '[WAITING]|SQL Text'    WRAP
COLUMN locking_instance_sid_serial  FORMAT a24          HEADING '[LOCKING]|Instance - SID / Serial#'
COLUMN locking_oracle_username      FORMAT a20          HEADING '[LOCKING]|Oracle User'
COLUMN locking_oracle_program       FORMAT a25          HEADING '[LOCKING]|Oracle Program'
COLUMN locking_pid                  FORMAT a11          HEADING '[LOCKING]|PID'
COLUMN locking_machine              FORMAT a15          HEADING '[LOCKING]|Machine'   TRUNC
COLUMN locking_os_username          FORMAT a15          HEADING '[LOCKING]|O/S User'
COLUMN locking_lock_time_min        FORMAT a10          HEADING '[LOCKING]|Lock Time'
COLUMN instance_name                FORMAT a8           HEADING 'Instance'
COLUMN sid                          FORMAT 999999       HEADING 'SID'
COLUMN session_status               FORMAT a9           HEADING 'Status'
COLUMN locking_oracle_user          FORMAT a20          HEADING 'Locking Oracle User'
COLUMN locking_os_user              FORMAT a20          HEADING 'Locking O/S User'
COLUMN locking_os_pid               FORMAT a11          HEADING 'Locking PID'
COLUMN locking_machine              FORMAT a15          HEADING 'Locking Machine'   TRUNC
COLUMN object_owner                 FORMAT a15          HEADING 'Object Owner'
COLUMN object_name                  FORMAT a25          HEADING 'Object Name'
COLUMN object_type                  FORMAT a15          HEADING 'Object Type'
COLUMN locked_mode                                      HEADING 'Locked Mode'
CLEAR BREAKS
select iw.instance_name || ' - ' || lw.sid || ' / ' || sw.serial#  waiting_instance_sid_serial
  , sw.username                                               waiting_oracle_username
  , ROUND(lw.ctime/60) || ' min.'                             waiting_lock_time_min
  , DECODE (   lh.type
             , 'CF', 'Control File'
             , 'DX', 'Distributed Transaction'
             , 'FS', 'File Set'
             , 'IR', 'Instance Recovery'
             , 'IS', 'Instance State'
             , 'IV', 'Libcache Invalidation'
             , 'LS', 'Log Start or Log Switch'
             , 'MR', 'Media Recovery'
             , 'RT', 'Redo Thread'
             , 'RW', 'Row Wait'
             , 'SQ', 'Sequence Number'
             , 'ST', 'Diskspace Transaction'
             , 'TE', 'Extend Table'
             , 'TT', 'Temp Table'
             , 'TX', 'Transaction'
             , 'TM', 'DML'
             , 'UL', 'PLSQL User_lock'
             , 'UN', 'User Name'
             , 'Nothing-' ) || ' / ' || DECODE ( lw.request
             , 0, 'None'                        /* Mon Lock equivalent */
             , 1, 'NoLock'                      /* N */
             , 2, 'Row-Share (SS)'              /* L */
             , 3, 'Row-Exclusive (SX)'          /* R */
             , 4, 'Share-Table'                 /* S */
             , 5, 'Share-Row-Exclusive (SSX)'   /* C */
             , 6, 'Exclusive'                   /* X */
             ,    '[Nothing]' )                                         waiter_lock_type_mode_req
  , ih.instance_name || ' - ' || lh.sid || ' / ' || sh.serial#          locking_instance_sid_serial
  , sh.username                                                         locking_oracle_username
  , sh.program                                                          locking_oracle_program
  , ROUND(lh.ctime/60) || ' min.'                                       locking_lock_time_min
FROM gv\$lock     lw
  , gv\$lock     lh
  , gv\$instance iw
  , gv\$instance ih
  , gv\$session  sw
  , gv\$session  sh
WHERE iw.inst_id  = lw.inst_id
  AND ih.inst_id  = lh.inst_id
  AND sw.inst_id  = lw.inst_id
  AND sh.inst_id  = lh.inst_id
  AND sw.sid      = lw.sid
  AND sh.sid      = lh.sid
  AND lh.id1      = lw.id1
  AND lh.id2      = lw.id2
  AND lh.request  = 0
  AND lw.lmode    = 0
  AND (lh.id1, lh.id2) IN (select id1, id2 FROM gv\$lock WHERE request = 0 INTERSECT select id1, id2 FROM gv\$lock WHERE lmode = 0)
ORDER BY iw.instance_name, lw.sid;
quit;
EOF
}
#
#########################################################################################################
# BLOCKING LOCKS [ USER DETAILS ]
#########################################################################################################
#
function DBA_033() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # BLOCKING LOCKS [ USER DETAILS ]
prompt ##############################################################
col waiting_instance_sid_serial for a30
col waiting_oracle_username for a15
col waiting_os_username for a15
col waiting_machine for a40
col waiting_pid for a10
col locking_instance_sid_serial for a30
col locking_oracle_username for a25
col locking_os_username for a20
col locking_machine for a20
col loocking_program for a20
col locking_pid for a10
select iw.instance_name || ' - ' || lw.sid || ' / ' || sw.serial#  waiting_instance_sid_serial
  , sw.username                                                    waiting_oracle_username
  , sw.osuser                                                      waiting_os_username
  , sw.machine                                                     waiting_machine
  , pw.spid                                                        waiting_pid
  , ih.instance_name || ' - ' || lh.sid || ' / ' || sh.serial#     locking_instance_sid_serial
  , sh.username                                                    locking_oracle_username
  , sh.osuser                                                      locking_os_username
  , sh.machine                                                     locking_machine
  , sh.program                                                     loocking_program
  , ph.spid                                                        locking_pid
FROM gv\$lock    lw
  , gv\$lock     lh
  , gv\$instance iw
  , gv\$instance ih
  , gv\$session  sw
  , gv\$session  sh
  , gv\$process  pw
  , gv\$process  ph
WHERE iw.inst_id  = lw.inst_id
  AND ih.inst_id  = lh.inst_id
  AND sw.inst_id  = lw.inst_id
  AND sh.inst_id  = lh.inst_id
  AND pw.inst_id  = lw.inst_id
  AND ph.inst_id  = lh.inst_id
  AND sw.sid      = lw.sid
  AND sh.sid      = lh.sid
  AND lh.id1      = lw.id1
  AND lh.id2      = lw.id2
  AND lh.request  = 0
  AND lw.lmode    = 0
  AND (lh.id1, lh.id2) IN (select id1, id2 FROM gv\$lock WHERE request = 0 INTERSECT select id1,id2 FROM gv\$lock WHERE lmode = 0)
  AND sw.paddr  = pw.addr (+)
  AND sh.paddr  = ph.addr (+)
ORDER BY iw.instance_name, lw.sid;
quit;
EOF
}
#
#########################################################################################################
# BLOCKING LOCKS [ WAITING SQL ]
#########################################################################################################
#
function DBA_034() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # BLOCKING LOCKS [ WAITING SQL ]
prompt ##############################################################
select iw.instance_name || ' - ' || lw.sid || ' / ' || sw.serial#  waiting_instance_sid_serial
  , aw.sql_text                                                    waiting_sql_text
FROM gv\$lock     lw
  , gv\$lock     lh
  , gv\$instance iw
  , gv\$instance ih
  , gv\$session  sw
  , gv\$session  sh
  , gv\$sqlarea  aw
WHERE iw.inst_id  = lw.inst_id
  AND ih.inst_id  = lh.inst_id
  AND sw.inst_id  = lw.inst_id
  AND sh.inst_id  = lh.inst_id
  AND aw.inst_id  = lw.inst_id
  AND sw.sid      = lw.sid
  AND sh.sid      = lh.sid
  AND lh.id1      = lw.id1
  AND lh.id2      = lw.id2
  AND lh.request  = 0
  AND lw.lmode    = 0
  AND (lh.id1, lh.id2) IN (select id1, id2 FROM gv\$lock WHERE request = 0 INTERSECT select id1, id2 FROM gv\$lock WHERE lmode = 0)
  AND sw.sql_address  = aw.address
ORDER BY iw.instance_name, lw.sid;
quit;
EOF
}
#
#########################################################################################################
# LOCKED OBJECTS [ DETAILS ]
#########################################################################################################
#
function DBA_035() {
sqlplus -S / as sysdba <<EOF
set pages 1000 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # LOCKED OBJECTS [ DETAILS ]
prompt ##############################################################
col INSTANCE for a10
col status for a10
col OBJECT_NAME for a30
col MACHINE for a30
col oracle_user for a15
col OS_USER for a15
col PROGRAM for a25
col USER for a10
col OWNER for a15
col OS_PID for a8
col LOCKED_MODE for a20
col OBJECT_TYPE for a15
col OBJECT_OWNER for a15
col LOCKING_OS_PID for a8
col LOCKING_OS_USER for a20
select i.instance_name        instance
  , l.session_id              sid
  , s.status                  status
  , l.oracle_username         oracle_user
  , o.owner                   owner
  , s.osuser                  os_user
  , s.machine                 machine
  , p.spid                    os_pid
  , o.object_name             object_name
  , o.object_type             object_type
  , s.program                 program
  , DECODE (   l.locked_mode
             , 0, 'None'                        /* Mon Lock equivalent */
             , 1, 'NoLock'                      /* N */
             , 2, 'Row-Share (SS)'              /* L */
             , 3, 'Row-Exclusive (SX)'          /* R */
             , 4, 'Share-Table'                 /* S */
             , 5, 'Share-Row-Exclusive (SSX)'   /* C */
             , 6, 'Exclusive'                   /* X */
             ,    '[Nothing]')                  locked_mode
FROM dba_objects       o
  , gv\$session        s
  , gv\$process        p
  , gv\$locked_object  l
  , gv\$instance       i
WHERE i.inst_id     = l.inst_id
  AND s.inst_id     = l.inst_id
  AND s.inst_id     = p.inst_id
  AND s.sid         = l.session_id
  AND o.object_id   = l.object_id
  AND s.paddr       = p.addr
ORDER BY i.instance_name, l.session_id;
quit;
EOF
}
#
#########################################################################################################
# DML AND DDL LOCKS
#########################################################################################################
#
function DBA_036() {
sqlplus -S / as sysdba <<EOF
SET TERMOUT OFF TERMOUT ON ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 256 PAGESIZE 50000 TERMOUT ON TRIMOUT ON TRIMSPOOL ON VERIFY OFF timing on colsep '|'
prompt ##############################################################
prompt # DML AND DDL LOCKS
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
COLUMN instance_name         FORMAT a10       HEADING 'Instance'
COLUMN sid_serial            FORMAT a15       HEADING 'SID / Serial#'
COLUMN session_status        FORMAT a9        HEADING 'Status'
COLUMN locking_oracle_user   FORMAT a20       HEADING 'Locking Oracle User'
COLUMN lock_type             FORMAT a9        HEADING 'Lock Type'
COLUMN mode_held             FORMAT a10       HEADING 'Mode Held'
COLUMN object                FORMAT a42       HEADING 'Object'
COLUMN program               FORMAT a20       HEADING 'Program'
COLUMN wait_time_sec         FORMAT 999,999   HEADING 'Wait Time (sec)'
COLUMN wait_time_min         FORMAT 999,999   HEADING 'Wait Time (min)'
COLUMN wait_time_hour        FORMAT 999,999   HEADING 'Wait Time (hour)'
CLEAR BREAKS
select i.instance_name                   instance_name
  , l.session_id || ' / ' || s.serial#   sid_serial
  , s.status                             session_status
  , s.username                           locking_oracle_user
  , l.lock_type                          lock_type
  , l.mode_held                          mode_held
  , o.owner || '.' || o.object_name      object
  , SUBSTR(s.program, 0, 20)             program
  , ROUND(w.seconds_in_wait, 2)          wait_time_sec
  , ROUND(w.seconds_in_wait/60, 2)       wait_time_min
  , ROUND(w.seconds_in_wait/60/60, 2)       wait_time_hour
FROM v\$instance      i
   , v\$session       s
   , dba_locks        l
   , dba_objects      o
   , v\$session_wait  w
WHERE s.sid = l.session_id
AND l.lock_type IN ('DML','DDL')
AND l.lock_id1 = o.object_id
AND l.session_id = w.sid
ORDER BY i.instance_name, l.session_id;
quit;
EOF
}
#
#########################################################################################################
# DML TABLE LOCKS TIME
#########################################################################################################
#
function DBA_037() {
sqlplus -S / as sysdba <<EOF
SET TERMOUT ON TERMOUT ON ECHO OFF FEEDBACK 6 HEADING ON LINESIZE 256 PAGESIZE 50000 TERMOUT ON TIMING ON TRIMOUT ON TRIMSPOOL ON VERIFY OFF timing on colsep '|'
prompt ##############################################################
prompt # DML TABLE LOCKS TIME
prompt ##############################################################
CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES
COLUMN instance_name                FORMAT a10          HEADING 'Instance'
COLUMN locking_oracle_user          FORMAT a20          HEADING 'Locking Oracle User'
COLUMN sid_serial                   FORMAT a15          HEADING 'SID / Serial#'
COLUMN mode_held                    FORMAT a15          HEADING 'Mode Held'
COLUMN mode_requested               FORMAT a15          HEADING 'Mode Requested'
COLUMN lock_type                    FORMAT a15          HEADING 'Lock Type'
COLUMN object                       FORMAT a42          HEADING 'Object'
COLUMN program                      FORMAT a20          HEADING 'Program'
COLUMN lock_time_min                FORMAT 999,999      HEADING 'Lock Time (min)'
COLUMN lock_time_hours              FORMAT 999,999      HEADING 'Lock Time (hours)'
COLUMN lock_time_days               FORMAT 999,999      HEADING 'Lock Time (days)'
CLEAR BREAKS
select i.instance_name instance_name
  , l.sid || ' / ' || s.serial# sid_serial
  , s.username locking_oracle_user
  , DECODE(   l.lmode
            , 1, NULL
            , 2, 'Row Share'
            , 3, 'Row Exclusive'
            , 4, 'Share'
            , 5, 'Share Row Exclusive'
            , 6, 'Exclusive'
            ,    'None') mode_held
  , DECODE(   l.request
            , 1, NULL
            , 2, 'Row Share'
            , 3, 'Row Exclusive'
            , 4, 'Share'
            , 5, 'Share Row Exclusive'
            , 6, 'Exclusive'
            ,    'None') mode_requested
  , DECODE (   l.type
             , 'CF', 'Control File'
             , 'DX', 'Distributed Transaction'
             , 'FS', 'File Set'
             , 'IR', 'Instance Recovery'
             , 'IS', 'Instance State'
             , 'IV', 'Libcache Invalidation'
             , 'LS', 'Log Start or Log Switch'
             , 'MR', 'Media Recovery'
             , 'RT', 'Redo Thread'
             , 'RW', 'Row Wait'
             , 'SQ', 'Sequence Number'
             , 'ST', 'Diskspace Transaction'
             , 'TE', 'Extend Table'
             , 'TT', 'Temp Table'
             , 'TX', 'Transaction'
             , 'TM', 'DML'
             , 'UL', 'PLSQL User_lock'
             , 'UN', 'User Name'
             ,       'Nothing'
           ) lock_type
  , o.owner || '.' || o.object_name object
  , ROUND(l.ctime/60, 2) lock_time_min
  , ROUND(l.ctime/60/60, 2) lock_time_hours
  , ROUND(l.ctime/60/60/24, 2) lock_time_days
FROM v\$instance    i
   , v\$session     s
   , v\$lock        l
   , dba_objects    o
   , dba_tables     t
WHERE l.id1            =  o.object_id
  AND s.sid            =  l.sid
  AND o.owner          =  t.owner
  AND o.object_name    =  t.table_name
  AND o.owner          <> 'SYS'
  AND l.type           =  'TM'
ORDER BY i.instance_name, l.sid;
quit;
EOF
}
#
#########################################################################################################
# VERIFY SESSIONS [ @ ]
#########################################################################################################
#
function DBA_038() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY SESSIONS [ @ ]
prompt ##############################################################
col MACHINE for a45
col OSUSER for a25
col EVENT for a30
col PROGRAM for a60
col username for a20
select MACHINE
  , OSUSER
  , USERNAME
  , SID
  , SERIAL#
  , event
  , PROGRAM
from v\$session
where osuser not in ('GRID','grid','ORACLE','oracle')
order by 1,2,5,6;
quit;
EOF
}
#
#########################################################################################################
# TOP 20 DATABASE SESSIONS
#########################################################################################################
#
function DBA_039() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # TOP 20 DATABASE SESSIONS
prompt ##############################################################
col rank form 99
col sql_id for a15
col MACHINE for a30
col event for a30
col username for a25
col OSUSER for a25
col PROGRAM for a40
select rownum as rank
  , a.sid
  , a.serial#
  , a.sql_id
  , a.username
  , a.osuser
  , a.machine
  , a.program
--  , a.event
  , a.CPUMins
  , a.CPUHours
  , a.CPUDays
from (select v.sid
        , serial#
	, sql_id
        , username
        , osuser
        , machine
        , program
--	, event
    , round(v.value/(100*60), 0) CPUMins
	, round(v.value/60/60)/100 CPUHours
	, round(v.value/60/60/24)/100 CPUDays
        FROM gv\$statname s, gv\$sesstat v, gv\$session sess
        WHERE s.name = 'CPU used by this session'
          and sess.sid = v.sid
          and v.statistic# = s.statistic#
          and v.value > 0
      ORDER BY v.value DESC) a
where rownum < 21
and osuser not in ('GRID','grid','ORACLE','oracle');
quit;
EOF
}
#
#########################################################################################################
# VERIFY TABLESPACES
#########################################################################################################
#
function DBA_040() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # Tablespaces                                                #
prompt ##############################################################
col "USAGE (%)"          for a9
col "FREE (%)"           for a9
col Tablespace           for a20
col "Type"               for a12
col "USED USAGE"         for a12
col "FREE USAGE"         for a12
col "USED SIZE(MB)"      for a12
col "USED SIZE(GB)"      for a12
col "USED SIZE(TB)"      for a12
col "FREE SIZE(MB)"      for a12
col "FREE SIZE(GB)"      for a12
col "FREE SIZE(TB)"      for a12
col "MAX SIZE"           for a12
col "Status"             for a7
col "Status Size"        for a13
column "USED SIZE(MB)"   format 9g999g999g990 heading  'USED SIZE(MB)'
column "USED SIZE(GB)"   format 9g999g999g990 heading  'USED SIZE(GB)'
column "USED SIZE(TB)"   format 9g999g999g990 heading  'USED SIZE(TB)'
column "FREE SIZE(MB)"   format 9g999g999g990 heading  'FREE SIZE(MB)'
column "FREE SIZE(GB)"   format 9g999g999g990 heading  'FREE SIZE(GB)'
column "FREE SIZE(TB)"   format 9g999g999g990 heading  'FREE SIZE(TB)'
column "TOTAL SIZE(MB)"  format 9g999g999g990 heading  'TOTAL SIZE(MB)'
column "TOTAL SIZE(GB)"  format 9g999g999g990 heading  'TOTAL SIZE(GB)'
column "TOTAL SIZE(TB)"  format 9g999g999g990 heading  'TOTAL SIZE(TB)'
column "MAX SIZE(GB)"    format 9g999g999g990 heading  'MAX SIZE(GB)'
break on report
compute sum of "USED SIZE(MB)"   on report
compute sum of "USED SIZE(GB)"   on report
compute sum of "USED SIZE(TB)"   on report
compute sum of "FREE SIZE(MB)"   on report
compute sum of "FREE SIZE(GB)"   on report
compute sum of "FREE SIZE(TB)"   on report
compute sum of "TOTAL SIZE(MB)"  on report
compute sum of "TOTAL SIZE(GB)"  on report
compute sum of "TOTAL SIZE(TB)"  on report
compute sum of "MAX SIZE(GB)"    on report
select substr(A.tablespace_name,1,20) "Tablespace"
   , MAX(A.contents) "Type"
   , MAX(A.status) "Status"
-- , MAX(A.max_extents) "Max extents"
-- , MAX(A.pct_increase) "Pct_increase"
   , (SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024)-(ROUND(SUM(C.BYTES)/1024/1024/COUNT(DISTINCT B.FILE_ID))) "USED SIZE(MB)"
   , ROUND(SUM(C.BYTES)/1024/1024/COUNT(DISTINCT B.FILE_ID)) "FREE SIZE(MB)"
   , SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024 "TOTAL SIZE(MB)"
   , (SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024)-(ROUND(SUM(C.BYTES)/1024/1024/1024/COUNT(DISTINCT B.FILE_ID))) "USED SIZE(GB)"
   , ROUND(SUM(C.BYTES)/1024/1024/1024/COUNT(DISTINCT B.FILE_ID)) "FREE SIZE(GB)"
   , SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024 "TOTAL SIZE(GB)"
-- , (SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024/1024)-(ROUND(SUM(C.BYTES)/1024/1024/1024/1024/COUNT(DISTINCT B.FILE_ID))) "USED SIZE(TB)"
   , ROUND(SUM(C.BYTES)/1024/1024/1024/1024/COUNT(DISTINCT B.FILE_ID)) "FREE SIZE(TB)"
   , SUM(B.BYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024/2014 "TOTAL SIZE(TB)"
-- , (SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID))-(SUM(C.BLOCKS)/COUNT(DISTINCT B.FILE_ID)) "USED BLOCKS"
-- , SUM(C.BLOCKS)/COUNT(DISTINCT B.FILE_ID) "FREE BLOCKS"
   , TO_CHAR(100-(SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID),'999.99') || '%' "USAGE (%)"
   , TO_CHAR((SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID),'999.99') || '%' "FREE (%)"
-- , SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID) "TOTAL BLOCKS"
   , SUM(B.MAXBYTES)*COUNT(DISTINCT B.FILE_ID)/COUNT(B.FILE_ID)/1024/1024/1024 "MAX SIZE(GB)"
   , case
       when TO_CHAR(100-(SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID)) < 80 then 'Size OK'
       when TO_CHAR(100-(SUM(C.BLOCKS)*100*COUNT(B.FILE_ID)/(SUM(B.BLOCKS)*COUNT(DISTINCT B.FILE_ID)))/COUNT(DISTINCT B.FILE_ID)) < 90 then 'Warning'
       else 'Critical' end as "Status Size"
from dba_tablespaces A, DBA_DATA_FILES B, DBA_FREE_SPACE C
WHERE A.TABLESPACE_NAME=B.TABLESPACE_NAME
AND A.TABLESPACE_NAME=C.TABLESPACE_NAME
GROUP BY A.TABLESPACE_NAME
order by 1;
prompt
prompt ##############################################################
prompt # Datafiles                                                  #
prompt ##############################################################
TTITLE OFF
BTITLE OFF
SET FEEDBACK ON
column "Size (M)" format 9g999g999g990     heading 'Size (M)'
column "Size (G)" format 9g999g999g990     heading 'Size (G)'
column "Used (M)" format 9g999g999g990     heading 'Used (M)'
column "Used (G)" format 9g999g999g990     heading 'Used (G)'
column "Free (M)" format 9g999g999g990     heading 'Free (M)'
column "Free (G)" format 9g999g999g990     heading 'Free (G)'
column "MAX (G)"  format 9g999g999g990     heading 'MAX (G)'
col "FILE NAME"          for a80
col "AUTOEXTENSIBLE"     for a15
col "Status"             for a10
col "Tablespace Name"    for a20
col "Used (%)"           for a11
-- col "Size (M)"        for a11
-- col "Size (g)"        for a11
-- col "Used (M)"        for a15
-- col "Used (G)"        for a15
-- col "Free (M)"        for a15
-- col "Free (G)"        for a15
-- col "Max (G)"         for a15
select Substr(df.tablespace_name,1,20)           "Tablespace Name"
  , Substr(df.file_name, 1, 80)                  "File Name"
--  , AUTOEXTENSIBLE as                          "AUTOEXTENSIBLE"
  , status as                                    "Status"
  , round(df.bytes/1024/1024, 2)                 "Size (M)"
  , round(e.used_bytes/1024/1024, 2)             "Used (M)"
  , round(f.free_bytes/1024/1024, 2)             "Free (M)"
--  , case when round(df.bytes/1024/1024, 2) = round(e.used_bytes/1024/1024, 2) then 'Full/100%' else to_char(round(f.free_bytes/1024/1024, 2)) end as "Free (M)"
  , round(df.bytes/1024/1024/1024, 2)            "Size (G)"
  , round(e.used_bytes/1024/1024/1024, 2)        "Used (G)"
  , round(f.free_bytes/1024/1024/1024, 2)        "Free (G)"
--  , case when Round(df.bytes/1024/1024/1024, 2) = Round(e.used_bytes/1024/1024/1024, 2) then 'Full/100%' else to_char(Round(f.free_bytes/1024/1024/1024, 2)) end as "Free (G)"
  , df.maxbytes/1024/1024/1024 as                "Max (G)"
  , rpad(' '|| Rpad ('X',Round(e.used_bytes*10/df.bytes,0), 'X'),11,'-') "Used (%)"
FROM DBA_DATA_FILES df,
   (select file_id, Sum(Decode(bytes,NULL,0,bytes)) used_bytes FROM dba_extents GROUP by file_id) E,
   (select Max(bytes) free_bytes, file_id FROM dba_free_space GROUP BY file_id) f
WHERE e.file_id (+) = df.file_id
AND df.file_id = f.file_id (+)
ORDER BY df.tablespace_name, df.file_name;
prompt
prompt ##############################################################
prompt # TempFiles                                                  #
prompt ##############################################################
column "Size (M)" format 9g999g999 heading 'Size (M)'
column "Used (M)" format 9g999g999 heading 'Used (M)'
column "Free (M)" format 9g999g999 heading 'Free (M)'
column "Size (G)" format 9g999g999 heading 'Size (G)'
column "Used (G)" format 9g999g999 heading 'Used (G)'
column "Free (G)" format 9g999g999 heading 'Free (G)'
column "MAX (G)"  format 9g999g999 heading 'MAX (G)'
col "FILE NAME"          for a80
col "AUTOEXTENSIBLE"     for a15
col "Status"             for a10
col "Tablespace Name"    for a20
col "Used (%)"           for a11
col "Free (M)"           for a9
col "Free (G)"           for a9
-- col "Max (G)"         for a15
select substr(df.tablespace_name,1,20) as    "Tablespace Name"
  , substr(df.file_name, 1, 80) as           "File Name"
  , AUTOEXTENSIBLE as                        "AUTOEXTENSIBLE"
  , status as                                "Status"
  , round(df.bytes/1024/1024, 2) as          "Size (M)"
  , round(e.used_bytes/1024/1024, 2) as      "Used (M)"
  , case when Round(df.bytes/1024/1024, 2) = Round(e.used_bytes/1024/1024, 2) then 'Full/100%' else to_char(Round(f.free_bytes/1024/1024, 2)) end as "Free (M)"
  , round(df.bytes/1024/1024/1024, 2) as     "Size (G)"
  , round(e.used_bytes/1024/1024/1024, 2) as "Used (G)"
  , case when Round(df.bytes/1024/1024/1024, 2) = Round(e.used_bytes/1024/1024/1024, 2) then 'Full/100%' else to_char(Round(f.free_bytes/1024/1024/1024, 2)) end as "Free (G)"
  , df.maxbytes/1024/1024/1024 as            "Max (G)"
  , rpad(' '|| Rpad ('X',Round(e.used_bytes*10/df.bytes,0), 'X'),11,'-') as "Used (%)"
FROM DBA_TEMP_FILES df,
   (select file_id, sum(Decode(bytes,NULL,0,bytes)) used_bytes FROM dba_extents GROUP by file_id) E,
   (select max(bytes) free_bytes, file_id FROM dba_free_space GROUP BY file_id) f
WHERE e.file_id (+) = df.file_id
AND df.file_id  = f.file_id (+)
ORDER BY df.tablespace_name, df.file_name;
quit;
EOF
}
#
#########################################################################################################
# VERIFY STATISTICS - TABLES [ @ ]
#########################################################################################################
#
function DBA_041() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY STATISTICS - TABLES [ @ ]
prompt ##############################################################
col schema for a20
col object for a50
select S.Owner as                                        "Schema"
  , S.Table_Name as                                      "Object"
  , S.Object_Type as                                     "Object Type"
  , S.Num_Rows as                                        "Qtd. of Lines"
  , To_Char(S.Last_Analyzed, 'dd/mm/yyyy HH24:mm:ss') as "Last Analyzed"
  , case when S.Last_Analyzed > sysdate - 7
    then 'Status OK' when S.Last_Analyzed > sysdate - 30 then 'Warning' else 'Critical' end as "Status of Statistics"
FROM sys.dba_tab_statistics S
ORDER BY S.Owner, S.Table_Name, S.Num_Rows, S.Last_Analyzed;
prompt
prompt ##############################################################
prompt # Quantity of Objects with Status OK - (Collected on the lasts 7 days)
prompt ##############################################################
col owner for a30
select a.owner, count(*)
from sys.dba_tab_statistics a
where a.last_analyzed > sysdate - 7
group by a.owner
order by a.owner;
prompt
prompt ##############################################################
prompt # Quantity of Objects with Warning - (Collected between 7 and 30 days)
prompt ##############################################################
col owner for a30
select a.owner, count(*)
from sys.dba_tab_statistics a
where a.last_analyzed < sysdate - 7
and a.last_analyzed < sysdate - 30
group by a.owner
order by a.owner;
prompt
prompt ##############################################################
prompt # Quantity of Objects with Critical - (Collected more them 30 days)
prompt ##############################################################
col owner for a30
select a.owner, count(*)
from sys.dba_tab_statistics a
where a.last_analyzed > sysdate - 30
and a.last_analyzed < sysdate - 90
group by a.owner
order by a.owner;
quit;
EOF
}
#
#########################################################################################################
# VERIFY STATISTICS - INDEXES [ @ ]
#########################################################################################################
#
function DBA_042() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY STATISTICS - INDEXES [ @ ]
prompt ##############################################################
col schema for a20
col object for a50
select S.Owner as                                        "Schema"
  , S.Table_Name as                                      "Object"
  , S.Object_Type as                                     "Object Type"
  , S.Num_Rows as                                        "Qtd. of Lines"
  , To_Char(S.Last_Analyzed, 'dd/mm/yyyy HH24:mm:ss') as "Last Analyzed"
  , case when S.Last_Analyzed > sysdate - 7 then 'Status OK' when S.Last_Analyzed > sysdate -30 then 'Warning' else 'Critical' end as "Status of Statistics"
FROM sys.dba_ind_statistics S
ORDER BY S.Owner, S.Table_Name, S.Num_Rows, S.Last_Analyzed;
prompt ##############################################################
prompt # Quantity of Objects with Status OK - (Collected on the lasts 7 days)
prompt ##############################################################
prompt
col owner for a30
select a.owner, count(*)
from sys.dba_ind_statistics a
where a.last_analyzed > sysdate - 7
group by a.owner
order by a.owner;
prompt ##############################################################
prompt # Quantity of Objects with Warning - (Collected between 7 and 30 days)
prompt ##############################################################
prompt
col owner for a30
select a.owner, count(*)
from sys.dba_ind_statistics a
where a.last_analyzed < sysdate - 7
group by a.owner
order by a.owner;
prompt ##############################################################
prompt # Quantity of Objects with Critical - (Collected more them 30 days)
prompt ##############################################################
prompt
col owner for a30
select a.owner, count(*)
from sys.dba_ind_statistics a
where a.last_analyzed > sysdate - 30
group by a.owner
order by a.owner;
quit;
EOF
}
#
#########################################################################################################
# CAPTURE STATISTICS - OWNER [ @ ]
#########################################################################################################
#
function DBA_043() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # CAPTURE STATISTICS - OWNER [ @ ]
prompt ##############################################################
col username for a30
col account_status for a25
col profile for a25
col default_tablespace for a25
col temporary_tablespace for a25
select username
   , account_status
   , profile
   , default_tablespace
   , temporary_tablespace
from dba_users
order by 1;
quit;
EOF
# DBA_043B $1
}
#
#########################################################################################################
# CAPTURE STATISTICS - OWNER [ @ ]
#########################################################################################################
#
function DBA_043B() {
local OPT=$1
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
begin
  dbms_stats.gather_schema_stats('${OPT}', estimate_percent => dbms_stats.auto_sample_size, cascade => true);
end;
/
quit;
EOF
}
#
#########################################################################################################
# VALIDATE OBJECTS FROM ONE OWNER [ @ ]
#########################################################################################################
#
function DBA_044() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VALIDATE OBJECTS FROM ONE OWNER [ @ ]
prompt ##############################################################
col username for a30
col account_status for a25
col profile for a25
col default_tablespace for a25
col temporary_tablespace for a25
select username
   , account_status
   , profile
   , default_tablespace
   , temporary_tablespace
from dba_users
order by 1;
quit;
EOF
# DBA_044B $1
}
#
#########################################################################################################
# VALIDATE OBJECTS FROM ONE OWNER [ @ ]
#########################################################################################################
#
function DBA_044B() {
sqlplus -S / as sysdba <<EOF
local OPT=$1
set pages 700 lines 1000 timing on numwidth 20 SERVEROUTPUT ON FEEDBACK OFF colsep '|'
begin
  dbms_utility.compile_schema('${OPT}',false);
end;
/
quit;
EOF
}
#
#########################################################################################################
# VERIFY TABLES SIZE, VALIDATE OBJ - OWNERS [ @ ]
#########################################################################################################
#
function DBA_045() {
sqlplus -S / as sysdba <<EOF
set pages 5000 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY TABLES SIZE, VALIDATE OBJ - OWNERS [ @ ]
prompt ##############################################################
col "OWNER" for a25
col "Table Name" for a35
col "Table Space" for a25
col "Last Analyzed" for a30
col "Status of Statistics" for a20
select t.owner as                                        "OWNER"
  , t.table_name as                                      "Table Name"
  , t.TABLESPACE_NAME as                                 "Table Space"
  , t.num_rows as                                        "Rows"
  , t.avg_row_len as                                     "Avg Row Len"
  , trunc((t.blocks * p.value)/1024/1024) as             "Size MB" -- numero de blocos X o seu tamanho em KBs
  , to_Char(t.Last_Analyzed, 'DD/MM/YYYY HH24:mm:ss') as "Last Analyzed"
  , case when t.Last_Analyzed > sysdate - 7 then 'Status OK' when t.Last_Analyzed > sysdate - 30 then 'Warning' else 'Critical' end as "Status of Statistics"
FROM dba_tables t, v\$parameter p
WHERE p.name = 'DBA_block_size'
ORDER BY 1,2;
quit;
EOF
}
#
#########################################################################################################
# OWNER X OBJECTS X TYPE X QTD
#########################################################################################################
#
function DBA_046() {
sqlplus -S / as sysdba <<EOF
set pages 2000 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # OWNER X OBJECTS X TYPE X QTD
prompt ##############################################################
col owner for a30
col object_type for a20
Clear Breaks
Break on owner Skip 1
Compute Sum LABEL 'TOTAL' Of Qtde On owner
select owner, object_type, count(*) Qtde from dba_objects where owner not in ('SYS','SYSTEM','SYSMAN','DBSNMP') group by owner, object_type
union
select owner, 'CONSTRAINT ' || constraint_type, count(*) from dba_constraints where owner not in ('SYS','SYSTEM','SYSMAN','DBSNMP') group by owner, 'CONSTRAINT ' || constraint_type
/
quit;
EOF
}
#
#########################################################################################################
# VERIFY INSTANCE CHARACTERSET
#########################################################################################################
#
function DBA_047() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY INSTANCE CHARACTERSET
prompt ##############################################################
col parameter for a50
col value for a50
select * from nls_database_parameters;
quit;
EOF
}
#
#########################################################################################################
# CACHE HIT RATIO [ GOOD: > 90% ]
#########################################################################################################
#
function DBA_048() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # CACHE HIT RATIO [ GOOD: > 90% ]
prompt ##############################################################
select sum(gets) "Data Dict Gets"
   , sum(getmisses) "Data Dict Cache Misses"
   , round((1-(sum(getmisses)/sum(gets)))*100) "DATA DICT CACHE HIT RATIO"
   , round(sum(getmisses)*100/sum(gets)) "% MISSED"
   , case when round((1-(sum(getmisses)/sum(gets)))*100) < 90 then 'Critical' else 'Status OK' end as status
from v\$rowcache;
quit;
EOF
}
#
#########################################################################################################
# VERIFY INSTANCE INSTALLED PRODUCTS
#########################################################################################################
#
function DBA_049() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY INSTANCE INSTALLED PRODUCTS
prompt ##############################################################
col version_full for a15
col status for a10
col schema for a12
col comp_name for a40
select comp_name
  , version_full
  , status
  , modified
--  , to_char(modified, 'DD/MM/YYYY HH24:MM:SS') as modified
  , schema
  , status
FROM dba_registry
order by 1, 2, 3;
quit;
EOF
}
#
#########################################################################################################
# INSTANCE PROPERTIES
#########################################################################################################
#
function DBA_050() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # INSTANCE PROPERTIES
prompt ##############################################################
COLUMN PROPERTY_NAME FORMAT A70
COLUMN PROPERTY_VALUE FORMAT A70
select PROPERTY_NAME
  , PROPERTY_VALUE
FROM database_properties
ORDER BY PROPERTY_NAME;
quit;
EOF
}
#
#########################################################################################################
# INSTANCE OPTIONS
#########################################################################################################
#
function DBA_051() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # INSTANCE OPTIONS
prompt ##############################################################
col value for A10
col parameter for A50
select * FROM v\$option
ORDER BY parameter;
quit;
EOF
}
#
#########################################################################################################
# INSTANCE DIFFERENTS PARAMETERS
#########################################################################################################
#
function DBA_052() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # INSTANCE DIFFERENTS PARAMETERS
prompt ##############################################################
COLUMN name          FORMAT A30
COLUMN current_value FORMAT A110
COLUMN sid           FORMAT A10
COLUMN spfile_value  FORMAT A70
select p.name
  , i.instance_name as sid
  , upper(p.value) as current_value
  , sp.sid
  , upper(sp.value) as spfile_value
FROM v\$spparameter sp
  , v\$parameter p
  , v\$instance i
WHERE sp.name = p.name
AND upper(sp.value) != upper(p.value);
quit;
EOF
}
#
# select name, VALUE, ISSYS_MODIFIABLE from SYS.V\$PARAMETER
#
#########################################################################################################
# INSTANCE MODIFICABLES PARAMETERS
#########################################################################################################
#
function DBA_053() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # INSTANCE MODIFICABLES PARAMETERS
prompt ##############################################################
COLUMN name  FORMAT A50
COLUMN value FORMAT A110
select p.name
  , p.type
  , p.value
  , p.isses_modifiable
  , p.issys_modifiable
  , p.isinstance_modifiable
FROM v\$parameter p
ORDER BY p.name;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DEAD LOCKS
#########################################################################################################
#
function DBA_054() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # WHICH SESSION IS BLOCKING OTHER SESSION                    #
prompt ##############################################################
select (select username FROM gv\$session WHERE sid=a.sid) blocker
  , a.sid
  , ' is blocking ' as BLOCKING
  , (select username FROM gv\$session WHERE sid=b.sid) blockee
  , b.sid
FROM gv\$lock a, gv\$lock b
WHERE a.block = 1
AND b.request > 0
AND a.id1 = b.id1
AND a.id2 = b.id2;
prompt
prompt ##############################################################
prompt # VERIFY DEAD LOCKS
prompt ##############################################################
col username form A15
col sid form 9999999
col type form A4
col lmode form 9999999
col request form 9999999
col id1 form 9999990
col id2 form 9999990
col lmode for a20
col request for a20
break on id1 skip 1 dup
select sn.username
  , m.sid
  , m.type
  , DECODE(m.lmode, 0, 'None', 1, 'Null', 2, 'Row Share', 3, 'Row Excl.', 4, 'Share', 6, 'Exclusive', 5, 'S/Row Excl.', lmode, ltrim(to_char(lmode,'990'))) lmode
  , DECODE(m.request, 0, 'None', 1, 'Null', 2, 'Row Share', 3, 'Row Excl.', 4, 'Share', 5, 'S/Row Excl.', 6, 'Exclusive', request, ltrim(to_char(request,'990'))) request
  , m.id1
  , m.id2
FROM gv\$session sn, gv\$lock m
WHERE (sn.sid = m.sid AND m.request != 0) OR (sn.sid = m.sid AND m.request = 0 AND lmode != 4 AND (id1, id2)
IN (select s.id1, s.id2 FROM gv\$lock s WHERE request != 0 AND s.id1 = m.id1 AND s.id2 = m.id2))
ORDER BY id1,id2, m.request;
clear breaks
quit;
EOF
}
#
#########################################################################################################
# select (select username FROM gv$session WHERE sid=a.sid) blocker
#   , a.sid || ',' || (select serial# from gv$session c where sid=a.sid) sess1
#   , ' is blocking ' as BLOCKING
#   , (select username FROM gv$session WHERE sid=b.sid) blockee
#   , b.sid || ',' || (select serial# from gv$session c where sid=b.sid) sess2
# FROM gv$lock a, gv$lock b
# WHERE a.block = 1
# AND b.request > 0
# AND a.id1 = b.id1
# AND a.id2 = b.id2;
#########################################################################################################
#
#########################################################################################################
# VERIFY SESSIONS PER I/O CONSUME
#########################################################################################################
#
function DBA_055() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY SESSIONS PER I/O CONSUME
prompt ##############################################################
clear breaks compute
set feedback 6 feedback off linesize 300 pagesize 10000 verify off echo on heading on timing on colsep '|'
undefine topN topStat topUser
define topN=3
define topStat=%
define pctMinimo=1
column sid for a15
column top_stat_name format a35 heading 'STATISTIC_NAME' trunc
column sess_status format a10 heading 'STATUS' truncate
column username_osuser format a30 heading 'USERNAME/OSUSER'
column minutos format 9999 heading 'MIN'
column statistic_value format 9g999g999g999g990 heading 'STATISTIC_VAL'
column conn_time format a20 heading 'CONNECTED ON'
col "CONNECTED ON" for a20
column rank format 99
break on top_stat_name skip 1
compute sum of pct on statistic_name
select statistic_name as top_stat_name
   , rank
   , pct
   , sid || '/' || serial# as sid
   , decode( username, null, '(' || bg_name || ')', username) || decode(osuser, null, null, '/') || substr(osuser, 1+instr(osuser, '\')) as username_osuser
   , lpad(decode(trunc(sysdate - logon_time), 0, null, trunc(sysdate - logon_time) || 'd, ') || to_char(to_date(trunc(86400 * ((sysdate-logon_time) - trunc(sysdate - logon_time))), 'SSSSS'), 'hh24"h "mi"m"'), 10) as conn_time
   , round(last_call_et/60, 1) as minutos
   , decode(status, 'ACTIVE', 'ACTIVE', 'INACTIVE', 'INACTIVE', status) as sess_status
   , statistic_value
from (select sn.name as statistic_name
    , row_number() over (partition by sn.name order by sn.name, sv.value desc) as rank
    , 100 * ratio_to_report(sv.value) over (partition by sn.name) as pct
    , sv.value as statistic_value
    , bg.name as bg_name
    , ss.*
from v\$sesstat sv
    , v\$statname sn
    , v\$session ss
    , v\$bgprocess bg
where sn.statistic# = sv.statistic#
and ss.sid = sv.sid
and ss.paddr = bg.paddr(+)
and ss.type != 'BACKGROUND'
and ((status = 'INACTIVE' and last_call_et/60 < 5) or status = 'ACTIVE') and sv.value > 0
and sn.name
in ( 'consistent gets'
   , 'db block gets'
   , 'physical reads'
   , 'physical writes'
-- , 'physical reads direct'
-- , 'physical writes direct'
-- , 'bytes sent via SQL*Net to client'
-- , 'bytes received via SQL*Net from dblink'
-- , 'bytes sent via SQL*Net to dblink'
-- , 'enqueue releases'
-- , 'enqueue requests'
   , 'enqueue waits'
-- , 'recursive cpu usage'
-- , 'session logical reads'
-- , 'session pga memory'
-- , 'session uga memory'
   , 'session pga memory max'
   , 'session uga memory max'
   , 'execute count'
   , 'parse count (hard)'
-- , 'parse time cpu'
-- , 'parse time elapsed'
-- , 'parse count (total)'
-- , 'sorts (disk)'
-- , 'sorts (memory)'
   , 'sorts (rows)'
   , 'table scans (long tables)'
   , 'table fetch continued row'))
where trunc(pct) > &pctMinimo    -- percentuais maiores que pctMinimo
and rank < 1+&topN               -- "N" maiores sessoes que consomem aquele recurso
and upper(statistic_name) like upper('%&topStat.%') ;
quit;
EOF
}
#
#########################################################################################################
# VERIFY FREE SEGMENTS ON DATAFILES
#########################################################################################################
#
function DBA_056() {
sqlplus -S / as sysdba <<EOF
set pages 5000 lines 5000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY FREE SEGMENTS ON DATAFILES
prompt ##############################################################
col "Name" for a50
select file_id
  , block_id
  , blocks*8192/1024 MB
  , owner || '.' || segment_name "Name"
  , block_id*8192/1024 "Position MB"
from  dba_Extents
where file_id = 21
union
select file_id
  , block_id
  , blocks*8192/1024, 'Free' "Name"
  , block_id*8192/1024 "Position MB"
from dba_free_space
order by 1,2,3;
quit;
EOF
}
#
#########################################################################################################
# VERIFY WHICH DATAFILE CAN BE RESIZED [ @ ]
#########################################################################################################
#
function DBA_057() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY WHICH DATAFILE CAN BE RESIZED [ @ ]
prompt ##############################################################
column file_name format a120 word_wrapped
column smallest format 999,999,990 heading "Smallest|Size|Poss."
column currsize format 999,999,990 heading "Current|Size"
column savings format 999,999,990 heading "Poss.|Savings"
break on report
compute sum of smallest on report
compute sum of currsize on report
compute sum of savings on report
column value new_val blksize for a10
prompt ##############################################################
PROMPT # DB BLOCK SIZE                                              #
prompt ##############################################################
select value from v\$parameter where name = 'DBA_block_size';
prompt
prompt ##############################################################
prompt # INFORMATIONS ABOUT DATAFILES                               #
prompt ##############################################################
select 'DATAFILE ' as DATAFILE
  , file_name
  , ceil((nvl(hwm,1)*&&blksize)/1024/1024 ) smallest
  , ceil(blocks*&&blksize/1024/1024) currsize
  , ceil(blocks*&&blksize/1024/1024) - ceil((nvl(hwm,1)*&&blksize)/1024/1024) savings
  , case when ceil(blocks*&&blksize/1024/1024) - ceil((nvl(hwm,1)*&&blksize)/1024/1024) > 100 then 'Recomended' else 'Not Recomended' end as "Recomendation"
from dba_data_files a, (select file_id, max(block_id+blocks-1) hwm from dba_extents group by file_id) b
where a.file_id = b.file_id(+);
prompt
prompt ##############################################################
prompt # COMMANDS TO RESIZE THE DATAFILES                           #
prompt ##############################################################
column "SQL Command" for a175 word_wrapped
select 'alter database datafile ''' || file_name || ''' resize ' || ceil((nvl(hwm,1)*&&blksize)/1024/1024) || 'M;' as "SQL Command"
from dba_data_files a, (select file_id, max(block_id+blocks-1) hwm from dba_extents group by file_id) b
where a.file_id = b.file_id(+)
and ceil(blocks*&&blksize/1024/1024) - ceil((nvl(hwm,1)*&&blksize)/1024/1024) > 0;
quit;
EOF
# DBA_057B $1
}
#
#########################################################################################################
# VERIFY WHICH DATAFILE CAN BE RESIZED [ @ ]
#########################################################################################################
#
function DBA_057B() {
local OPT=$1
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
# ${OPT}
quit;
EOF
}
#
#########################################################################################################
# VERIFY RECYCLEBIN
#########################################################################################################
#
function DBA_058() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY RECYCLEBIN                                          #
prompt ##############################################################
col OBJECT_NAME for a25
col ORIGINAL_NAME for a25
col OPERATION for a10
select * from recyclebin;
quit;
EOF
}
#
#########################################################################################################
# CLEAR REYICLEBIN
#########################################################################################################
#
function DBA_059() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY RECYCLEBIN                                          #
Prompt # WAIT A MOMENT PLEASE, THE CLEARING IS RUNNING              #
prompt ##############################################################
purge recyclebin;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DATABASE SESSIONS
#########################################################################################################
#
function DBA_060() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY DATABASE SESSIONS
prompt ##############################################################
select total_sessions
  , active_sessions
  , (total_sessions - active_sessions) inactive_sessions
  , round( 100 * active_sessions / total_sessions, 2) pct_active
  , round( 100 * (total_sessions - active_sessions) / total_sessions, 2) pct_inactive
from (select count(*) total_sessions from v\$session where type <> 'BACKGROUND') st,
     (select count(*) active_sessions from v\$session where  status = 'ACTIVE' and type <> 'BACKGROUND') sa;
quit;
EOF
}
#
#########################################################################################################
# VERIFY ACTIVES SESSIONS PER OWNER
#########################################################################################################
#
function DBA_061() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY ACTIVES SESSIONS PER OWNER
prompt ##############################################################
select total_sessions
  , active_sessions
  , (total_sessions - active_sessions) inactive_sessions
  , round( 100 * active_sessions / total_sessions, 2) pct_active
  , round( 100 * (total_sessions - active_sessions) / total_sessions, 2) pct_inactive
from (select count(*) total_sessions from v\$session where type <> 'BACKGROUND') st,
     (select count(*) active_sessions from v\$session where  status = 'ACTIVE' and type <> 'BACKGROUND') sa;
quit;
EOF
}
#
#########################################################################################################
# UNLOCKING A USER [ @ ]
#########################################################################################################
#
function DBA_062() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # UNLOCKING A USER [ @ ]
prompt ##############################################################
col username for a30
col profile for a30
select user_id
  , username
  , account_status
  , default_tablespace
  , profile 
from dba_users
where account_status <> 'OPEN'
order by 2;
quit;
EOF
# DBA_062B $1
}
#
#########################################################################################################
# UNLOCKING A USER [ @ ]
#########################################################################################################
#
function DBA_062B() {
local OPT=$1
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
# alter user ${OPT} account unlock;
quit;
EOF
}
#
#########################################################################################################
# LOCKING A USER [ @ ]
#########################################################################################################
#
function DBA_063() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # LOCKING A USER [ @ ]
prompt ##############################################################
col username for a30
col profile for a30
select user_id
  , username
  , account_status
  , default_tablespace
  , profile 
from dba_users
where account_status = 'OPEN'
order by 2;
quit;
EOF
# DBA_063B $1
}
#
#########################################################################################################
# LOCKING A USER [ @ ]
#########################################################################################################
#
function DBA_063B() {
local OPT=$1
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
# alter user ${OPT} account lock;
quit;
EOF
}
#########################################################################################################
# REDO GROUPS INFORMATIONS
#########################################################################################################
#
function DBA_064() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col member FORMAT A90
col group# format 999
col status for a15
-- col thread# for a15
col TOTAL_MB format 999,999,999,999
col TOTAL_GB format 999,999,999,999
col TOTAL_MB for a20
col TOTAL_GB for a20
break on report
break on top_stat_name skip 1
compute sum of TOTAL_MB on report
compute sum of TOTAL_GB on report
cl break
prompt ##############################################################
prompt # OnLine RedoLogs                                            #
prompt ##############################################################
select t1.GROUP#
   , t2.thread#
   , t1.TYPE
   , t2.status
   , t1.MEMBER
   , t1.IS_RECOVERY_DEST_FILE
   , to_char(t2.bytes/1024/1024, '9G999G999D999') TOTAL_MB
   , to_char(t2.bytes/1024/1024/1024, '999D999') TOTAL_GB
from v\$logfile t1, v\$log t2
where t1.group# = t2.group#
order by 1,2,3,4;
prompt
prompt ##############################################################
prompt # Standby RedoLogs                                           #
prompt ##############################################################
select s1.group#
  , s2.THREAD#
  , s1.type
  , s2.status
  , s1.member
  , 'N/A' as "N/A"
  , to_char(s2.bytes/1024/1024, '9G999G999D999') TOTAL_MB
  , to_char(s2.bytes/1024/1024/1024, '999D999') TOTAL_GB
from v\$logfile s1, v\$standby_log s2
where s1.group# = s2.group#
and s1.type = 'STANDBY'
order by 1,2,3,4;
prompt
prompt ##############################################################
prompt # Archiving Details                                          #
prompt ##############################################################
select PROCESS
  , STATUS
  , THREAD#
  , SEQUENCE#
  , BLOCK#
  , BLOCKS
FROM V\$MANAGED_STANDBY;
prompt
prompt ##############################################################
prompt # Utilization of Current Redo Log ( in % )                   #
prompt ##############################################################
select le.leseq "Current log sequence No"
  , 100*cp.cpodr_bno/le.lesiz "Percent Full"
  , cp.cpodr_bno "Current Block No"
  , le.lesiz "Size of Log in Blocks" 
from x\$kcccp cp, x\$kccle le 
where le.leseq =CP.cpodr_seq 
and bitand(le.leflg,24) = 8 
/
quit;
EOF
}
#
#########################################################################################################
# SHOW ALL CORRUPTED OBJECTS
#########################################################################################################
#
function DBA_065() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # SHOW ALL CORRUPTED OBJECTS
prompt ##############################################################
select e.owner
  , e.segment_type
  , e.segment_name
  , e.partition_name
  , c.file#
  , greatest(e.block_id, c.block#) corr_start_block#
  , least(e.block_id+e.blocks-1
  , c.block#+c.blocks-1) corr_end_block#
  , least(e.block_id+e.blocks-1, c.block#+c.blocks-1)- greatest(e.block_id, c.block#) + 1 blocks_corrupted
  , null description
FROM dba_extents e, v\$database_block_corruption c
WHERE e.file_id = c.file#
AND e.block_id <= c.block# + c.blocks - 1
AND e.block_id + e.blocks - 1 >= c.block#
UNION
select s.owner
  , s.segment_type
  , s.segment_name
  , s.partition_name
  , c.file#
  , header_block corr_start_block#
  , header_block corr_end_block#
  , 1 blocks_corrupted
  , 'Segment Header' description
FROM dba_segments s, v\$database_block_corruption c
WHERE s.header_file = c.file#
AND s.header_block between c.block#
and c.block# + c.blocks - 1
UNION
select null owner
  , null segment_type
  , null segment_name
  , null partition_name
  , c.file#
  , greatest(f.block_id, c.block#) corr_start_block#
  , least(f.block_id+f.blocks-1, c.block#+c.blocks-1) corr_end_block#
  , least(f.block_id+f.blocks-1, c.block#+c.blocks-1) - greatest(f.block_id, c.block#) + 1 blocks_corrupted
  , 'Free Block' description
FROM dba_free_space f, v\$database_block_corruption c
WHERE f.file_id = c.file#
AND f.block_id <= c.block# + c.blocks - 1
AND block_id + f.blocks - 1 >= c.block#
order by file#, corr_start_block#;
quit;
EOF
}
#
#########################################################################################################
# VERIFY SPACE OF FLASH RECOVERY AREA
#########################################################################################################
#
function DBA_066() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY SPACE OF FLASH RECOVERY AREA
prompt ##############################################################
col name for a75
col size_m for 999,999,999
col used_m for 999,999,999
col "% USED" for a30
select name
   , ceil(space_limit/1024/1024) SIZE_M
   , ceil(space_used/1024/1024) USED_M
   , case when ceil((space_used/space_limit)*100) < 80 then ceil((space_used/space_limit)*100) || '% - Status OK' when ceil((space_used/space_limit)*100) < 90 then ceil((space_used/space_limit)*100) || '% - Warning' else ceil((space_used/space_limit)*100) || '% - Critical' end as "% USED"
-- , decode(nvl(space_used, 2), 0, 0) as "#"
FROM v\$recovery_file_dest
ORDER BY name;
prompt
prompt ##############################################################
prompt # VERIFY SPACE OF FLASH RECOVERY AREA - DETAILS
prompt ##############################################################
col "Status Space" for a20
select FILE_TYPE
   , PERCENT_SPACE_USED
   , PERCENT_SPACE_RECLAIMABLE
   , NUMBER_OF_FILES
-- , CON_ID
   , case when PERCENT_SPACE_USED < 80 then 'Space OK' when PERCENT_SPACE_USED < 90 then 'Warning' else 'Critical' end as "Status Space"
FROM V\$RECOVERY_AREA_USAGE;
quit;
EOF
}
#
#########################################################################################################
# 
#########################################################################################################
#
function DBA_067() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'



quit;
EOF
}
#
#########################################################################################################
# VERIFY CONTROLFILES
#########################################################################################################
#
function DBA_068() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY CONTROLFILES
prompt ##############################################################
col name for a120
select name
  , status
  , IS_RECOVERY_DEST_FILE
  , BLOCK_SIZE/1024 as BLOCK_SIZE_MB
from v\$controlfile;
quit;
EOF
}
#
#########################################################################################################
# VERIFY CONSUME PER CPU
#########################################################################################################
#
function DBA_069() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY CONSUME PER CPU
prompt ##############################################################
COLUMN wait_class format a20
COLUMN name       format a55
COLUMN time_sec   format 999,999,999,999.99
COLUMN time_min   format 999,999,999,999,999.99
COLUMN time_hou   format 999,999,999,999,999,999.99
COLUMN time_day   format 999,999,999,999,999,999,999.99
COLUMN pct        format 999,99
COLUMN "% Used"   format a8 JUSTIFY RIGHT
select wait_class
   , NAME
   , ROUND(time_secs, 2) time_sec
   , ROUND(time_secs/60, 2) time_min
   , ROUND(time_secs/60/60, 2) time_hou
   , ROUND(time_secs/60/60/24, 2) time_day
   , ' ' || ROUND(time_secs * 100 / SUM (time_secs) OVER (), 2) || '%' as "% Used"
FROM (select n.wait_class, e.event NAME, e.time_waited / 100 time_secs FROM v\$system_event e, v\$event_name n WHERE n.NAME = e.event AND n.wait_class <> 'Idle' AND time_waited > 0
      UNION
      select 'CPU', 'server CPU', SUM (VALUE / 1000000) time_secs FROM v\$sys_time_model WHERE stat_name IN ('background cpu time', 'DB CPU'))
-- where ROUND(time_secs*100/SUM(time_secs) OVER (), 2) > 0
-- where "% Used" > 0
ORDER BY time_sec DESC;
quit;
EOF
}
#
#########################################################################################################
# QUICK TUNE
#########################################################################################################
#
function DBA_070() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # QUICK TUNE
prompt ##############################################################
COL "MEMORY TYPE" FOR A16
--HEAD "SGA + RATIOS"
--COL "Total_Mem(Ko)" FOR A12
--COL "Free(Ko)" FOR A8
COL "###" FOR A3
COL "MEMORY RATIOS" FOR A28
COL "RATIO %" FOR A7
COL IDEAL FOR A8 ;
compute sum of "Total_Mem K" on report
compute sum of "Free K" on report
break on report ;
select pool as "MEMORY TYPE"
  , Total_Mem as "ALLOCATION K"
  , Free_Mem as "FREE K"
  , '###' "###"
  , RUBRIQUE "MEMORY RATIOS"
  , to_char(round(RATIO*100,1),'999.9') "RATIO %"
  , IDEAL
from (select rownum0, A.pool, A.Total_Mem, B.Free_Mem from (select (rownum) rownum0, A.* from (select pool, round(sum(bytes)/1024,0) Total_Mem from v\$sgastat where pool is not null group by pool
UNION
select name, round(bytes/1024) from v\$sgastat where pool is null and name !='fixed_sga') A
UNION ALL
select 6,'Sort Area Size' ,round(value/1024,0) from v\$parameter where name in ('sort_area_size')
UNION ALL
select 7,'Hash Area Size' ,round(value/1024,0) from v\$parameter where name in ('hash_area_size')) A, (select pool, round(bytes/1024,0) Free_Mem from v\$sgastat where name = 'free memory'
UNION ALL
select 'DBA_block_buffers', (select count(*) from v\$bh where status='free')*(select (round(value/1024,0)) from v\$parameter where name = 'DBA_block_size') from dual ) B where A.pool=B.pool(+)) SGA, (select 6 rownum0, 'DATA DICTIONARY CACHE' "RUBRIQUE", sum(getmisses)/sum(gets) "RATIO", ' < 15 %' "IDEAL" from v\$rowcache
UNION ALL
select 3,'SHARED POOL HIT RATIO',sum(pinhits-reloads)/sum(pins),' > 85 %' from v\$librarycache
UNION ALL
select 4 ,'SHARED POOL RELOAD %',sum (reloads)/sum(pins), ' <  2 %' from v\$librarycache
UNION ALL
select 2,'BUFFER CACHE Hit Ratio', (1-(sum(decode(name, 'physical reads', value, 0))/(sum(decode(name, 'db block gets',value,0)) + (sum(decode(name,'consistent gets', value, 0)))))), ' > 95 %' from v\$sysstat
UNION ALL
select 1,'BUFFER CACHE MISS RATIO', ((G-F)/(G-F+C+E)),' < 15 %' from (select sum(value) C  from v\$sysstat where name like '%- consistent read gets') c, (select value E from v\$sysstat where name = 'db block gets') e, (select value F from v\$sysstat where name = 'physical reads direct') f, (select value G from v\$sysstat where name = 'physical reads') g
UNION ALL
select 5, 'LOG BUFFER REQUESTS Ratio', -- '#Redo Space requests/#redo entries'
((req.value * 50)/entries.value), ' < 0.02%' from v\$sysstat req, v\$sysstat entries where req.name='redo log space requests' and entries.name = 'redo entries'
UNION ALL
select 7,'MEM SORTS/TOTAL SORTS', mem.value/(mem.value+disk.value),' > 95 %' from v\$sysstat mem, v\$sysstat disk where mem.name = 'sorts (memory)' and disk.name = 'sorts (disk)') RATIOS where SGA.rownum0(+) = RATIOS.ROWNUM0 order by SGA.rownum0 asc;
quit;
EOF
}
#
#########################################################################################################
# VERIFY RECOMENDATIONS TUNING TOP 20 [ @ ]
#########################################################################################################
#
function DBA_071() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
DEF days_of_history_accessed = '31';
DEF captured_at_least_x_times = '10';
DEF captured_at_least_x_days_apart = '5';
DEF med_elap_microsecs_threshold = '1e4';
DEF min_slope_threshold = '0.1';
DEF max_num_rows = '20';
SET lin 200 ver OFF;
COL SLOPE for a15
COL row_n FOR A2 HEA '#';
COL med_secs_per_exec HEA 'Median Secs|Per Exec' for a20;
COL std_secs_per_exec HEA 'Std Dev Secs|Per Exec';
COL avg_secs_per_exec HEA 'Avg Secs|Per Exec';
COL min_secs_per_exec HEA 'Min Secs|Per Exec';
COL max_secs_per_exec HEA 'Max Secs|Per Exec';
COL plans FOR 9999;
COL sql_text_80 FOR A75;
prompt
prompt ##############################################################
prompt # SQL Statements with "Elapsed Time per Execution" changing over time
prompt ##############################################################
WITH
per_time AS (
select h.dbid
   , h.sql_id
   , SYSDATE - CAST(s.end_interval_time AS DATE) days_ago
   , SUM(h.elapsed_time_total) / SUM(h.executions_total) time_per_exec
FROM  dba_hist_sqlstat h, dba_hist_snapshot s
WHERE h.executions_total > 0
AND s.snap_id = h.snap_id
AND s.dbid = h.dbid
AND s.instance_number = h.instance_number
AND CAST(s.end_interval_time AS DATE) > SYSDATE - &&days_of_history_accessed
GROUP BY h.dbid, h.sql_id, SYSDATE - CAST(s.end_interval_time AS DATE)),
avg_time AS (
select dbid
   , sql_id
   , MEDIAN(time_per_exec) med_time_per_exec
   , STDDEV(time_per_exec) std_time_per_exec
   , AVG(time_per_exec)    avg_time_per_exec
   , MIN(time_per_exec)    min_time_per_exec
   , MAX(time_per_exec)    max_time_per_exec
FROM per_time
GROUP BY dbid, sql_id
HAVING COUNT(*) >= &&captured_at_least_x_times
AND MAX(days_ago) - MIN(days_ago) >= &&captured_at_least_x_days_apart
AND MEDIAN(time_per_exec) > &&med_elap_microsecs_threshold),
time_over_median AS (
select h.dbid
   ,  h.sql_id
   ,  h.days_ago
   ,  (h.time_per_exec / a.med_time_per_exec) time_per_exec_over_med
   ,  a.med_time_per_exec
   ,  a.std_time_per_exec
   ,  a.avg_time_per_exec
   ,  a.min_time_per_exec
   ,  a.max_time_per_exec
FROM per_time h, avg_time a WHERE a.sql_id = h.sql_id),
ranked AS (
select RANK () OVER (ORDER BY ABS(REGR_SLOPE(t.time_per_exec_over_med, t.days_ago)) DESC) rank_num
   ,  t.dbid
   ,  t.sql_id
   ,  CASE WHEN REGR_SLOPE(t.time_per_exec_over_med, t.days_ago) > 0 THEN 'IMPROVING' ELSE 'REGRESSING' END change
   ,  ROUND(REGR_SLOPE(t.time_per_exec_over_med, t.days_ago), 3) slope
   ,  ROUND(AVG(t.med_time_per_exec)/1e6, 3) med_secs_per_exec
   ,  ROUND(AVG(t.std_time_per_exec)/1e6, 3) std_secs_per_exec
   ,  ROUND(AVG(t.avg_time_per_exec)/1e6, 3) avg_secs_per_exec
   ,  ROUND(MIN(t.min_time_per_exec)/1e6, 3) min_secs_per_exec
   ,  ROUND(MAX(t.max_time_per_exec)/1e6, 3) max_secs_per_exec
FROM time_over_median t
GROUP BY t.dbid, t.sql_id
HAVING ABS(REGR_SLOPE(t.time_per_exec_over_med, t.days_ago)) > &&min_slope_threshold)
select LPAD(ROWNUM, 2) row_n
   ,  r.sql_id
   ,  r.change
   ,  TO_CHAR(r.slope, '990.000MI') slope
   ,  TO_CHAR(r.med_secs_per_exec, '999,990.000') med_secs_per_exec
   ,  TO_CHAR(r.std_secs_per_exec, '999,990.000') std_secs_per_exec
   ,  TO_CHAR(r.avg_secs_per_exec, '999,990.000') avg_secs_per_exec
   ,  TO_CHAR(r.min_secs_per_exec, '999,990.000') min_secs_per_exec
   ,  TO_CHAR(r.max_secs_per_exec, '999,990.000') max_secs_per_exec
   ,  (select COUNT(DISTINCT p.plan_hash_value) FROM dba_hist_sql_plan p WHERE p.dbid = r.dbid AND p.sql_id = r.sql_id) plans
--  ,  REPLACE((select DBMS_LOB.SUBSTR(s.sql_text, 80) FROM dba_hist_sqltext s WHERE s.dbid = r.dbid AND s.sql_id = r.sql_id), CHR(10)) sql_text_80
FROM ranked r
WHERE r.rank_num <= &&max_num_rows
ORDER BY r.rank_num
/
quit;
EOF
}
#
#########################################################################################################
# VERIFY TOP 20 TUNING HISTORY [ @ ]
#########################################################################################################
#
function DBA_072() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on colsep '|' feedback off trimspool on echo off heading on wrap off
prompt ##############################################################
prompt # VERIFY TOP 20 TUNING HISTORY [ @ ]
prompt ##############################################################
select * from (select SQL_ID ,
sum(decode(session_state,'ON CPU',1,0)) as CPU,
sum(decode(session_state,'WAITING',1,0)) - sum(decode(session_state, 'WAITING', decode(wait_class, 'User I/O',1,0),0)) as WAIT,
sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as IO,
sum(decode(session_state,'ON CPU',1,1)) as TOTAL
from v\$active_session_history
where SQL_ID is not NULL
group by sql_id
order by sum(decode(session_state,'ON CPU',1,1)) desc)
where rownum < 21;
quit;
EOF
}
#
#########################################################################################################
# VERIFY BACKGROUND PROCESSESS
#########################################################################################################
#
function DBA_073() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY BACKGROUND PROCESSESS
prompt ##############################################################
select min(name || ': '|| description) process_description FROM v\$bgprocess group by substr(name,1,3) ORDER BY 1;
quit;
EOF
}
#
#########################################################################################################
# TOP 100 QUERY RECOMMENDATIONS
#########################################################################################################
#
function DBA_074() {
read
${ORACLE_HOME}/perl/bin/perl <<EOF
#!/usr/bin/perl
# -------------------------------------------------------------------------------------
# Performance Script
# -------------------------------------------------------------------------------------
local Hostname=${1};
local Database=${2};
local Port=${3};
local Username=${3};
local Password=${4};
local Schema=${5};
local AutoImplement=${6};
local Top=${7};
# -------------------------------------------------------------------------------------
# perl AutoDBMS_SQLTUNE.pl HOSTNAME SERVICE PORT USERNAME PASSWORD SCHEMA AUTOIMPLEMENT TOPSQL
# perl AutoDBMS_SQLTUNE.pl nerv01 prod 1521 PORTILHO Nerv2008 SOE N 10
# -------------------------------------------------------------------------------------
use strict;
use warnings;
use DBD::Oracle qw(:ora_session_modes);
# -------------------------------------------------------------------------------------
# Versão 2.00.
# -------------------------------------------------------------------------------------
# Oracle Variable Connections
# -------------------------------------------------------------------------------------
my $Hostname = $ARGV[0];
my $Database = $ARGV[1];
my $Port = $ARGV[2];
my $Username = $ARGV[3];
my $Password = $ARGV[4];
my $Schema = $ARGV[5];
my $AutoImplement = $ARGV[6];
my $Top = $ARGV[7];
# -------------------------------------------------------------------------------------
# Which is the creterie of SQLs to be analyze and in which order?
# -------------------------------------------------------------------------------------
my @Order = ('ELAPSED_TIME', 'CPU_TIME', 'DISK_READS', 'BUFFER_GETS', 'DIRECT_WRITES', 'SORTS');
# -------------------------------------------------------------------------------------
my $oracle_dbh = DBI->connect("dbi:Oracle:host=$Hostname;service_name=$Database;port=$Port", $Username, $Password, {RaiseError => 1, AutoCommit => 0, ora_session_mode => ORA_SYSDBA});
$oracle_dbh->{LongReadLen} = 20*1024*1024; # 20MB
# -------------------------------------------------------------------------------------
open(LOG, '>AutoDBMS_SQLTUNE.log') || die ("Could not open file!");
# -------------------------------------------------------------------------------------
# Remove the Tuning Task Pack if it exists already.
# -------------------------------------------------------------------------------------
my $task_exist = 0;
my $oracle_sql_01 = "select TASK_ID FROM DBA_ADVISOR_TASKS WHERE OWNER = 'SYS' AND TASK_NAME = 'Auto DBMS_SQLTUNE Tuning Task'";
my $oracle_sth_01 = $oracle_dbh->prepare($oracle_sql_01);
$oracle_sth_01->execute();
while (my $oracle_ref_01 = $oracle_sth_01->fetchrow_hashref())
{
  $task_exist++;
}
$oracle_sth_01->finish();
if ($task_exist > 0)
{
  my $oracle_sql_02 = "BEGIN DBMS_SQLTUNE.DROP_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task'); END;";
  my $oracle_sth_02 = $oracle_dbh->prepare($oracle_sql_02);
  $oracle_sth_02->execute();
  $oracle_sth_02->finish();
}

foreach (@Order)
{
  my $Order = $_;
  print "\nAnalisando os TOP $Top SQLs ordenados por $Order...\n\n";
  print LOG "\nAnalisando os $Top 100 SQLs ordenados por $Order...\n\n";
# -------------------------------------------------------------------------------------
# Search for the Top SQLs.
# -------------------------------------------------------------------------------------
my $oracle_sql_03 = "select SQL_ID, SQL_TEXT FROM (select SQL_ID, SQL_TEXT FROM GV\$SQL WHERE PARSING_SCHEMA_NAME = '$Schema' ORDER BY $Order) WHERE ROWNUM < $Top";
my $oracle_sth_03 = $oracle_dbh->prepare($oracle_sql_03);
$oracle_sth_03->execute();
while (my $oracle_ref_03 = $oracle_sth_03->fetchrow_hashref())
{
  my $sql_id = $oracle_ref_03->{SQL_ID};
  my $sql_text = $oracle_ref_03->{SQL_TEXT};
# -------------------------------------------------------------------------------------
# Verify if the SQL stil exists.
# -------------------------------------------------------------------------------------
  my $sql_exist = 0;
  my $oracle_sql_04 = "select SQL_TEXT FROM V\$SQL WHERE SQL_ID= '$sql_id'";
  my $oracle_sth_04 = $oracle_dbh->prepare($oracle_sql_04);
  $oracle_sth_04->execute();
  while (my $oracle_ref_04 = $oracle_sth_04->fetchrow_hashref())
  {
    $sql_exist++;
  }
  $oracle_sth_04->finish();
# -------------------------------------------------------------------------------------
# Execute the Tuning Task
# -------------------------------------------------------------------------------------
  if ($sql_exist > 0)
  {
  my $oracle_sql_05 = "DECLARE RET_VAL VARCHAR2(4000); BEGIN RET_VAL := DBMS_SQLTUNE.CREATE_TUNING_TASK(SQL_ID => '$sql_id', SCOPE => DBMS_SQLTUNE.SCOPE_COMPREHENSIVE, TIME_LIMIT => 600, TASK_NAME => 'Auto DBMS_SQLTUNE Tuning Task', DESCRIPTION => 'Auto DBMS_SQLTUNE Tuning Task'); END;";
  my $oracle_sth_05 = $oracle_dbh->prepare($oracle_sql_05);
  $oracle_sth_05->execute();
  $oracle_sth_05->finish();

  my $oracle_sql_06 = "BEGIN DBMS_SQLTUNE.EXECUTE_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task'); END;";
  my $oracle_sth_06 = $oracle_dbh->prepare($oracle_sql_06);
  $oracle_sth_06->execute();
  $oracle_sth_06->finish();
# -------------------------------------------------------------------------------------
# Show the Recomendations.
# -------------------------------------------------------------------------------------
  my $oracle_sql_07 = "select DBMS_SQLTUNE.REPORT_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task') RECOMMENTATION FROM DUAL";
  my $oracle_sth_07 = $oracle_dbh->prepare($oracle_sql_07);
  $oracle_sth_07->execute();
  while (my $oracle_ref_07 = $oracle_sth_07->fetchrow_hashref())
  {
    my $recommendation = $oracle_ref_07->{RECOMMENTATION};
    print "$recommendation\n\n";
    print LOG "$recommendation\n\n";
  }
# -------------------------------------------------------------------------------------
# Execute the Recomendations.
# -------------------------------------------------------------------------------------
  my $oracle_sql_08 = "select DBMS_SQLTUNE.SCRIPT_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task') RECOMMENTATION FROM DUAL";
  my $oracle_sth_08 = $oracle_dbh->prepare($oracle_sql_08);
  $oracle_sth_08->execute();
  while (my $oracle_ref_08 = $oracle_sth_08->fetchrow_hashref())
  {
    my $recommendation = $oracle_ref_08->{RECOMMENTATION};
    if ($recommendation !~ m/There are no recommended actions for this task under the given filters./)
    {
      my @CompleteRecommendation =  split /\n/, $recommendation;
      foreach (@CompleteRecommendation)
      {
        my $RecommendationLine = $_;
        unless ($RecommendationLine =~ /;/gm) {next;}

        if ($RecommendationLine =~ /^create index /) {$RecommendationLine =~ s/;//;}
        if ($RecommendationLine =~ /^execute /) {$RecommendationLine =~ s/execute //; $RecommendationLine = "BEGIN $RecommendationLine END;";}
        my $oracle_sql_09 = "$RecommendationLine";
        my $oracle_sth_09 = $oracle_dbh->prepare($oracle_sql_09);
        print "Recommendation to implement: $RecommendationLine\n\n";
        print LOG "Recommendation to implement:: $RecommendationLine\n\n";

        my $YesOrNo;
        print "Do you wish to implement it? (Y/N)";
        if ($AutoImplement eq 'Y')
        {
          $YesOrNo = 'Y';
        }
        else
        {
          $YesOrNo = <STDIN>;
          chomp $YesOrNo;
        }
							
        if ($YesOrNo eq 'Y')
        {
          $oracle_sth_09->execute();
          $oracle_sth_09->finish();
          print "Recommendation IMPLEMENTED.\n\n";
          print LOG "Recommendation IMPLEMENTED.\n\n";
          last;
        }
        elsif ($YesOrNo eq 'N')
        {
          print "Recommendation NOT IMPLEMENTED.\n\n";
          print LOG "Recommendation NOT IMPLEMENTED.\n\n";
          last;
        }
        else
        {
          print "\nWell, I don´t know what to do...\n";
          print LOG "\nWell, I don´t know what to do...\n";
        }
        }
    }
      print "\n\n\n\n\n";
    }
    $oracle_sth_08->finish();

    my $oracle_sql_10 = "BEGIN DBMS_SQLTUNE.DROP_TUNING_TASK('Auto DBMS_SQLTUNE Tuning Task'); END;";
    my $oracle_sth_10 = $oracle_dbh->prepare($oracle_sql_10);
    $oracle_sth_10->execute();
    $oracle_sth_10->finish();
    }
  }
  $oracle_sth_03->finish();
}
$oracle_dbh->disconnect;
exit;
EOF
}
#
#########################################################################################################
# VERIFY DYNAMICS PARAMETERS [ SPFILE ]
#########################################################################################################
#
function DBA_075() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY DYNAMICS PARAMETERS [ SPFILE ]
prompt ##############################################################
col sid for a10
col name for a45
col type for a15
col display_value for a100
select sid
  , name
  , type
  , display_value
from v\$spparameter
order by name;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DBA FEATURES USAGE STATISTICS
#########################################################################################################
#
function DBA_076() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY DBA FEATURES USAGE STATISTICS
prompt ##############################################################
col "NAME" for a70
col "DETECTED USAGES" for a20
col "USING NOW Y/N" for a15
select name
  , case when DETECTED_USAGES = 0 then 'Never Used' else to_char(DETECTED_USAGES) || ' Time(s) Used' end as "DETECTED USAGES"
  , case when CURRENTLY_USED = 'FALSE' then 'Not Using' when CURRENTLY_USED = 'TRUE' then 'Using' else 'UNKNOWN' end as "USING NOW Y/N"
  , FIRST_USAGE_DATE
  , LAST_USAGE_DATE
from dba_feature_usage_statistics a, v\$instance b
where a.version = b.version
order by 1;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DBA HIGH WATER MARK STATISTICS
#########################################################################################################
#
function DBA_077() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY DBA HIGH WATER MARK STATISTICS
prompt ##############################################################
col NAME for a30
col VERSION for a15
col HIGHWATER for a20
col LAST_VALUE for a20
col DESCRIPTION for a70
select distinct a.NAME
  , a.VERSION
  , to_char(HIGHWATER) as HIGHWATER
  , to_char(LAST_VALUE) as LAST_VALUE
  , DESCRIPTION
from DBA_HIGH_WATER_MARK_STATISTICS a, v\$instance b
where a.version = b.version
order by 1,2;
quit;
EOF
}
#
#########################################################################################################
# GLOBAL INFORMATION ABOUT I/O
#########################################################################################################
#
function DBA_078() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
set feedback off trimspool on echo off wrap off;
prompt ##############################################################
prompt # REPORT SQL MONITOR                                         #
prompt ##############################################################
select dbms_sqltune.report_sql_monitor from dual;
prompt
prompt ##############################################################
prompt # GLOBAL INFORMATION ABOUT I/O                               #
prompt ##############################################################
set pages 700 lines 700 timing on long 10000000 longchunksize 10000000 colsep '|' numwidth 20 heading on echo on verify on feedback on colsep '|' lin 200 ver off;
COL instance_number FOR 9999 HEA 'Inst';
COL end_time HEA 'End Time';
COL plan_hash_value HEA 'Plan|Hash Value';
COL executions_total FOR 999,999 HEA 'Execs|Total';
COL rows_per_exec HEA 'Rows Per Exec';
COL et_secs_per_exec HEA 'Elap Secs|Per Exec';
COL cpu_secs_per_exec HEA 'CPU Secs|Per Exec';
COL io_secs_per_exec HEA 'IO Secs|Per Exec';
COL cl_secs_per_exec HEA 'Clus Secs|Per Exec';
COL ap_secs_per_exec HEA 'App Secs|Per Exec';
COL cc_secs_per_exec HEA 'Conc Secs|Per Exec';
COL pl_secs_per_exec HEA 'PLSQL Secs|Per Exec';
COL ja_secs_per_exec HEA 'Java Secs|Per Exec';
select h.instance_number
   , TO_CHAR(CAST(s.end_interval_time AS DATE), 'DD/MM/YYYY HH24:MI:SS') end_time
   , h.plan_hash_value
   , h.executions_total
   , TO_CHAR(ROUND(h.rows_processed_total / h.executions_total), '999,999,999,999') rows_per_exec
   , TO_CHAR(ROUND(h.elapsed_time_total / h.executions_total / 1e6, 3), '999,990.000') et_secs_per_exec
   , TO_CHAR(ROUND(h.cpu_time_total / h.executions_total / 1e6, 3), '999,990.000') cpu_secs_per_exec
   , TO_CHAR(ROUND(h.iowait_total / h.executions_total / 1e6, 3), '999,990.000') io_secs_per_exec
   , TO_CHAR(ROUND(h.clwait_total / h.executions_total / 1e6, 3), '999,990.000') cl_secs_per_exec
   , TO_CHAR(ROUND(h.apwait_total / h.executions_total / 1e6, 3), '999,990.000') ap_secs_per_exec
   , TO_CHAR(ROUND(h.ccwait_total / h.executions_total / 1e6, 3), '999,990.000') cc_secs_per_exec
   , TO_CHAR(ROUND(h.plsexec_time_total / h.executions_total / 1e6, 3), '999,990.000') pl_secs_per_exec
   , TO_CHAR(ROUND(h.javexec_time_total / h.executions_total / 1e6, 3), '999,990.000') ja_secs_per_exec
FROM dba_hist_sqlstat h, dba_hist_snapshot s
WHERE h.sql_id = '${SQL_ID}'
AND h.executions_total > 0
AND s.snap_id = h.snap_id
AND s.dbid = h.dbid
AND s.instance_number = h.instance_number
ORDER BY h.sql_id, h.instance_number, s.end_interval_time, h.plan_hash_value;
quit;
EOF
}
#
#########################################################################################################
# WHICH SEG. HAVE TOP LOGICAL I/O - PHYSICAL I/O
#########################################################################################################
#
function DBA_079() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # WHICH SEG. HAVE TOP LOGICAL I/O - PHYSICAL I/O
prompt ##############################################################
col owner for a30
col OBJECT_NAME for a40
select ROWNUM AS Rank
  , Seg_Lio.*
FROM (select St.Owner
  , St.Obj#
  , St.Object_Type
  , St.Object_Name
  , to_char(St.VALUE) as VALUE
  , 'LIO' AS Unit
FROM V\$segment_Statistics St
WHERE St.Statistic_Name = 'logical reads'
ORDER BY St.VALUE DESC) Seg_Lio WHERE ROWNUM <= 15
UNION ALL
select ROWNUM AS Rank
  , Seq_Pio_r.*
FROM (select St.Owner
  , St.Obj#
  , St.Object_Type
  , St.Object_Name
  , to_char(St.VALUE) as VALUE
  , 'PIO Reads' AS Unit
FROM V\$segment_Statistics St
WHERE St.Statistic_Name = 'physical reads'
ORDER BY St.VALUE DESC) Seq_Pio_r
WHERE ROWNUM <= 15
UNION ALL
select ROWNUM AS Rank
  , Seq_Pio_w.*
FROM (select St.Owner
  , St.Obj#
  , St.Object_Type
  , St.Object_Name
  , to_char(St.VALUE) as VALUE
  , 'PIO Writes' AS Unit
FROM V\$segment_Statistics St
WHERE St.Statistic_Name = 'physical writes'
ORDER BY St.VALUE DESC) Seq_Pio_w
WHERE ROWNUM <= 15;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DBLINKS & FOLDERS INFO
#########################################################################################################
#
function DBA_080() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # DATABASE LINKS                                             #
prompt ##############################################################
set long 1000 serveroutput on verify off lines 132
DECLARE
   v_output CLOB := NULL;
BEGIN
   DBMS_OUTPUT.put_line ('DDL For Database Links');
   FOR tt IN (select owner, DBA_link FROM dba_DB_links)
   LOOP
      select DBMS_METADATA.get_ddl ('DBA_LINK', tt.DBA_link, tt.owner) INTO v_output FROM DUAL;
      DBMS_OUTPUT.put_line (v_output);
   END LOOP;
END;
/
prompt
select * from dba_db_links order by 1,2,3;
prompt
prompt ##############################################################
prompt # Verify Wich DB LINK are Opened                             #
prompt ##############################################################
COL DBA_LINK FORMAT A25 
COL OWNER_ID FORMAT 99999 HEADING "OWNID" 
COL LOGGED_ON FORMAT A5 HEADING "LOGON" 
COL HETEROGENEOUS FORMAT A5 HEADING "HETER" 
COL PROTOCOL FORMAT A8 
COL OPEN_CURSORS FORMAT 999 HEADING "OPN_CUR" 
COL IN_TRANSACTION FORMAT A3 HEADING "TXN" 
COL UPDATE_SENT FORMAT A6 HEADING "UPDATE" 
COL COMMIT_POINT_STRENGTH FORMAT 99999 HEADING "C_P_S" 
select * FROM V\$DBLINK;
prompt
prompt ##############################################################
prompt # FOLDERS                                                    #
prompt ##############################################################
col folders for a200
select 'create or replace directory ' || directory_name || ' as ' || '''' || directory_path || ''';' as folders from all_directories;
quit;
EOF
}
#
#########################################################################################################
# IDENTIFYING WHEN A PASSWORD WAS LAST CHANGED
#########################################################################################################
#
function DBA_081() {

sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # IDENTIFYING WHEN A PASSWORD WAS LAST CHANGED
prompt ##############################################################
col name form a30
col "Created" for a20
col "Last_Changed" for a20
select name
  , ctime as "Created"
  , ptime as "Last_Changed"
  , case when ptime = ctime then 'Never Changed' when ptime < sysdate - 30 and ctime < sysdate - 30 then 'Change Recomended' else 'Recently Changed' end as "Result"
FROM sys.user\$ a, dba_users b
where a.name = b.username
order by 1;
quit;
EOF
}
#
#########################################################################################################
# VERIFY UNDO SEGMENTS
#########################################################################################################
#
function DBA_082() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY UNDO SEGMENTS
prompt ##############################################################
select to_char(begin_time, 'DD/MM/YYYY HH24:MI') begin_time
  , to_char(end_time, 'DD/MM/YYYY HH24:MI') end_time
  , tuned_undoretention
from v\$undostat
order by end_time;
prompt
prompt ##############################################################
prompt # VERIFY UNDO SEGMENTS - DETAILS
prompt ##############################################################
select TO_CHAR(BEGIN_TIME, 'DD/MM/YYYY HH24:MI') BEGIN_TIME
  , TO_CHAR(END_TIME, 'DD/MM/YYYY HH24:MI') END_TIME
  , UNDOTSN
  , UNDOBLKS
  , TXNCOUNT
  , MAXCONCURRENCY AS "MAXCON"
FROM v\$UNDOSTAT
WHERE rownum <= 144;
prompt
prompt ##############################################################
prompt # VERIFY UNDO SEGMENTS - STATUS
prompt ##############################################################
select segment_name
  , status
FROM dba_rollback_segs;
prompt
prompt ##############################################################
prompt # VERIFY UNDO SEGMENTS - ROLLBACK
prompt ##############################################################
select rn.Name "Rollback Segment"
  , rs.RSSize/1024 "Size (KB)"
  , rs.Gets "Gets"
  , rs.waits "Waits"
  , (rs.Waits/rs.Gets)*100 "% Waits"
  , rs.Shrinks "# Shrinks"
  , rs.Extends "# Extends"
FROM sys.v_\$rollName rn, sys.v_\$rollStat rs
WHERE rn.usn = rs.usn
order by "Size (KB)", "Waits", "% Waits";
quit;
EOF
}
#
#########################################################################################################
# VERIFY ALL SQL STATEMENTS
#########################################################################################################
#
function DBA_083() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 5000 lines 80 timing on long 9999999 numwidth 20 heading on echo off verify off feedback on colsep '|' head off
prompt ##############################################################
prompt # VERIFY ALL SQL STATEMENTS
prompt ##############################################################
select /*+ CHOOSE*/
'Session Id...........................: ' || s.sid,
'Serial Num...........................: ' || s.serial#,
'User Name............................: ' || s.username,
'SQL ID...............................: ' || s.sql_id,
'Session Status.......................: ' || s.status,
'Client Process Id on Client Machine..: ' || '*' || s.process || '*' Client,
'Server Process ID....................: ' || p.spid Server,
'Sql_Address..........................: ' || s.sql_address,
'Sql_hash_value.......................: ' || s.sql_hash_value,
'Schema Name..........................: ' || s.SCHEMANAME,
'Program..............................: ' || s.program,
'Module...............................: ' || s.module,
'Action...............................: ' || s.action,
'Terminal.............................: ' || s.terminal,
'Client Machine.......................: ' || s.machine,
'LAST_CALL_ET.........................: ' || s.last_call_et,
'S.LAST_CALL_ET/3600..................: ' || s.last_call_et/3600
from v\$session s, v\$process p
where p.addr = s.paddr;
-- and s.sid = nvl('${ORACLE_SID}', s.sid);
quit;
EOF
}
#
#########################################################################################################
# CLONE USER COMMANDS [ @ ]
#########################################################################################################
#
function DBA_084() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # CLONE USER COMMANDS [ @ ]
prompt ##############################################################
col username for a30
col profile for a20
select username
  , account_status
  , default_tablespace
  , temporary_tablespace
  , profile
from dba_users
where username not in ('SYS','SYSTEM','XDB','XS$NULL','ANONYMOUS')
order by 1,2;
quit;
EOF
}
#
#########################################################################################################
# VERIFY ALL INFOS ABOUT SYSAUX
#########################################################################################################
#
function DBA_085() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # AWR Retention Time                                         #
prompt ##############################################################
select a.dbid
  , c.name
  , b.instance_name
  , a.retention
from DBA_HIST_WR_CONTROL a, v\$instance b, v\$database c
where a.dbid = c.dbid (+);
prompt
prompt ##############################################################
prompt # Statistics Retention History                               #
prompt ##############################################################
select dbms_stats.get_stats_history_retention from dual;
prompt
prompt ##############################################################
prompt # Statistics Availability History                            #
prompt ##############################################################
select dbms_stats.get_stats_history_availability from dual;
prompt
prompt ##############################################################
prompt # Duration Time of SnapShots                                 #
prompt ##############################################################
col "Start Time" for a25
col "End Time" for a25
select min(snap_id) as "First Snap ID"
  , max(snap_id) as "Last Snap ID"
  , min(to_char(begin_interval_time,'DD/MM/YYYY HH24:MI:SS')) as "Start Time"
  , max(to_char(end_interval_time,'DD/MM/YYYY HH24:MI:SS')) as "End Time"
from dba_hist_snapshot;
prompt
prompt ##############################################################
prompt # Infos About SYSAUX TBS                                     #
prompt ##############################################################
COLUMN "Item" FORMAT A25
COLUMN "Space Used (GB)" FORMAT 999.999
COLUMN "Schema" FORMAT A25
COLUMN "Move Procedure" FORMAT A50
select occupant_name "Item"
  , space_usage_kbytes/1048576 "Space Used (GB)"
  , schema_name "Schema"
  , move_procedure "Move Procedure"
FROM gv_\$sysaux_occupants
ORDER BY 1;
prompt
prompt ##############################################################
prompt # Controlling the Size and Age of the OS Audit Trail         #
prompt ##############################################################
COLUMN parameter_name FORMAT A30
COLUMN parameter_value FORMAT A20
COLUMN audit_trail FORMAT A20
select * FROM dba_audit_mgmt_config_params
WHERE parameter_name LIKE 'AUDIT FILE MAX%';
quit;
EOF
}
#
#########################################################################################################
# VERIFY ALL INFOS ABOUT I/O + LATENCY
#########################################################################################################
#
function DBA_086() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|' trim on trims on numformat 999999999999999
prompt ##############################################################
prompt # VERIFY ALL INFOS ABOUT I/O & LATENCY
prompt ##############################################################
col name for a70
select to_char(sn.END_INTERVAL_TIME,'dd/mm/YYYY HH24:MI:SS') "End snapshot time"
  , sum(after.PHYRDS+after.PHYWRTS-before.PHYWRTS-before.PHYRDS) "number of IOs"
  , trunc(10*sum(after.READTIM+after.WRITETIM-before.WRITETIM-before.READTIM)/sum(1+after.PHYRDS+after.PHYWRTS-before.PHYWRTS-before.PHYRDS)) "ave IO time (ms)"
  , trunc((select value from v\$parameter where name='DBA_block_size')*sum(after.PHYBLKRD+after.PHYBLKWRT-before.PHYBLKRD-before.PHYBLKWRT)/sum(1+after.PHYRDS+after.PHYWRTS-before.PHYWRTS-before.PHYRDS)) "ave IO size (bytes)"
from DBA_HIST_FILESTATXS before
  , DBA_HIST_FILESTATXS after
  , DBA_HIST_SNAPSHOT sn
where after.file# = before.file#
and after.snap_id = before.snap_id+1
and before.instance_number = after.instance_number
and after.snap_id = sn.snap_id
and after.instance_number = sn.instance_number
group by to_char(sn.END_INTERVAL_TIME,'dd/mm/YYYY HH24:MI:SS')
order by to_char(sn.END_INTERVAL_TIME,'dd/mm/YYYY HH24:MI:SS');
prompt
prompt ##############################################################
prompt # Physical Reads and Writes                                  #
prompt ##############################################################
col name for a100
select NAME
  , PHYRDS "Physical Reads"
  , round((PHYRDS / PD.PHYS_READS)*100,2) "Read %"
  , PHYWRTS "Physical Writes"
  , round(PHYWRTS * 100 / PD.PHYS_WRTS,2) "Write %"
  , fs.PHYBLKRD+FS.PHYBLKWRT "Total Block I/O's"
from (select sum(PHYRDS) PHYS_READS, sum(PHYWRTS) PHYS_WRTS from v\$filestat) pd
  , v\$datafile df
  , v\$datafile df
  , v\$filestat fs
where df.FILE# = fs.FILE#
order by fs.PHYBLKRD+fs.PHYBLKWRT desc;
prompt
prompt ##############################################################
prompt # ??? #
prompt ##############################################################
col event for a70
col total_waits for a15
col total_timeouts for a15
col time_waited for a15
select EVENT
  , to_char(TOTAL_WAITS) as TOTAL_WAITS
  , to_char(TOTAL_TIMEOUTS) as TOTAL_TIMEOUTS
  , to_char(TIME_WAITED) as TIME_WAITED
  , round(AVERAGE_WAIT,2) "Average Wait"
from v\$system_event
order by event, to_char(TOTAL_WAITS);
prompt
prompt ##############################################################
prompt # Datafiles Sync Status                                      #
prompt ##############################################################
col name format a100
select distinct name
  , asynch_io
from v\$datafile d
inner join v\$iostat_file f on d.file# = f.file_no;
prompt
-- SET SERVEROUTPUT ON
-- DECLARE
  -- lat  INTEGER;
  -- iops INTEGER;
  -- mbps INTEGER;
-- BEGIN
  -- DBMS_RESOURCE_MANAGER.CALIBRATE_IO(
    -- 1    /* # of disks */
    -- , 10   /* maximum tolerable latency in milliseconds */
    -- , iops /* I/O rate per second */
    -- , mbps /* throughput, MB per second */
    -- , lat  /* actual latency in milliseconds */
   -- );
  -- DBMS_OUTPUT.PUT_LINE('max_iops = ' || iops);
  -- DBMS_OUTPUT.PUT_LINE('latency  = ' || lat);
  -- DBMS_OUTPUT.PUT_LINE('max_mbps = ' || mbps);
-- END;
-- /
prompt ##############################################################
prompt # Datafiles Size Reads                                       #
prompt ##############################################################
col name for a100
select d.name
  , f.file_no
  , f.small_read_megabytes
  , f.small_read_reqs
  , f.large_read_megabytes
--  , f.large_read_reqs
from v\$iostat_file f
inner join v\$datafile d on f.file_no = d.file#;
quit;
EOF
}
#
#########################################################################################################
# VERIFY MAIN TOP WAIT EVENTS PER WEEK
#########################################################################################################
#
function DBA_087() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|' trim on trims on numformat 999999999999999
-- Auslesen Event Historie (cursor: mutex S) - je Report
prompt ##############################################################
prompt # VERIFY MAIN TOP WAIT EVENTS PER WEEK
prompt ##############################################################
col begin_interval_time format a20
col end_interval_time format a20
col AVG_WAIT_TIME_MSEC for a30
col EVENT_NAME for a40
col total_waits for a15
col total_waited_sec for a15
col KW for a5
col AVG_WAIT_TIME_MSEC for 999999999,99
select dhs.snap_id
  , to_char(dhs.begin_interval_time,'iw') kw
  , to_char(dhs.begin_interval_time,'dd/mm/yyyy hh24:mi:ss') begin_interval_time
  , to_char(dhs.end_interval_time,'dd/mm/yyyy hh24:mi:ss') end_interval_time
  , to_char(event_name) event_name
  , to_char(total_waits) total_waits
  , to_char(round(total_waited_micro/1000000)) as total_waited_sec
  , decode(total_waits,0,0,round(total_waited_micro/total_waits/1000,2)) avg_wait_time_msec
FROM (select snap_id
        , event_name
        , total_waits - lag( total_waits) OVER(ORDER BY snap_id) AS total_waits
        , time_waited_micro - lag (time_waited_micro) over (ORDER BY snap_id) as total_waited_micro
      FROM dba_hist_system_event
      WHERE event_name in ('db file sequential read','direct path read','direct path read temp','direct path sync','direct path write','direct path write temp','log file sync','db file scattered read','cursor: mutex S')
      ORDER BY snap_id) details,
dba_hist_snapshot dhs
WHERE dhs.snap_id = details.snap_id
and total_waits > 0
-- and begin_interval_time > sysdate - 12/24
ORDER BY dhs.snap_id;
quit;
EOF
}
#
#########################################################################################################
# VERIFY OBJECTS SIZE
#########################################################################################################
#
function DBA_088() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # SIZE BY OWNER                                              #
prompt ##############################################################
col size_mb for a20
col size_gb for a20
col size_tb for a20
col owner for a30
select owner
  , to_char(sum(bytes)/1024/1024,'999G999G999D999') as SIZE_MB
  , to_char(sum(bytes)/1024/1024/1024,'999G999G999D999') as SIZE_GB
  , to_char(sum(bytes)/1024/1024/1024/1024,'999G999G999D999') as SIZE_TB
From dba_segments
group by owner
order by owner;
prompt
prompt ##############################################################
prompt # VERIFY LARGESTS OBJECTS
prompt ##############################################################
col owner format a30
col segment_name format a50
col segment_type format a20
col tablespace_name format a20
col mb format 999,999,999,999
col gb format 999,999,999,999
col tb format 999,999,999,999
select owner
  , segment_name
  , segment_type
  , tablespace_name
  , mb
  , gb
  , tb
from (select owner
        , segment_name
        , segment_type
        , tablespace_name
        , bytes/1024/1024 "MB"
        , bytes/1024/1024/1024 "GB"
        , bytes/1024/1024/1024/1024 "TB"
      from dba_segments
      order by bytes desc)
where rownum < 26;
quit;
EOF
}
#
#########################################################################################################
# GENERAL DATABASE OVERVIEW
#########################################################################################################
#
function DBA_089() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 1000 lines 5000 timing off long 9999999 numwidth 20 heading on echo off verify on colsep '|' head off TRIMSPOOL ON NEWPAGE NONE
prompt ##############################################################
prompt # GENERAL DATABASE OVERVIEW
prompt ##############################################################
col PROPERTY_NAME for a25
col PROPERTY_VALUE for a15
col DESCRIPTION for a35
col DIRECTORY_PATH for a70
col directory_name for a25
col OWNER for a10
col DBA_LINK for a40
col HOST for a20
col "User_Concurrent_Queue_Name" format a50 heading 'Manager'
col "Running_Processes" for 9999 heading 'Running'
break on utl_file_dir
select '------------------------ Getting Database Information ------------------------' from dual;
select 'Database Name.....................: ' || name from v\$database;
select 'Database Status...................: ' || open_mode from v\$database;
select 'Archiving Status..................: ' || log_mode from v\$database;
select 'Global Name.......................: ' || global_name from global_name;
select 'Service Name......................: ' || value from v\$parameter where name = 'service names';
select 'Creation Date.....................: ' || to_char(created,'DD/MM/YYYY HH24:MI:SS') from v\$database;
select 'Checking For Missing File.........: ' || count(*) from v\$recover_file;
select 'Checking Missing File Name .......: ' || count(*) from v\$datafile where name like '%MISS%';
select 'Total SGA MB......................: ' || round(sum(value)/(1024*1024)) || ' MB' from v\$sga ;
select 'Total SGA GB......................: ' || round(sum(value)/(1024*1024*1024)) || ' GB' from v\$sga ;
select 'Total SGA TB......................: ' || round(sum(value)/(1024*1024*1024*1024)) || ' TB' from v\$sga ;
select 'Database Version..................: ' || version from v\$instance;
select 'Database Size MB..................: ' || trim(to_char(sum(bytes)/1024/1024,'9G999G999D99')) || ' MB' from (select sum(bytes) bytes from dba_data_files
union all
select sum(bytes) bytes from dba_temp_files
union all
select sum(bytes * members) from v\$log
union all
select sum(block_size * file_size_blks) from v\$controlfile);
select 'Database Size GB..................: ' || trim(to_char(sum(bytes)/1024/1024/1024,'9G999G999D99')) || ' GB' from (select sum(bytes) bytes from dba_data_files
union all
select sum(bytes) bytes from dba_temp_files
union all
select sum(bytes * members) from v\$log
union all
select sum(block_size * file_size_blks) from v\$controlfile);
select 'Database Size TB..................: ' || trim(to_char(sum(bytes)/1024/1024/1024/1024,'9G999G999D99')) || ' TB' from (select sum(bytes) bytes from dba_data_files
union all
select sum(bytes) bytes from dba_temp_files
union all
select sum(bytes * members) from v\$log
union all
select sum(block_size * file_size_blks) from v\$controlfile);
select 'Temporary Tablespace..............: ' || property_value from database_properties where property_name like 'default_temp_tablespace';
select 'Apps Temp Tablespace..............: ' || temporary_tablespace from dba_users where username like '%APPS%';
select 'Temp Tablespace Size..............: ' || sum(maxbytes/1024/1024/1024) || ' GB' from dba_temp_files group by tablespace_name;
select 'No of Invalid Object .............: ' || count(*) from dba_objects where status = 'INVALID' ;
select 'plsql Code Type...................: ' || value from v\$parameter2 where name = 'plsql_code_type';
select 'plsql Subdir Count................: ' || value from v\$parameter2 where name = 'plsql_native_library_subdir_count';
select 'plsql Native Library Dir..........: ' || value from v\$parameter2 where name = 'plsql_native_library_dir';
select 'Shared Pool Size.........,........: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'shared_pool_size';
select 'Log Buffer........................: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'log_buffer';
select 'Buffer Cache MB...................: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'DBA_cache_size';
select 'Buffer Cache GB...................: ' || (value/1024/1024/1024) || ' GB' from v\$parameter where name = 'DBA_cache_size';
select 'Buffer Cache TB...................: ' || (value/1024/1024/1024/1024) || ' TB' from v\$parameter where name = 'DBA_cache_size';
select 'Large Pool Size MB................: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'large_pool_size';
select 'Large Pool Size GB................: ' || (value/1024/1024/1024) || ' GB' from v\$parameter where name = 'large_pool_size';
select 'Java Pool Size MB.................: ' || (value/1024/1024) || ' MB' from v\$parameter where name = 'java_pool_size';
select 'Java Pool Size GB.................: ' || (value/1024/1024/1024) || ' GB' from v\$parameter where name = 'java_pool_size';
select 'utl_file_dir......................: ' || value from v\$parameter2 where name = 'utl_file_dir';
select directory_name || '................: ' || directory_path from all_directories where rownum < 15;
quit;
EOF
}
#
#
#########################################################################################################
# DATABASE DASHBOARD
#########################################################################################################
#
function DBA_090() {
varDBA_JSS=$(sqlplus -S / as sysdba <<EOF
set define off trims on newp none heads off echo off feed off pagesize 0 null null verify off wrap off timing off serveroutput off termout off heading off
alter session set current_schema = system;
var varDBA_JSS varchar2(50);
begin
  select count(*) into :varDBA_JSS from all_objects where owner = 'SYSTEM' and object_name like 'JSS%';
end;
/
print varDBA_JSS
quit;
EOF
)
#
if [[ ${varDBA_JSS} = 0 ]]; then
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # INSTALLING THE DATABASE DASHBOARD
prompt ##############################################################
grant create type to system;
grant create procedure to system;
grant execute on dbms_lock to system;
grant select on gv_\$sql to system;
grant select on gv_\$sql_monitor to system;
grant select on gv_\$active_session_history to system;
grant select on gv_\$osstat to system;
grant select on gv_\$instance to system;
grant select on gv_\$statname to system;
grant select on gv_\$sysstat to system;
grant select on gv_\$segment_statistics to system;
grant select on gv_\$dlm_misc to system;
grant select on gv_\$sysmetric to system;
grant select on v_\$parameter to system;
alter session set current_schema=system;
drop type ta_obj;
drop type ta_ginst;
drop type ta_gash;
drop type ta_gc;
drop type ta_gsqlm;
drop type ty_obj;
drop type ty_ginst;
drop type ty_gash;
drop type ty_gsqlm;
drop type ty_gc;
drop package body JSS;
drop package jss;
create or replace type ty_obj as object (output varchar2(2500));
/
create or replace type ty_ginst as object
  (
    inst_id       number(2),
    inst_name     varchar2(16),
    statname      varchar2(64),
    value         number,
    Times         date
   );
/
create or replace type ty_gash as object
  (
    inst_id       number,
    sid           number,
    sql_id        varchar2(13),
    sql_child     number,
    sql_text      varchar2(100),
    planhash      varchar2(64),
    offloadpct    number,
    plancntrl     varchar2(10),
    pgamb         number,
    tmpmb         number,
    event         varchar2(64),
    wait_class    varchar2(64),
    time_Waited   number,
    obj#          number
   );
/
create or replace type ty_gsqlm as object
  (
    inst_id                    number,
    sql_id                     varchar2(13),
    sql_text                   varchar2(100),
    elapsed_time               number,
    cpu_time                   number,
    concurrency_Wait_time      number,
    cluster_Wait_time          number,
    user_io_wait_time          number,
    physical_read_bytes        number,
    px_server#                 number
  );
 /
create or replace type ty_gc as object
 (
   inst_id    number(2),
   GCBCS      number,
   GCBRS      number,
   GMSR       number
  );
/
create or replace type ta_gc as table of ty_gc;
/
create or replace type ta_gsqlm is table of ty_gsqlm;
/
create or replace type ta_obj as table of ty_obj;
/
create or replace type ta_ginst as table of ty_ginst;
/
create or replace type ta_gash as table of ty_gash;
/
CREATE OR REPLACE PACKAGE JSS
AS
FUNCTION GTOP
  (
     PV_ARR_SIZE     INT DEFAULT 50,
     PV_SAMPLE       INT DEFAULT 6,
     PV_COLORS       INT DEFAULT 1,
     PV_SYSMETRC_ID1 INT DEFAULT NULL,
     PV_SYSMETRC_ID2 INT DEFAULT NULL,
     PV_SYSMETRC_ID3 INT DEFAULT NULL
  )
RETURN ta_obj pipelined;
FUNCTION GTOPHELP
RETURN TA_OBJ PIPELINED;
end;
/
CREATE OR REPLACE PACKAGE body jss
AS
---##############
-- Global Variables
---##############
pv_first_ginst        ta_ginst := ta_ginst();   -- variables to store global instance info by using gv\$sysstat, first sample
pv_last_ginst         ta_ginst := ta_ginst();   -- second sample, In order to get delta data
pv_only_gash          ta_gash  := ta_gash();    -- to store gv\$active_session_history data for given sample
pv_version            number;
pv_tmp_obj            ta_obj   := ta_obj() ;    -- temporary variable
pv_only_gsqlm         ta_gsqlm := ta_gsqlm();   -- to store gv\$sql_monitor info, no delta
pv_num_cpus           int;                      -- no. of cores from gv\$iostat
pv_maxcpuprint        varchar2(100);            -- array no. to get maxcpu print in active session graph
p_sample              int;                      -- Input parameter for delay in sample\/sleep time
pv_st_sample          date;                     -- sample start time from sysdate
pv_et_sample          date;                     -- sample end time from sysdate
pv_top_sql            ta_obj := ta_obj();       -- to store top sqls from pv_only_gash collection
pv_only_gc            ta_gc  :=  ta_gc();       -- Global Cache info from gv\$sysstat
pv_block_size         number;                   -- Block size from v\$parameter to calculate interconnect traffic
pv_tmp_gcinfo         ta_obj := ta_obj();       -- temporary global variable
PV_SYSMETRIC_STRING1  VARCHAR2(200);
PV_SYSMETRIC_STRING2  VARCHAR2(200);
pv_sysmetric_string3  varchar2(200);
V_PGAMB               VARCHAR2(20);
v_tmpmb               varchar2(20);
pv_maxcpu_string      varchar2(50);
----##################################################
-- Variables to draw active sessions Graph, 80 samples are shown in graph.
-- 4 arrays are used to show session range.
----##################################################
pa_stet  ta_obj := ta_obj();  pa1       ta_obj := ta_obj(); pa2       ta_obj := ta_obj();
pa3      ta_obj := ta_obj();  pa4       ta_obj := ta_obj(); pa5       ta_obj := ta_obj();
pa6      ta_obj := ta_obj();  pa7       ta_obj := ta_obj(); pa8       ta_obj := ta_obj();
pa9      ta_obj := ta_obj();  pa10      ta_obj := ta_obj(); pa11      ta_obj := ta_obj();
pa12     ta_obj := ta_obj();  pa13      ta_obj := ta_obj(); pa14      ta_obj := ta_obj();
pa15      ta_obj := ta_obj(); pa16      ta_obj := ta_obj(); pa17      ta_obj := ta_obj();
pa18      ta_obj := ta_obj(); pa19      ta_obj := ta_obj(); pa20      ta_obj := ta_obj();
pa21      ta_obj := ta_obj(); pa22      ta_obj := ta_obj(); pa23      ta_obj := ta_obj();
pa24      ta_obj := ta_obj(); pa25      ta_obj := ta_obj(); pa26      ta_obj := ta_obj();
pa27      ta_obj := ta_obj(); pa28      ta_obj := ta_obj(); pa29      ta_obj := ta_obj();
pa30      ta_obj := ta_obj(); pa31      ta_obj := ta_obj(); pa32      ta_obj := ta_obj();
pa33      ta_obj := ta_obj(); pa34      ta_obj := ta_obj(); pa35      ta_obj := ta_obj();
pa36      ta_obj := ta_obj(); pa37      ta_obj := ta_obj(); pa38      ta_obj := ta_obj();
pa39      ta_obj := ta_obj(); pa40      ta_obj := ta_obj(); pa41      ta_obj := ta_obj();
pa42      ta_obj := ta_obj(); pa43      ta_obj := ta_obj(); pa44      ta_obj := ta_obj();
pa45      ta_obj := ta_obj(); pa46      ta_obj := ta_obj(); pa47      ta_obj := ta_obj();
pa48      ta_obj := ta_obj(); pa49      ta_obj := ta_obj(); pa50      ta_obj := ta_obj();
pa51      ta_obj := ta_obj(); pa52      ta_obj := ta_obj(); pa53      ta_obj := ta_obj();
pa54      ta_obj := ta_obj(); pa55      ta_obj := ta_obj(); pa56      ta_obj := ta_obj();
pa57      ta_obj := ta_obj(); pa58      ta_obj := ta_obj(); pa59      ta_obj := ta_obj();
pa60      ta_obj := ta_obj(); pa61      ta_obj := ta_obj(); pa62      ta_obj := ta_obj();
pa63      ta_obj := ta_obj(); pa64      ta_obj := ta_obj(); pa65      ta_obj := ta_obj();
pa66      ta_obj := ta_obj(); pa67      ta_obj := ta_obj(); pa68      ta_obj := ta_obj();
pa69      ta_obj := ta_obj(); pa70      ta_obj := ta_obj(); pa71      ta_obj := ta_obj();
pa72      ta_obj := ta_obj(); pa73      ta_obj := ta_obj(); pa74      ta_obj := ta_obj();
pa75      ta_obj := ta_obj(); pa76      ta_obj := ta_obj(); pa77      ta_obj := ta_obj();
pa78      ta_obj := ta_obj(); pa79      ta_obj := ta_obj(); pa80      ta_obj := ta_obj();
pa81      ta_obj := ta_obj(); pa82      ta_obj := ta_obj(); pa83      ta_obj := ta_obj();
pa84      ta_obj := ta_obj();
pv_maxval    int ;    --- info regarding maxval of Active Session Graph array
pv_tmp_maxval int;    --- for reshuffling the maxval based on current active sessions
pv_maxsess   int ;    --- max sessions reached in last 80 samples
 ------------------ to store waits
pv_cpuwaitpct int;
pv_iowaitpct  int;
pv_cluwaitpct int;
pv_othwaitpct int;
PV_CPU_DIG     VARCHAR2(11) ;
PV_IO_DIG      VARCHAR2(11) ;
PV_CLU_DIG     VARCHAR2(11) ;
pv_oth_dig     varchar2(11) ;
p_localarray   int := 0;
pva int;
pvb int;
pvc int;
pvd int;
pve int;
JS_MAXSESS    INT := 0;
js_arr        int := 0 ;
pv_work_done  int := 0;
----##################################################
-- Fbyt function format bytes in K,M,G,T
----##################################################
FUNCTION fbyt(V_SIZE_K   NUMBER)
RETURN varchar2
AS
BEGIN
if v_size_k > 0  then
    IF      V_SIZE_K/1024                  <= 1023 THEN RETURN ROUND(V_SIZE_K/1024,1)||'K';
    ELSIF   V_SIZE_K/1024/1024             <= 1023 THEN RETURN ROUND(V_SIZE_K/1024/1024,1)||'M';
    ELSIF   V_SIZE_K/1024/1024/1024        <= 1023 THEN RETURN ROUND(V_SIZE_K/1024/1024/1024,1)||'G';
    ELSIF   V_SIZE_K/1024/1024/1024/1024   <= 1023 THEN RETURN ROUND(V_SIZE_K/1024/1024/1024/1024,1)||'T';
    END IF;
ELSE   RETURN ' '; -- instead of null so that lpad function should work
end if;
end;
------##################
--Initial Procedure to extend all the arrays to ASG [Active Sessions Graph]
------##################
procedure initactarr
as
begin
 ---extending arrays
    pa1.extend(21);   pa2.extend(21); pa3.extend(21);  pa4.extend(21);   pa5.extend(21);
    pa6.extend(21);   pa7.extend(21); pa8.extend(21);  pa9.extend(21);  pa10.extend(21);
    pa11.extend(21); pa12.extend(21); pa13.extend(21); pa14.extend(21); pa15.extend(21);
    pa16.extend(21); pa17.extend(21); pa18.extend(21); pa19.extend(21); pa20.extend(21);
    pa21.extend(21); pa22.extend(21); pa23.extend(21); pa24.extend(21); pa25.extend(21);
    pa26.extend(21); pa27.extend(21); pa28.extend(21); pa29.extend(21); pa30.extend(21);
    pa31.extend(21); pa32.extend(21); pa33.extend(21); pa34.extend(21); pa35.extend(21);
    pa36.extend(21); pa37.extend(21); pa38.extend(21); pa39.extend(21); pa40.extend(21);
    pa41.extend(21); pa42.extend(21); pa43.extend(21); pa44.extend(21); pa45.extend(21);
    pa46.extend(21); pa47.extend(21); pa48.extend(21); pa49.extend(21); pa50.extend(21);
    pa51.extend(21); pa52.extend(21); pa53.extend(21); pa54.extend(21); pa55.extend(21);
    pa56.extend(21); pa57.extend(21); pa58.extend(21); pa59.extend(21); pa60.extend(21);
    pa61.extend(21); pa62.extend(21); pa63.extend(21); pa64.extend(21); pa65.extend(21);
    pa66.extend(21); pa67.extend(21); pa68.extend(21); pa69.extend(21); pa70.extend(21);
    pa71.extend(21); pa72.extend(21); pa73.extend(21); pa74.extend(21); pa75.extend(21);
    pa76.extend(21); pa77.extend(21); pa78.extend(21); pa79.extend(21); pa80.extend(21);
exception
when others then
raise_application_Error(-20001,'INITACTARR : '||sqlerrm );
end;
-------------------
------##################
-- ginsteff build data set from gv\$sysstat, gv\$osstat, gv\$dlm_misc
-- and load data collection name pv_last_ginst
-- only every loop, pv_last_ginst will be assigned to pv_first_ginst to get the delta
------##################
function ginsteff return ta_ginst
is
fv_ginst  ta_ginst := ta_ginst();
fv_sql    varchar2(3000) := q'[select ty_ginst(a.instance_number, a.instance_name, b.name, c.value, sysdate) from gv\$instance a, gv\$statname b, gv\$sysstat c where a.inst_id = b.inst_id and b.inst_id = c.inst_id and b.statistic# = c.statistic# and b.name in ('execute count','parse count (hard)','parse count (total)','physical read total IO requests','physical read total bytes','physical write total IO requests','physical write total bytes','redo size','session logical reads','user commits','cell physical IO interconnect bytes returned by smart scan','cell physical IO bytes saved by storage index','cell flash cache read hits','gc cr blocks served','gc current blocks served','gc cr blocks received','gc current blocks received','gcs messages sent','ges messages sent')
union all
select ty_ginst(d.inst_id, e.instance_name, d.stat_name, d.value, sysdate) from gv\$osstat d, gv\$instance e where d.inst_id = e.inst_id and d.stat_name in ('IDLE_TIME','USER_TIME','SYS_TIME','IOWAIT_TIME','BUSY_TIME','NICE_TIME','NUM_CPU_CORES')
union all
select ty_ginst(i.inst_id, i.instance_name, d.name, d.value, sysdate) from gv\$instance i, gv\$dlm_misc d where i.inst_id = d.inst_id and d.name in ('gcs msgs received','ges msgs received')]';
begin
  execute immediate fv_sql bulk collect into fv_ginst;
return fv_ginst;
exception
  when others then
raise_application_Error(-20001,'GINSTEFF : ' || sqlerrm);
end;
-------------------
------##################
-- ginstbuilddata - once data set is ready by calling ginsteff [ above function ], ginstbuilddata
-- format the data by query both samples [ pv_first_ginst and pv_last_ginst ]
------##################
function ginstbuilddata (fv_firstsample ta_ginst, fv_lastsample  ta_ginst) return ta_obj
is
fv_ta_obj      ta_obj := ta_obj();
v_sampl_time   int;
v_total_time   int;
-- Variables to store sum values for cluster
vt_tprse       int := 0;
vt_hprse       int := 0;
vt_phwio       int := 0;
vt_phwmb       int := 0;
vt_phrio       int := 0;
vt_phrmb       int := 0;
vt_slio        int := 0;
vt_exec        int := 0;
vt_redo        int := 0;
vt_comt        int := 0;
vt_exSS        int := 0;
vt_exSI        int := 0;
vt_exFC        int := 0;
begin
pv_only_gc.delete;
fv_ta_obj.extend;
fv_ta_obj(fv_ta_obj.count) := ty_obj( '+Inst-------+CPUIDL%--IO%-USR%--SYS%+--Tprse/s--+Hprse/s+--PhyWIO/s-+-PhyWMB/s-+--PhyRIO/s--+-PhyRMB/s-+-SessLIO/s--+---Exec/s-+RedoMB/s+Commit/s+-ExSSMB/s-+-ExSIMB/s+-ExFCRh/s+') ;
    --- updating CPU info -- updating with every sample in case new node join/leave the cluser
        select sum(first.value) into pv_num_cpus from table (fv_firstsample) first where first.statname = 'NUM_CPU_CORES';
    --- Initializing package variables with sample time for later use.
        select first.times,last.times  into pv_st_sample, pv_et_sample from table (fv_firstsample) first, table( fv_lastsample ) last where rownum = 1;
    ---# Not using pv_sample as selecting across multiple instances may take more time, so would be wise to calculate sample based on timestamps
        v_sampl_time := (pv_et_sample - pv_st_sample ) *24*60*60 ;
    -------
   for i in (select distinct inst_id from table(fv_lastsample ) order by inst_id ) loop -- processing order by inst_id. Pls. note : no restriction on no. of instances
            -------------
            for ii in (select b.inst_id,b.inst_name,
                        max(decode(b.statname,'DB time', round((b.value-a.value)/v_sampl_time)))                                                               dbtime,
                        max(decode(b.statname,'parse count (total)', round((b.value-a.value)/v_sampl_time)))                                                   Tparse,
                        max(decode(b.statname,'parse count (hard)', round((b.value-a.value)/v_sampl_time)))                                                    Hparse,
                        max(decode(b.statname,'physical write total IO requests', round((b.value-a.value)/v_sampl_time)))                                      PhyWIO,
                        max(decode(b.statname,'physical write total bytes', round(((b.value-a.value)/1048576)/v_sampl_time)))                                  PhyWMB,
                        max(decode(b.statname,'physical read total IO requests', round((b.value-a.value)/v_sampl_time)))                                       PhyRIO,
                        max(decode(b.statname,'physical read total bytes', round(((b.value-a.value)/1048576)/v_sampl_time)))                                   PhyRMB,
                        max(decode(b.statname,'session logical reads', round((b.value-a.value)/v_sampl_time)))                                                 SessLIO,
                        max(decode(b.statname,'execute count', round((b.value-a.value)/v_sampl_time)))                                                         TotExec,
                        max(decode(b.statname,'redo size', round(((b.value-a.value)/1048576)/v_sampl_time)))                                                   RedoMB,
                        max(decode(b.statname,'user commits', round((b.value-a.value)/v_sampl_time)))                                                          Ccommit,
                        sum(decode(b.statname,'IDLE_TIME', round((b.value-a.value)/v_sampl_time)))                                                             idle_time,
                        sum(decode(b.statname,'USER_TIME', round((b.value-a.value)/v_sampl_time)))                                                             user_time,
                        sum(decode(b.statname,'SYS_TIME',  round((b.value-a.value)/v_sampl_time)))                                                             sys_time,
                        sum(decode(b.statname,'IOWAIT_TIME', round((b.value-a.value)/v_sampl_time)))                                                           iowait_time,
                        sum(decode(b.statname,'BUSY_TIME', round((b.value-a.value)/v_sampl_time)))                                                             busy_time,
                        sum(decode(b.statname,'NICE_TIME', round((b.value-a.value)/v_sampl_time)))                                                             nice_time,
                        sum(decode(b.statname,'cell physical IO interconnect bytes returned by smart scan', round(((b.value-a.value)/1048576)/v_sampl_time)))  ExSSMB,
                        sum(decode(b.statname,'cell physical IO bytes saved by storage index', round(((b.value-a.value)/1048576)/v_sampl_time)))               ExSIMB,
                        sum(decode(b.statname,'cell flash cache read hits', round(((b.value-a.value))/v_sampl_time)))                                          ExFCRh,
                        sum(decode(b.statname,'gc cr blocks served', round(((b.value-a.value))/v_sampl_time)))                                                 GCCRBS,
                        sum(decode(b.statname,'gc current blocks served', round(((b.value-a.value))/v_sampl_time)))                                            GCCUBS,
                        sum(decode(b.statname,'gc cr blocks received', round(((b.value-a.value))/v_sampl_time)))                                               GCCRBR,
                        sum(decode(b.statname,'gc current blocks received', round(((b.value-a.value))/v_sampl_time)))                                          GCCUBR,
                        sum(decode(b.statname,'gcs msgs received', round(((b.value-a.value))/v_sampl_time)))                                                   GCSMR,
                        sum(decode(b.statname,'ges msgs received', round(((b.value-a.value))/v_sampl_time)))                                                   GESMR,
                        sum(decode(b.statname,'gcs messages sent', round(((b.value-a.value))/v_sampl_time)))                                                   GCSMS,
                        sum(decode(b.statname,'ges messages sent', round(((b.value-a.value))/v_sampl_time)))                                                   GESMS
                        from table(fv_lastsample) b, table(fv_firstsample) a
                        where a.inst_id = b.inst_id and a.statname = b.statname and a.inst_id = i.inst_id group by b.inst_id,b.inst_name) loop
            v_total_time :=  ii.idle_time+ii.busy_time;
            fv_ta_obj.extend;
            fv_ta_obj(fv_ta_obj.count) := ty_obj( '|' ||
              rpad(substr(ii.inst_name,1,11),11,' ') || '|' ||
              lpad(trunc(100-((ii.iowait_time+ii.user_time+ii.sys_time+ii.nice_time)/v_total_time*100),1) || ' ',6,' ') ||
              lpad(trunc(ii.iowait_time/v_total_time*100,1),5,' ') || ' ' ||
              lpad(trunc(ii.user_time/v_total_time*100,1),5,' ') || ' ' ||
              lpad(trunc(ii.sys_time/v_total_time*100,1),5,' ') || '|' ||
              lpad(ii.Tparse,11,' ') || '|' ||
              lpad(ii.Hparse,7,' ') || '|' ||
              lpad(ii.Phywio,11,' ') || '|' ||
              lpad(ii.phywmb,10,' ') || '|' ||
              lpad(ii.phyrio,12,' ') || '|' ||
              lpad(ii.phyrmb,10,' ') || '|' ||
              lpad(ii.sesslio,12,' ') || '|' ||
              lpad(ii.totexec,10,' ') || '|' ||
              lpad(ii.redomb,8,' ') || '|' ||
              lpad(ii.ccommit,8,' ') || '|' ||
              lpad(ii.ExSSMB,10,' ') || '|' ||
              lpad(ii.ExSIMB,9,' ') || '|' ||
              lpad(ii.ExFCRh,9,' ') || '|'
              ) ;
      -- Filling GC data into global array for later use., info for columns related to gc* waits
            pv_only_gc.extend;
            pv_only_gc(pv_only_gc.count) := ty_gc(ii.inst_id,ii.GCCRBS+ii.GCCUBS,ii.GCCRBR+ii.GCCRBR,ii.GCSMR+ii.GESMR+ii.GCSMS+ii.GESMS);
          -------------- Getting Total/sum
            vt_tprse   :=  vt_tprse + ii.tparse;
            vt_hprse   :=  vt_hprse + ii.hparse;
            vt_phwio   :=  vt_phwio + ii.phywio;
            vt_phwmb   :=  vt_phwmb + ii.phywmb;
            vt_phrio   :=  vt_phrio + ii.phyrio;
            vt_phrmb   :=  vt_phrmb + ii.phyrmb;
            vt_slio    :=  vt_slio  + ii.sesslio;
            vt_exec    :=  vt_exec  + ii.totexec;
            vt_redo    :=  vt_redo  + ii.redomb;
            vt_comt    :=  vt_comt  + ii.ccommit;
            vt_exSS    :=  vt_exSS  + ii.ExSSMB;
            vt_exSI    :=  vt_exSI  + ii.ExSIMB;
            vt_exFC    :=  vt_exFC  + ii.ExFCRh;
         --------------
          end loop;
   end loop;
  -------
     fv_ta_obj.extend;
     fv_ta_obj(fv_ta_obj.count) := ty_obj( '+-----------+-----------------------+-----------+-------+-----------+----------+------------+----------+------------+----------+--------+--------+----------+---------+---------+'  )  ;
     fv_ta_obj.extend;
     fv_ta_obj(fv_ta_obj.count) := ty_obj( '                              TOTAL :' || lpad(vt_tprse,11,' ')||','||lpad(vt_hprse,7,' ')||','||lpad(vt_phwio,11,' ')||','||lpad(vt_phwmb,10,' ')||','||lpad(vt_phrio,12,' ')||','||lpad(vt_phrmb,10,' ')||','||lpad(vt_slio,12,' ')||','||lpad(vt_exec,10,' ')||','||lpad(vt_redo,8,' ')||','||lpad(vt_comt,8,' ')||','||lpad(vt_ExSS,10,' ')||','||lpad(vt_ExSI,9,' ')||','||lpad(vt_ExFC,9,' ')||',' );
return fv_ta_obj;
exception
when others then
raise_application_Error(-20001,'GINSTBUILDDATA: '||sqlerrm );
end;
-------------------
------##################
-- gash - build dataset from gv\$active_Session_history for the given sample time,
-- added logic to eliminate the own session info
------##################
FUNCTION GASH (FV_ST_SMPLTIME DATE,FV_ET_SMPLTIME DATE) RETURN TA_GASH
is
FV_GASH    TA_GASH := TA_GASH();
FV_SQL     VARCHAR2(2000);
BEGIN
IF PV_VERSION = 12 THEN
-- In below cursor, I am using IS_RESOLVED_ADAPTIVE_PLAN for 12c.
-- Using Min function for SQL Plan Control to pick the plan with sql patch/profile/adaptive info in case when we have both plans
FV_SQL  := q'[select ty_gash(gash.Inst_id, gash.session_id, gash.sql_id, gash.sql_child_number, substr(sql_Text,1,100), decode(sql_plan_hash_value,0,null,sql_plan_hash_value), round(decode(IO_CELL_OFFLOAD_ELIGIBLE_BYTES,0,0,100*(IO_CELL_OFFLOAD_ELIGIBLE_BYTES-IO_INTERCONNECT_BYTES)/decode(IO_CELL_OFFLOAD_ELIGIBLE_BYTES,0,1,IO_CELL_OFFLOAD_ELIGIBLE_BYTES))), substr(nvl2(sql_profile,'SProf',null)||nvl2(sql_plan_baseline,'SBase',null)||nvl2(sql_patch,'SPatc',null)||nvl2( decode(IS_RESOLVED_ADAPTIVE_PLAN,'Y','Y'),'ADapt',null),1,9), pga_allocated, temp_space_allocated, case when session_state = 'WAITING' then gash.event else 'ON CPU' end, case when session_state = 'WAITING' then gash.wait_class else 'ON CPU' end, gash.delta_Time, gash.current_obj#)
from gv\$active_Session_history gash, gv\$sql gsql
where gash.sample_time between :fv_st_smpltime and :fv_et_smpltime
and  gash.program not like '%(PZ%'
and  gash.delta_time > 0
and (gash.wait_class != 'Idle' or gash.session_state != 'WAITING')
and  gash.inst_id || ':' || gash.session_id != sys_context('userenv','INSTANCE') || ':' || sys_context('userenv','SID')
and gash.inst_id = gsql.inst_id and gash.sql_id=gsql.sql_id]';
else    -- For 11gR2 Version
FV_SQL  := q'[select ty_gash(gash.Inst_id, gash.session_id, gash.sql_id, gash.sql_child_number, substr(sql_Text,1,100), decode(sql_plan_hash_value,0,null,sql_plan_hash_value), round(decode(IO_CELL_OFFLOAD_ELIGIBLE_BYTES,0,0,100*(IO_CELL_OFFLOAD_ELIGIBLE_BYTES-IO_INTERCONNECT_BYTES)/decode(IO_CELL_OFFLOAD_ELIGIBLE_BYTES,0,1,IO_CELL_OFFLOAD_ELIGIBLE_BYTES))), substr(nvl2(sql_profile,'SProf',null)||nvl2(sql_plan_baseline,'SBase',null)||nvl2(sql_patch,'SPatc',null),1,9), pga_allocated, temp_space_allocated, case when session_state = 'WAITING' then gash.event else 'ON CPU' end, case when session_state = 'WAITING' then gash.wait_class else 'ON CPU' end, gash.delta_Time, gash.current_obj#)
from gv\$active_Session_history gash, gv\$sql gsql
where gash.sample_time between :fv_st_smpltime and :fv_et_smpltime
and gash.program not like '%(PZ%'
and gash.delta_time > 0
and (gash.wait_class != 'Idle' or gash.session_state != 'WAITING')
and gash.inst_id || ':' || gash.session_id != sys_context('userenv','INSTANCE') || ':' || sys_context('userenv','SID')
and gash.inst_id = gsql.inst_id and gash.sql_id = gsql.sql_id]';
END IF;
execute immediate fv_sql bulk collect into fv_gash using fv_st_smpltime,fv_et_smpltime;
return fv_gash;
end;
-------------------
------##################
-- gashbuilddata - it access data from collection pv_only_gash built in gash function for given sample
------##################
function gashbuilddata (fv_only_gash ta_gash ) return ta_obj
is
fv_ta_obj      ta_obj := ta_obj();
fv_wait_obj    ta_obj := ta_obj();
fv_sql_obj     ta_obj := ta_obj();
fv_output      varchar2(200);
fv_sid_string  varchar2(66);
begin
--js resetting graph wait variables
pv_cpuwaitpct := 0;
pv_iowaitpct  := 0;
pv_cluwaitpct := 0;
pv_othwaitpct := 0;
------------
pv_top_sql.delete;
--- getting top 5 events based on time spent event wise
for i in (select pct,event,wait_class from (select wait_class,event, round(evnttime/tottime * 100,1) pct from
(select wait_class,event, sum(time_waited) evnttime from table(fv_only_gash) where event is not null group by wait_class, event ) evnt,
(select sum(time_Waited) tottime from table(fv_only_gash )) tot order by pct desc) where rownum < 6) loop
FV_WAIT_OBJ.EXTEND;
fv_wait_obj(fv_wait_obj.count) :=  ty_obj('| ' || lpad(round(i.pct,1) || '%',6,' ') || ' | ' || rpad(substr(i.event,1,34),34,' ') || ' | ' || rpad(i.wait_class,13,' ') || ' |');
-------------- Storing info in 4 variables to get the % of of all the waits for total active sessions for graph
case
when i.wait_class = 'ON CPU'      then pv_cpuwaitpct :=   (pv_cpuwaitpct + i.pct);
when i.wait_class = 'User I/O'    then pv_iowaitpct  :=   (pv_iowaitpct  + i.pct);
when i.wait_class = 'System I/O'  then pv_iowaitpct  :=   (pv_iowaitpct  + i.pct);
when i.wait_class = 'Cluster'     then pv_cluwaitpct :=   (pv_cluwaitpct + i.pct);
ELSE
pv_othwaitpct := (pv_othwaitpct + i.pct );
end case;
-------------
end loop;
--- getting top 5 sqls based on time spent event wise
 FOR II IN (select PLANHASH, PCT,SQL_ID || '(' || SQL_CHILD || ')' SQL_ID, OFFLOADPCT,PLANCNTRL, pgamb, tmpmb
 FROM      (select SQL_ID,SQL_CHILD, PLANHASH, OFFLOADPCT, PLANCNTRL, ROUND(SQLTIME/TOTTIME * 100,1) PCT, PGAMB, TMPMB
 FROM      (select SQL_ID,SQL_CHILD, PLANHASH, max(OFFLOADPCT) OFFLOADPCT,min(PLANCNTRL) PLANCNTRL, max(pgamb) pgamb, max(tmpmb) tmpmb, SUM(TIME_WAITED) SQLTIME FROM TABLE(FV_ONLY_GASH)
where sql_id is not null group by sql_id,sql_child, planhash ) sqlt,
(select sum(time_Waited) tottime from  table(fv_only_gash)) tot order by pct desc) where rownum < 6) loop
--- building inst_id and sid string for top sqls
select substr(sidstring,1,66) into fv_sid_string
from (select  listagg(inst_id || ':' || sid,', ') within group (order by  sql_id || '(' || sql_child || ')' ) sidstring
FROM (select DISTINCT SQL_ID, SQL_CHILD, INST_ID, SID FROM TABLE(FV_ONLY_GASH) WHERE SQL_ID || '(' || SQL_CHILD || ')' = II.SQL_ID));
V_PGAMB := FBYT(II.PGAMB);
v_tmpmb := fbyt(ii.tmpmb);
            FV_SQL_OBJ.EXTEND;
            fv_sql_obj(fv_sql_obj.count)  :=  ty_obj('    | ' || lpad(round(ii.pct,1) || '%',6,' ') || ' | ' || rpad(ii.sql_id,17,' ') || '| ' || rpad(nvl(ii.planhash,' '),9,' ') || ' | ' || lpad(ii.OFFLOADPCT || '%',7,' ') || ' |' || lpad(v_pgamb,7,' ') || '|' || lpad(v_tmpmb,7,' ') || '| ' || rpad(nvl(ii.PLANCNTRL,' '),5,' ') || ' | ' || rpad(fv_sid_string,32,' ') || ' |');
                --- filling global collection pv_top_sql for later use
           pv_top_sql.extend; pv_top_sql(pv_Top_sql.count) := ty_obj(substr(ii.sql_id,1,13));
 end loop;
  FV_TA_OBJ.EXTEND;
  fv_ta_obj(fv_ta_obj.count) := ty_obj('+IMPACT%-+--TOP WAIT EVENTS-------------------+-WAIT CLASS----+    +IMPACT%-+ TOP SQLs (child)-+--PLAN#----+-OFFLOAD-+--PGA--+--TEMP-+-PLANC-+------TOP SESSIONS----INST:SID----+' ) ;
--- printing top wait events and top sqls
  for iii in 1..greatest(fv_wait_obj.count,fv_sql_obj.count) loop
    IF FV_WAIT_OBJ.EXISTS(III)
      then
        fv_output := fv_wait_obj(iii).output;
      ELSE
        FV_OUTPUT :=                         '|        |                                    |               |' ;
      end if;
      if fv_sql_obj.exists(iii) then
        fv_output := fv_output || fv_sql_obj(iii).output;
      ELSE
       FV_OUTPUT := FV_OUTPUT || '    |        |                  |           |         |       |       |       |                                  |';
            END IF;
             fv_ta_obj.extend;
             fv_ta_obj(fv_ta_obj.count) := ty_obj(fv_output);
  end loop;
  FV_TA_OBJ.EXTEND;
  fv_ta_obj(fv_ta_obj.count) := ty_obj('+--------+------------------------------------+---------------+    +--------+------------------+-----------+---------+-------+-------+-------+----------------------------------+' );
 -- adding emplty lines to getting fixed ASG [Active Session Graph ]
 for iv in 1..(7-fv_ta_obj.count) loop
   fv_ta_obj.extend;
   fv_ta_obj(fv_ta_obj.count):= ty_obj(' ');
   end loop;
return fv_ta_obj;
--exception
--when others then
--raise_application_Error(-20001,'GASH: ' || sqlerrm);
end;
-------------------
----#######################
PROCEDURE PRINT_MAXCPU(v_ARRAYNO  INT )
as
BEGIN
PA69(V_ARRAYNO).OUTPUT := '-';
PA68(V_ARRAYNO).OUTPUT := 'M';
PA67(V_ARRAYNO).OUTPUT := 'A';
PA66(V_ARRAYNO).OUTPUT := 'X';
PA65(V_ARRAYNO).OUTPUT := ' ';
PA64(V_ARRAYNO).OUTPUT := 'C';
PA63(V_ARRAYNO).OUTPUT := 'P';
PA62(V_ARRAYNO).OUTPUT := 'U';
PA61(V_ARRAYNO).OUTPUT := '[';
if length(pv_num_cpus)= 1 then
PA60(V_ARRAYNO).OUTPUT := PV_NUM_CPUS;
PA59(V_ARRAYNO).OUTPUT := ']';
PA58(V_ARRAYNO).OUTPUT := '-';
ELSIF LENGTH(PV_NUM_CPUS)= 2 THEN
PA60(V_ARRAYNO).OUTPUT := SUBSTR(PV_NUM_CPUS,1,1);
PA59(V_ARRAYNO).OUTPUT := SUBSTR(PV_NUM_CPUS,2,1);
PA58(V_ARRAYNO).OUTPUT := ']';
PA57(V_ARRAYNO).OUTPUT := '-';
ELSIF LENGTH(PV_NUM_CPUS)= 3 THEN
PA60(V_ARRAYNO).OUTPUT := SUBSTR(PV_NUM_CPUS,1,1);
PA59(V_ARRAYNO).OUTPUT := SUBSTR(PV_NUM_CPUS,2,1);
PA58(V_ARRAYNO).OUTPUT := SUBSTR(PV_NUM_CPUS,3,1);
PA57(V_ARRAYNO).OUTPUT := ']';
PA56(V_ARRAYNO).OUTPUT := '-';
END IF;
end;
------------------
------##################
-- Gcinfo uses pv_only_gc collection built by ginstbuilddata to format
------##################
function gcinfo return ta_obj
as
fv_gcs     ta_obj := ta_obj();
fv_topgseg ta_obj := ta_obj();
fv_ta_obj  ta_obj := ta_obj();
fv_seg              varchar2(40);
fv_totblks           int;
fv_totmsgs           int;
begin
------------------------------
-- *BASED on AWR, below formula can be used to calculate  Estd interconnect Traffic
------------------------------
/*
Estd Interconnect traffic (KB): =(('gc cr blocks received' + 'gc current blocks received' + 'gc cr blocks served' + 'gc current blocks served') * db Block size)
+ (('gcs messages sent' + 'ges messages sent' + 'gcs msgs received' + 'ges msgs received' )* 200 )/1024/
 -- Sample Calculation from AWR using Above Formula
 Global Cache Load Profile
~~~~~~~~~~~~~~~~~~~~                  Per Second       Per Transact
                                      ---------------       ------------
  Global Cache blocks received:              1,086.29                  3
    Global Cache blocks served:              1,088.33                  3
     GCS/GES messages received:              2,736.50                  9
         GCS/GES messages sent:              2,681.79                  9
            DBWR Fusion writes:                  5.90                  0
 Estd Interconnect traffic (KB)             18,455.23
((1086.29 + 1088.33) * 8192) / 1024 = 17396.96
((2736.50 + 2681.79) * 200 / 1024 = 1058.26
 17396.96 + 1058.26  = (18455.22) <-- Final Value
*/
--  pv_only_gc is being populated from ginstbuilddata function [ access gv\$sysstat and gv\$dlm_misc ] only for GC* waits
--  calculating totblks received/sent and total GCS/GES messages received/sent
for i in 1..pv_only_gc.count loop
fv_totblks :=  (nvl(pv_only_gc(i).GCBCS,0) + nvl(pv_only_gc(i).GCBRS,0)) * pv_block_size ;
fv_totmsgs :=   nvl(pv_only_gc(i).GMSR,0) * 200 ;
fv_gcs.extend;
fv_gcs(fv_gcs.count) := ty_obj ( lpad(pv_only_gc(i).inst_id,3,' ') || ' | ' || lpad(nvl(pv_only_gc(i).GCBCS,0),9,' ') || '|' || lpad(nvl(pv_only_gc(i).GCBRS,0),10,' ') || '|' || lpad(round(((fv_totblks+fv_totmsgs)/1048576),1),11,' ') || '|');
end loop;
--
--  querying pv_only_gash [ global active session history data for Cluster waits and using current_obj# to find the topobject
   for ii in (select * from (select obj#, round(evnttime/tottime * 100,1) pct from
                            (select  obj#,sum(time_waited) evnttime from table(pv_only_gash) where wait_class = 'Cluster' and  obj# != -1 group by obj# ) gcobj,
                            (select sum(time_Waited) tottime from table(pv_only_gash ) where wait_class = 'Cluster' and  obj# != -1 ) tot order by pct desc) where rownum < 6) loop
            begin
            --- getting object name from gv\$segment_statistics
            select rpad((substr(s.object_type,1,3) || ':' || substr(s.object_name || nvl2(subobject_name, ':' || subobject_name,null),1,33)),37,' ') into fv_seg from gv\$segment_statistics s where s.obj# = ii.obj# and rownum = 1;
            exception
            when no_data_found then
            fv_seg := 'Obj ID not populated' ;
            end;
            fv_topgseg.extend;
            fv_topgseg(fv_topgseg.count) := ty_obj (' |' || lpad(ii.pct || '%',5) || ' ' || fv_seg);
            end loop;
--
-- building header for Global Cache info
fv_ta_obj.extend;fv_ta_obj(fv_ta_obj.count) := ty_obj( '    |  Global  |  Global  | Estd.     |                            ');
fv_ta_obj.extend;fv_ta_obj(fv_ta_obj.count) := ty_obj( '    |  Cache   |  Cache   | Intercnt  |  | TOP Segments by GC*     |');
FV_TA_OBJ.EXTEND;FV_TA_OBJ(FV_TA_OBJ.COUNT) := TY_OBJ( 'Inst|  Blocks  |  Blocks  | Traffic   |  | Waits                   |');
FV_TA_OBJ.EXTEND;FV_TA_OBJ(FV_TA_OBJ.COUNT) := TY_OBJ( '  ID|  Sent/s  |  Rcvd/s  | MB/s      |  | IMPACT% [Type:Segment]  |');
fv_ta_obj.extend;fv_ta_obj(fv_ta_obj.count) := ty_obj( '+---+----------+----------+-----------+  +-------------------------+');
            for iii in 1..12 loop     -- Concatinating output about GC info and TOP Segment
               if fv_gcs.count < iii then fv_gcs.extend; end if;
               if fv_topgseg.count < iii then fv_topgseg.extend; end if;
            fv_ta_obj.extend; fv_ta_obj(fv_ta_obj.count) := ty_obj(rpad(nvl(fv_gcs(iii).output,' '),39,' ') || ' ' || fv_topgseg(iii).output );
            end loop;
return fv_ta_obj;
exception
when others then
raise_application_Error(-20001,'GCINFO : ' || sqlerrm );
end ;
-------------------
------##################
--   stactsessar - it shuffles all the arrays to have moving effect in ASG
--   it also rearrange the max sess based on the changed array range.
------##################
procedure stactsessarr
as
procedure setgraphdigit(p_varrlenset int, p_pa in out ta_obj)
as
begin
pv_work_done := 1 ;
pva := 0;
pvb := 0;
pvc := 0;
pvd := 0;
pve := 0;
 if to_number(p_pa(18).output) > 0 then    -- CPU
     p_localarray := round(p_varrlenset * to_number(p_pa(18).output)/100) ;
     if p_localarray > 0 then
          for i in pv_work_done..p_localarray loop
            p_pa(i) := ty_obj(pv_cpu_dig) ;
            end loop;
          pv_work_done := pv_work_done + p_localarray ;
     end if;
end if;
if to_number(p_pa(19).output) > 0 then    -- IO
     p_localarray := round( p_varrlenset * to_number(p_pa(19).output)/100);
     if p_localarray > 0 then
          for i in pv_work_done..(pv_work_done + p_localarray) loop
            p_pa(i) := ty_obj(pv_io_dig) ;
          end loop;
          pv_work_done :=  pv_work_done + p_localarray ;
     end if;
end if;
if to_number(p_pa(20).output) > 0 then    -- CLU
     p_localarray := round( p_varrlenset * to_number(p_pa(20).output)/100);
     if p_localarray > 0 then
          for i in pv_work_done..(pv_work_done + p_localarray) loop
            p_pa(i) := ty_obj(pv_CLU_dig) ;
          end loop;
          pv_work_done :=  pv_work_done + p_localarray ;
     end if;
end if;
if to_number(p_pa(21).output) > 0 then    -- OTH
     p_localarray := round( p_varrlenset * to_number(p_pa(21).output)/100);
     if p_localarray > 0 then
          for i in pv_work_done..(pv_work_done + p_localarray) loop
            p_pa(i) := ty_obj(pv_oth_dig) ;
          end loop;
          pv_work_done :=  pv_work_done + p_localarray ;
     end if;
end if;
     FOR I IN (P_VARRLENSET+1)..15 LOOP  --filling remaining array
         P_PA(I) := TY_OBJ(' ');   -- I have replaced single space ' ' with ' ' to adjust colored graph
       end loop;
 end;
begin
 --- shuffling array except the first one
pa80 := pa79; pa79 := pa78; pa78 := pa77; pa77 := pa76; pa76 := pa75; pa75 := pa74; pa74 := pa73; pa73 := pa72; pa72 := pa71; pa71 := pa70;
pa70 := pa69; pa69 := pa68; pa68 := pa67; pa67 := pa66; pa66 := pa65; pa65 := pa64; pa64 := pa63; pa63 := pa62; pa62 := pa61; pa61 := pa60;
pa60 := pa59; pa59 := pa58; pa58 := pa57; pa57 := pa56; pa56 := pa55; pa55 := pa54; pa54 := pa53; pa53 := pa52; pa52 := pa51; pa51 := pa50;
pa50 := pa49; pa49 := pa48; pa48 := pa47; pa47 := pa46; pa46 := pa45; pa45 := pa44; pa44 := pa43; pa43 := pa42; pa42 := pa41; pa41 := pa40;
pa40 := pa39; pa39 := pa38; pa38 := pa37; pa37 := pa36; pa36 := pa35; pa35 := pa34; pa34 := pa33; pa33 := pa32; pa32 := pa31; pa31 := pa30;
pa30 := pa29; pa29 := pa28; pa28 := pa27; pa27 := pa26; pa26 := pa25; pa25 := pa24; pa24 := pa23; pa23 := pa22; pa22 := pa21; pa21 := pa20;
pa20 := pa19; pa19 := pa18; pa18 := pa17; pa17 := pa16; pa16 := pa15; pa15 := pa14; pa14:=pa13; pa13:=pa12; pa12:=pa11; pa11:=pa10;
pa10:= pa9; pa9:=pa8; pa8 :=pa7; pa7:=pa6; pa6:=pa5; pa5:=pa4; pa4:=pa3; pa3:=pa2; pa2:=pa1;
    -- updating first array
       pa1(21) := ty_obj(pv_othwaitpct);
       pa1(20) := ty_obj(pv_cluwaitpct);
       pa1(19) := ty_obj(pv_iowaitpct);
       pa1(18) := ty_obj(pv_cpuwaitpct);
       pa1(17) := ty_obj(pv_maxval);
       pa1(16) := ty_obj(pv_maxsess);
--- here else clause is used for the empty arrays when we start dashboard
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa1(16).output) then js_maxsess := to_number(pa1(16).output); js_arr := i-1;  setgraphdigit(i-1,pa1);  exit; else pa1(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa2(16).output) then setgraphdigit(i-1,pa2);  exit; else pa2(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa3(16).output) then setgraphdigit(i-1,pa3);  exit; else pa3(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa4(16).output) then setgraphdigit(i-1,pa4);  exit; else pa4(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa5(16).output) then setgraphdigit(i-1,pa5);  exit; else pa5(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa6(16).output) then setgraphdigit(i-1,pa6);  exit; else pa6(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa7(16).output) then setgraphdigit(i-1,pa7);  exit; else pa7(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa8(16).output) then setgraphdigit(i-1,pa8);  exit; else pa8(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa9(16).output) then setgraphdigit(i-1,pa9);  exit; else pa9(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa10(16).output) then setgraphdigit(i-1,pa10);  exit; else pa10(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa11(16).output) then setgraphdigit(i-1,pa11);  exit; else pa11(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa12(16).output) then setgraphdigit(i-1,pa12);  exit; else pa12(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa13(16).output) then setgraphdigit(i-1,pa13);  exit; else pa13(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa14(16).output) then setgraphdigit(i-1,pa14);  exit; else pa14(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa15(16).output) then setgraphdigit(i-1,pa15);  exit; else pa15(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa16(16).output) then setgraphdigit(i-1,pa16);  exit; else pa16(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa17(16).output) then setgraphdigit(i-1,pa17);  exit; else pa17(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa18(16).output) then setgraphdigit(i-1,pa18);  exit; else pa18(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa19(16).output) then setgraphdigit(i-1,pa19);  exit; else pa19(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa20(16).output) then setgraphdigit(i-1,pa20);  exit; else pa20(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa21(16).output) then setgraphdigit(i-1,pa21);  exit; else pa21(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa22(16).output) then setgraphdigit(i-1,pa22);  exit; else pa22(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa23(16).output) then setgraphdigit(i-1,pa23);  exit; else pa23(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa24(16).output) then setgraphdigit(i-1,pa24);  exit; else pa24(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa25(16).output) then setgraphdigit(i-1,pa25);  exit; else pa25(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa26(16).output) then setgraphdigit(i-1,pa26);  exit; else pa26(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa27(16).output) then setgraphdigit(i-1,pa27);  exit; else pa27(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa28(16).output) then setgraphdigit(i-1,pa28);  exit; else pa28(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa29(16).output) then setgraphdigit(i-1,pa29);  exit; else pa29(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa30(16).output) then setgraphdigit(i-1,pa30);  exit; else pa30(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa31(16).output) then setgraphdigit(i-1,pa31);  exit; else pa31(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa32(16).output) then setgraphdigit(i-1,pa32);  exit; else pa32(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa33(16).output) then setgraphdigit(i-1,pa33);  exit; else pa33(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa34(16).output) then setgraphdigit(i-1,pa34);  exit; else pa34(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa35(16).output) then setgraphdigit(i-1,pa35);  exit; else pa35(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa36(16).output) then setgraphdigit(i-1,pa36);  exit; else pa36(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa37(16).output) then setgraphdigit(i-1,pa37);  exit; else pa37(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa38(16).output) then setgraphdigit(i-1,pa38);  exit; else pa38(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa39(16).output) then setgraphdigit(i-1,pa39);  exit; else pa39(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa40(16).output) then setgraphdigit(i-1,pa40);  exit; else pa40(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa41(16).output) then setgraphdigit(i-1,pa41);  exit; else pa41(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa42(16).output) then setgraphdigit(i-1,pa42);  exit; else pa42(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa43(16).output) then setgraphdigit(i-1,pa43);  exit; else pa43(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa44(16).output) then setgraphdigit(i-1,pa44);  exit; else pa44(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa45(16).output) then setgraphdigit(i-1,pa45);  exit; else pa45(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa46(16).output) then setgraphdigit(i-1,pa46);  exit; else pa46(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa47(16).output) then setgraphdigit(i-1,pa47);  exit; else pa47(i) := ty_obj(' ');   end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa48(16).output) then setgraphdigit(i-1,pa48);  exit; else pa48(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa49(16).output) then setgraphdigit(i-1,pa49);  exit; else pa49(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa50(16).output) then setgraphdigit(i-1,pa50);  exit; else pa50(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa51(16).output) then setgraphdigit(i-1,pa51);  exit; else pa51(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa52(16).output) then setgraphdigit(i-1,pa52);  exit; else pa52(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa53(16).output) then setgraphdigit(i-1,pa53);  exit; else pa53(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa54(16).output) then setgraphdigit(i-1,pa54);  exit; else pa54(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa55(16).output) then setgraphdigit(i-1,pa55);  exit; else pa55(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa56(16).output) then setgraphdigit(i-1,pa56);  exit; else pa56(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa57(16).output) then setgraphdigit(i-1,pa57);  exit; else pa57(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa58(16).output) then setgraphdigit(i-1,pa58);  exit; else pa58(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa59(16).output) then setgraphdigit(i-1,pa59);  exit; else pa59(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa60(16).output) then setgraphdigit(i-1,pa60);  exit; else pa60(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa61(16).output) then setgraphdigit(i-1,pa61);  exit; else pa61(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa62(16).output) then setgraphdigit(i-1,pa62);  exit; else pa62(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa63(16).output) then setgraphdigit(i-1,pa63);  exit; else pa63(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa64(16).output) then setgraphdigit(i-1,pa64);  exit; else pa64(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa65(16).output) then setgraphdigit(i-1,pa65);  exit; else pa65(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa66(16).output) then setgraphdigit(i-1,pa66);  exit; else pa66(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa67(16).output) then setgraphdigit(i-1,pa67);  exit; else pa67(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa68(16).output) then setgraphdigit(i-1,pa68);  exit; else pa68(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa69(16).output) then setgraphdigit(i-1,pa69);  exit; else pa69(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa70(16).output) then setgraphdigit(i-1,pa70);  exit; else pa70(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa71(16).output) then setgraphdigit(i-1,pa71);  exit; else pa71(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa72(16).output) then setgraphdigit(i-1,pa72);  exit; else pa72(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa73(16).output) then setgraphdigit(i-1,pa73);  exit; else pa73(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa74(16).output) then setgraphdigit(i-1,pa74);  exit; else pa74(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa75(16).output) then setgraphdigit(i-1,pa75);  exit; else pa75(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa76(16).output) then setgraphdigit(i-1,pa76);  exit; else pa76(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa77(16).output) then setgraphdigit(i-1,pa77);  exit; else pa77(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa78(16).output) then setgraphdigit(i-1,pa78);  exit; else pa78(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa79(16).output) then setgraphdigit(i-1,pa79);  exit; else pa79(i) := ty_obj(' ');  end if;  end loop;
      for i in 1..15 loop  if to_number(pa_stet(i).output) > to_number(pa80(16).output) then setgraphdigit(i-1,pa80);  exit; else pa80(i) := ty_obj(' ');  end if;  end loop;
                for i in 2..15 loop
               if pv_num_cpus < to_number(pa_stet(i).output) then
                   pv_maxcpuprint := pa_stet(i-1).output;  exit; end if;
               end loop;
               -- printing exact active sess
               pa81.delete; pa81.extend(15);
               pa82.delete; pa82.extend(15);
               pa83.delete; pa83.extend(15);
               pa84.delete; pa84.extend(15);
               for i in 1..15 loop
               if  pa1(i).output in (pv_cpu_dig,pv_io_dig,pv_clu_dig,pv_oth_dig) then
                 null; -- need to add logic
                 else
                   if i > 1 then -- protecting being no active session
                   pa81(i-1) := ty_obj(substr(lpad(pv_maxsess,4,'_'),1,1));
                   pa82(i-1) := ty_obj(substr(lpad(pv_maxsess,4,'_'),2,1));
                   pa83(i-1) := ty_obj(substr(lpad(pv_maxsess,4,'_'),3,1));
                   pa84(i-1) := ty_obj(substr(lpad(pv_maxsess,4,'_'),4,1));
                   end if;
                 exit;
                 end if;
               end loop;
exception
when others then
raise_application_Error(-20001,'STACTSESSAR : ' || sqlerrm || '  ' || pv_work_done ) ;
end;
-------------------
------##################
-- gactses : it set the upper bound of array based on
-- no. of active sessions and add 15%
-- it also builds the range of sessions
------##################
Procedure gactses
is
begin
       -- Max active session at this point
       select  count (distinct ( inst_id||':'||sid )) into  pv_maxsess  from  table(pv_only_gash);
          -- Setting MAx VALUE top of CPU Vs Active sess and adding 15% -
        select case when round (max(pv_maxsess+(pv_maxsess*15/100))) < 15 then 15 else round (max(pv_maxsess+(pv_maxsess*15/100))) end  maxval  into pv_maxval from dual;
        --- searching if any existing array has got higher value.
             pv_tmp_maxval := greatest(pv_maxval,nvl(pa1(17).output,0),nvl(pa2(17).output,0),nvl(pa3(17).output,0),nvl(pa4(17).output,0)
            ,nvl(pa5(17).output,0),nvl(pa6(17).output,0), nvl(pa7(17).output,0),nvl(pa8(17).output,0),nvl(pa9(17).output,0),nvl(pa10(17).output,0),nvl(pa11(17).output,0)
            ,nvl(pa12(17).output,0),nvl(pa13(17).output,0),nvl(pa14(17).output,0),nvl(pa15(17).output,0)
            ,nvl(pa16(17).output,0) ,nvl(pa17(17).output,0) ,nvl(pa18(17).output,0) ,nvl(pa19(17).output,0) ,nvl(pa20(17).output,0)
            ,nvl(pa21(17).output,0) ,nvl(pa22(17).output,0) ,nvl(pa23(17).output,0) ,nvl(pa24(17).output,0) ,nvl(pa25(17).output,0)
            ,nvl(pa26(17).output,0) ,nvl(pa27(17).output,0) ,nvl(pa28(17).output,0) ,nvl(pa29(17).output,0) ,nvl(pa30(17).output,0)
            ,nvl(pa31(17).output,0) ,nvl(pa32(17).output,0) ,nvl(pa33(17).output,0) ,nvl(pa34(17).output,0) ,nvl(pa35(17).output,0)
            ,nvl(pa36(17).output,0) ,nvl(pa37(17).output,0) ,nvl(pa38(17).output,0) ,nvl(pa39(17).output,0) ,nvl(pa40(17).output,0)
            ,nvl(pa41(17).output,0) ,nvl(pa42(17).output,0) ,nvl(pa43(17).output,0) ,nvl(pa44(17).output,0) ,nvl(pa45(17).output,0)
            ,nvl(pa46(17).output,0) ,nvl(pa47(17).output,0) ,nvl(pa48(17).output,0) ,nvl(pa49(17).output,0) ,nvl(pa50(17).output,0)
            ,nvl(pa51(17).output,0) ,nvl(pa52(17).output,0) ,nvl(pa53(17).output,0) ,nvl(pa54(17).output,0) ,nvl(pa55(17).output,0)
            ,nvl(pa56(17).output,0) ,nvl(pa57(17).output,0) ,nvl(pa58(17).output,0) ,nvl(pa59(17).output,0) ,nvl(pa60(17).output,0)
            ,nvl(pa61(17).output,0) ,nvl(pa62(17).output,0) ,nvl(pa63(17).output,0) ,nvl(pa64(17).output,0) ,nvl(pa65(17).output,0)
            ,nvl(pa66(17).output,0) ,nvl(pa67(17).output,0) ,nvl(pa68(17).output,0) ,nvl(pa69(17).output,0) ,nvl(pa70(17).output,0)
            ,nvl(pa71(17).output,0) ,nvl(pa72(17).output,0) ,nvl(pa73(17).output,0) ,nvl(pa74(17).output,0) ,nvl(pa75(17).output,0)
            ,nvl(pa76(17).output,0) ,nvl(pa77(17).output,0) ,nvl(pa78(17).output,0) ,nvl(pa79(17).output,0) ,nvl(pa80(17).output,0));
          -- Fill Start/End array to print
             pa_stet.delete;
             select  ty_obj(val) bulk collect into pa_stet from
			 (select ceil(rownum * (pv_tmp_maxval/14)) val from dict where rownum < 15
        union all
        select 1 from dual) order by val;
        pa_stet.extend;
        pa_stet.extend;
stactsessarr;   -- calls stactsessarr to shuffle all the arrays to have moving effect
exception
when others then
raise_application_Error(-20001,'GACTSES : ' || sqlerrm);
end;
-------------------/
Procedure gset3sysmetrics (p_sysmetric_id1 int,p_sysmetric_id2 int,p_sysmetric_id3 int)
as
BEGIN
--------
PV_SYSMETRIC_STRING1 := ' ';   -- setting space for rpad
PV_SYSMETRIC_STRING2 := ' ';
PV_SYSMETRIC_STRING3 := ' ';
--------
--------------------------
select MAX(DECODE(METRIC_ID, NVL(P_SYSMETRIC_ID1,2144), V)),
       MAX(DECODE(METRIC_ID, NVL(P_SYSMETRIC_ID2,2008), V)),
       max(decode(metric_id, nvl(p_sysmetric_id3,2010), V))
       into
       pv_sysmetric_string1,
       PV_SYSMETRIC_STRING2,
       pv_sysmetric_string3
from
(select  metric_id, metric_name||'- '||V  v from
(select metric_id, METRIC_NAME, LISTAGG(VALUE, ', ') WITHIN GROUP (ORDER BY METRIC_name) "V"
FROM (select metric_id,REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(METRIC_NAME,
         'Average Synchronous Single-Block Read Latency','SingBlk Read Latency'),
         'User Rollback Undo','UsrRlbkUndo'),
         'Logical Reads Per Sec','LogicalReads /s'),
         'Per Second','/s'),
         'Per Sec','/s'),
         'Per Txn','/tx'),
         'Shared Pool','SPool'),
         'Hit Ratio','HitRtio'),
         'Global Cache','GC'),
         'Total','Tot'),
         'Database','DB'),
         'Enqueue','Enq'),
         'Percentage','%'),
         'per Second','/s'),
         'Physical','Phy'),
         'Workload','Wrklod'),
         'Capture','Cptur'),
         'Execute','Exec'),
         'Consistent','Consist'),
         'parallelized','PX'),
         'downgraded','\/'),
         'Records','Recrds'),
         'Requests','Reqs'),
         'Block','Blk'),
         'Interconnect','Interc'),
         'statements','stmts'),
         'Bytes','Byts') Metric_name, Value
        FROM (select metric_id, METRIC_NAME, INST_ID || ':' || ROUND(VALUE,1) VALUE FROM GV\$SYSMETRIC WHERE GROUP_ID = 2 and metric_id in ( nvl(p_sysmetric_id1,2144),nvl(p_sysmetric_id2,2008),nvl(p_sysmetric_id3,2010))))
GROUP BY metric_id, METRIC_NAME
order by Metric_name)
order by decode (metric_id, nvl(p_sysmetric_id1,2144), 1, nvl(p_sysmetric_id2,2008), 2, NVL(P_SYSMETRIC_ID3,2010), 3));
--------------------------
end;
------##################
-- gactsesret : it uses all global pa* arrays to format Active Session Graph
------##################
function gactsessret return ta_obj
as
fv_ta_obj  ta_obj := ta_obj();
BEGIN

IF     PV_MAXCPUPRINT = PA_STET(1).OUTPUT THEN PRINT_MAXCPU(1);
ELSIF  PV_MAXCPUPRINT = PA_STET(2).OUTPUT THEN PRINT_MAXCPU(2);
ELSIF  PV_MAXCPUPRINT = PA_STET(3).OUTPUT THEN PRINT_MAXCPU(3);
ELSIF  PV_MAXCPUPRINT = PA_STET(4).OUTPUT THEN PRINT_MAXCPU(4);
ELSIF  PV_MAXCPUPRINT = PA_STET(5).OUTPUT THEN PRINT_MAXCPU(5);
ELSIF  PV_MAXCPUPRINT = PA_STET(6).OUTPUT THEN PRINT_MAXCPU(6);
ELSIF  PV_MAXCPUPRINT = PA_STET(7).OUTPUT THEN PRINT_MAXCPU(7);
ELSIF  PV_MAXCPUPRINT = PA_STET(8).OUTPUT THEN PRINT_MAXCPU(8);
ELSIF  PV_MAXCPUPRINT = PA_STET(9).OUTPUT THEN PRINT_MAXCPU(9);
ELSIF  PV_MAXCPUPRINT = PA_STET(10).OUTPUT THEN PRINT_MAXCPU(10);
ELSIF  PV_MAXCPUPRINT = PA_STET(11).OUTPUT THEN PRINT_MAXCPU(11);
ELSIF  PV_MAXCPUPRINT = PA_STET(12).OUTPUT THEN PRINT_MAXCPU(12);
ELSIF  PV_MAXCPUPRINT = PA_STET(13).OUTPUT THEN PRINT_MAXCPU(13);
ELSIF  PV_MAXCPUPRINT = PA_STET(14).OUTPUT THEN PRINT_MAXCPU(14);
ELSIF  PV_MAXCPUPRINT = PA_STET(15).OUTPUT THEN PRINT_MAXCPU(15);
End If;

fv_Ta_obj.extend(20);
fv_ta_obj(1) :=ty_obj(rpad(' ',71,' ')||'        -------+'||'                                 ACTIVE SESSIONS GRAPH                              +----');
fv_ta_obj(2) :=ty_obj(rpad(' ',71,' ')||'  Active'||lpad(pa_stet(15).output,6,' ')||' |'||(
pa80(15).output||pa79(15).output||pa78(15).output||pa77(15).output||pa76(15).output||pa75(15).output||pa74(15).output||pa73(15).output||pa72(15).output||pa71(15).output||pa70(15).output||pa69(15).output||pa68(15).output||pa67(15).output||pa66(15).output||pa65(15).output||pa64(15).output||pa63(15).output||
pa62(15).output||pa61(15).output||pa60(15).output||pa59(15).output||pa58(15).output||pa57(15).output||pa56(15).output||pa55(15).output||pa54(15).output||pa53(15).output||pa52(15).output||pa51(15).output||pa50(15).output||pa49(15).output||pa48(15).output||pa47(15).output||pa46(15).output||pa45(15).output||
pa44(15).output||pa43(15).output||pa42(15).output||pa41(15).output||pa40(15).output||pa39(15).output||pa38(15).output||pa37(15).output||pa36(15).output||pa35(15).output||pa34(15).output||pa33(15).output||pa32(15).output||pa31(15).output||pa30(15).output||pa29(15).output||pa28(15).output||pa27(15).output||
pa26(15).output||pa25(15).output||pa24(15).output||pa23(15).output||pa22(15).output||pa21(15).output||pa20(15).output||pa19(15).output||pa18(15).output||pa17(15).output||pa16(15).output||pa15(15).output||pa14(15).output||pa13(15).output||pa12(15).output||pa11(15).output||pa10(15).output||pa9(15).output||
pa8(15).output||pa7(15).output||pa6(15).output||pa5(15).output||pa4(15).output||pa3(15).output||pa2(15).output||pa1(15).output)||rpad(nvl(pa81(15).output||pa82(15).output||pa83(15).output||pa84(15).output,' '),4,' ')||'| '||rpad(pa_stet(15).output,6,' '));

fv_ta_obj(3)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(1).output,1,71),71,' ')||'Sessions'||lpad(pa_stet(14).output,6,' ')||' |'||(
pa80(14).output||pa79(14).output||pa78(14).output||pa77(14).output||pa76(14).output||pa75(14).output||pa74(14).output||pa73(14).output||pa72(14).output||pa71(14).output||pa70(14).output||pa69(14).output||pa68(14).output||pa67(14).output||pa66(14).output||pa65(14).output||pa64(14).output||pa63(14).output||
pa62(14).output||pa61(14).output||pa60(14).output||pa59(14).output||pa58(14).output||pa57(14).output||pa56(14).output||pa55(14).output||pa54(14).output||pa53(14).output||pa52(14).output||pa51(14).output||pa50(14).output||pa49(14).output||pa48(14).output||pa47(14).output||pa46(14).output||pa45(14).output||
pa44(14).output||pa43(14).output||pa42(14).output||pa41(14).output||pa40(14).output||pa39(14).output||pa38(14).output||pa37(14).output||pa36(14).output||pa35(14).output||pa34(14).output||pa33(14).output||pa32(14).output||pa31(14).output||pa30(14).output||pa29(14).output||pa28(14).output||pa27(14).output||
PA26(14).OUTPUT||PA25(14).OUTPUT||PA24(14).OUTPUT||PA23(14).OUTPUT||PA22(14).OUTPUT||PA21(14).OUTPUT||PA20(14).OUTPUT||PA19(14).OUTPUT||PA18(14).OUTPUT||PA17(14).OUTPUT||PA16(14).OUTPUT||PA15(14).OUTPUT||PA14(14).OUTPUT||PA13(14).OUTPUT||PA12(14).OUTPUT||PA11(14).OUTPUT||PA10(14).OUTPUT||PA9(14).OUTPUT||
pa8(14).output||pa7(14).output||pa6(14).output||pa5(14).output||pa4(14).output||pa3(14).output||pa2(14).output||pa1(14).output)||rpad(nvl(pa81(14).output||pa82(14).output||pa83(14).output||pa84(14).output,' '),4,' ')||'| '||rpad(pa_stet(14).output,6,' ')||'           ' );

fv_ta_obj(4)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(2).output,1,71),71,' ')||'        '||lpad(pa_stet(13).output,6,' ')||' |'||(
pa80(13).output||pa79(13).output||pa78(13).output||pa77(13).output||pa76(13).output||pa75(13).output||pa74(13).output||pa73(13).output||pa72(13).output||pa71(13).output||pa70(13).output||pa69(13).output||pa68(13).output||pa67(13).output||pa66(13).output||pa65(13).output||pa64(13).output||pa63(13).output||
pa62(13).output||pa61(13).output||pa60(13).output||pa59(13).output||pa58(13).output||pa57(13).output||pa56(13).output||pa55(13).output||pa54(13).output||pa53(13).output||pa52(13).output||pa51(13).output||pa50(13).output||pa49(13).output||pa48(13).output||pa47(13).output||pa46(13).output||pa45(13).output||
pa44(13).output||pa43(13).output||pa42(13).output||pa41(13).output||pa40(13).output||pa39(13).output||pa38(13).output||pa37(13).output||pa36(13).output||pa35(13).output||pa34(13).output||pa33(13).output||pa32(13).output||pa31(13).output||pa30(13).output||pa29(13).output||pa28(13).output||pa27(13).output||
PA26(13).OUTPUT||PA25(13).OUTPUT||PA24(13).OUTPUT||PA23(13).OUTPUT||PA22(13).OUTPUT||PA21(13).OUTPUT||PA20(13).OUTPUT||PA19(13).OUTPUT||PA18(13).OUTPUT||PA17(13).OUTPUT||PA16(13).OUTPUT|| PA15(13).OUTPUT||PA14(13).OUTPUT||PA13(13).OUTPUT||PA12(13).OUTPUT||PA11(13).OUTPUT||PA10(13).OUTPUT||PA9(13).OUTPUT||
pa8(13).output||pa7(13).output||pa6(13).output||pa5(13).output||pa4(13).output||pa3(13).output||pa2(13).output||pa1(13).output)||rpad(nvl(pa81(13).output||pa82(13).output||pa83(13).output||pa84(13).output,' '),4,' ')||'| '||rpad(pa_stet(13).output,6,' ')||'           ' );

fv_ta_obj(5)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(3).output,1,71),71,' ')||'        '||lpad(pa_stet(12).output,6,' ')||' |'||(
pa80(12).output||pa79(12).output||pa78(12).output||pa77(12).output||pa76(12).output||pa75(12).output||pa74(12).output||pa73(12).output||pa72(12).output||pa71(12).output||pa70(12).output||pa69(12).output||pa68(12).output||pa67(12).output||pa66(12).output||pa65(12).output||pa64(12).output||pa63(12).output||
pa62(12).output||pa61(12).output||pa60(12).output||pa59(12).output||pa58(12).output||pa57(12).output||pa56(12).output||pa55(12).output||pa54(12).output||pa53(12).output||pa52(12).output||pa51(12).output||pa50(12).output||pa49(12).output||pa48(12).output||pa47(12).output||pa46(12).output||pa45(12).output||
pa44(12).output||pa43(12).output||pa42(12).output||pa41(12).output||pa40(12).output||pa39(12).output||pa38(12).output||pa37(12).output||pa36(12).output||pa35(12).output||pa34(12).output||pa33(12).output||pa32(12).output||pa31(12).output||pa30(12).output||pa29(12).output||pa28(12).output||pa27(12).output||
PA26(12).OUTPUT||PA25(12).OUTPUT||PA24(12).OUTPUT||PA23(12).OUTPUT||PA22(12).OUTPUT||PA21(12).OUTPUT||PA20(12).OUTPUT||PA19(12).OUTPUT||PA18(12).OUTPUT||PA17(12).OUTPUT||PA16(12).OUTPUT||PA15(12).OUTPUT||PA14(12).OUTPUT||PA13(12).OUTPUT||PA12(12).OUTPUT||PA11(12).OUTPUT||PA10(12).OUTPUT||PA9(12).OUTPUT||
PA8(12).OUTPUT||PA7(12).OUTPUT||PA6(12).OUTPUT||PA5(12).OUTPUT||PA4(12).OUTPUT||PA3(12).OUTPUT||PA2(12).OUTPUT||PA1(12).OUTPUT)||RPAD(NVL(PA81(12).OUTPUT||PA82(12).OUTPUT||PA83(12).OUTPUT||PA84(12).OUTPUT,' '),4,' ')||'| '||RPAD(PA_STET(12).OUTPUT,6,' ')||'           ' );

fv_ta_obj(6)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(4).output,1,71),71,' ')||'        '||lpad(pa_stet(11).output,6,' ')||' |'||(
pa80(11).output||pa79(11).output||pa78(11).output||pa77(11).output||pa76(11).output||pa75(11).output||pa74(11).output||pa73(11).output||pa72(11).output||pa71(11).output||pa70(11).output||pa69(11).output||pa68(11).output||pa67(11).output||pa66(11).output||pa65(11).output||pa64(11).output||pa63(11).output||
pa62(11).output||pa61(11).output||pa60(11).output||pa59(11).output||pa58(11).output||pa57(11).output||pa56(11).output||pa55(11).output||pa54(11).output||pa53(11).output||pa52(11).output||pa51(11).output||pa50(11).output||pa49(11).output||pa48(11).output||pa47(11).output||pa46(11).output||pa45(11).output||
pa44(11).output||pa43(11).output||pa42(11).output||pa41(11).output||pa40(11).output||pa39(11).output||pa38(11).output||pa37(11).output||pa36(11).output||pa35(11).output||pa34(11).output||pa33(11).output||pa32(11).output||pa31(11).output||pa30(11).output||pa29(11).output||pa28(11).output||pa27(11).output||
PA26(11).OUTPUT||PA25(11).OUTPUT||PA24(11).OUTPUT||PA23(11).OUTPUT||PA22(11).OUTPUT||PA21(11).OUTPUT||PA20(11).OUTPUT||PA19(11).OUTPUT||PA18(11).OUTPUT||PA17(11).OUTPUT||PA16(11).OUTPUT||PA15(11).OUTPUT||PA14(11).OUTPUT||PA13(11).OUTPUT||PA12(11).OUTPUT||PA11(11).OUTPUT||PA10(11).OUTPUT||PA9(11).OUTPUT||
pa8(11).output||pa7(11).output||pa6(11).output||pa5(11).output||pa4(11).output||pa3(11).output||pa2(11).output||pa1(11).output)||rpad(nvl(pa81(11).output||pa82(11).output||pa83(11).output||pa84(11).output,' '),4,' ')||'| '||rpad(pa_stet(11).output,6,' ')||'           ' );

fv_ta_obj(7)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(5).output,1,71),71,' ')||'        '||lpad(pa_stet(10).output,6,' ')||' |'||(
pa80(10).output||pa79(10).output||pa78(10).output||pa77(10).output||pa76(10).output||pa75(10).output||pa74(10).output||pa73(10).output||pa72(10).output||pa71(10).output||pa70(10).output||pa69(10).output||pa68(10).output||pa67(10).output||pa66(10).output||pa65(10).output||pa64(10).output||pa63(10).output||
pa62(10).output||pa61(10).output||pa60(10).output||pa59(10).output||pa58(10).output||pa57(10).output||pa56(10).output||pa55(10).output||pa54(10).output||pa53(10).output||pa52(10).output||pa51(10).output||pa50(10).output||pa49(10).output||pa48(10).output||pa47(10).output||pa46(10).output||pa45(10).output||
pa44(10).output||pa43(10).output||pa42(10).output||pa41(10).output||pa40(10).output||pa39(10).output||pa38(10).output||pa37(10).output||pa36(10).output||pa35(10).output||pa34(10).output||pa33(10).output||pa32(10).output||pa31(10).output||pa30(10).output||pa29(10).output||pa28(10).output||pa27(10).output||
pa26(10).output||pa25(10).output||pa24(10).output||pa23(10).output||pa22(10).output||pa21(10).output||pa20(10).output||pa19(10).output||pa18(10).output||pa17(10).output||pa16(10).output||pa15(10).output||pa14(10).output||pa13(10).output||pa12(10).output||pa11(10).output||pa10(10).output||pa9(10).output||
pa8(10).output||pa7(10).output||pa6(10).output||pa5(10).output||pa4(10).output||pa3(10).output||pa2(10).output||pa1(10).output)||rpad(nvl(pa81(10).output||pa82(10).output||pa83(10).output||pa84(10).output,' '),4,' ')||'| '||rpad(pa_stet(10).output,6,' ')||'           ' );

fv_ta_obj(8)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(6).output,1,77),77,' ')||'  '||lpad(pa_stet(9).output,6,' ')||' |'||(
pa80(9).output||pa79(9).output||pa78(9).output||pa77(9).output||pa76(9).output||pa75(9).output||pa74(9).output||pa73(9).output||pa72(9).output||pa71(9).output||pa70(9).output||pa69(9).output||pa68(9).output||pa67(9).output||pa66(9).output||pa65(9).output||pa64(9).output||pa63(9).output||pa62(9).output||
pa61(9).output||pa60(9).output||pa59(9).output||pa58(9).output||pa57(9).output||pa56(9).output||pa55(9).output||pa54(9).output||pa53(9).output||pa52(9).output||pa51(9).output||pa50(9).output||pa49(9).output||pa48(9).output||pa47(9).output||pa46(9).output||pa45(9).output||pa44(9).output||pa43(9).output||
pa42(9).output||pa41(9).output||pa40(9).output||pa39(9).output||pa38(9).output||pa37(9).output||pa36(9).output||pa35(9).output||pa34(9).output||pa33(9).output||pa32(9).output||pa31(9).output||pa30(9).output||pa29(9).output||pa28(9).output||pa27(9).output||pa26(9).output||pa25(9).output||pa24(9).output||
PA23(9).OUTPUT||PA22(9).OUTPUT||PA21(9).OUTPUT||PA20(9).OUTPUT||PA19(9).OUTPUT||PA18(9).OUTPUT||PA17(9).OUTPUT||PA16(9).OUTPUT|| PA15(9).OUTPUT||PA14(9).OUTPUT||PA13(9).OUTPUT||PA12(9).OUTPUT||PA11(9).OUTPUT||PA10(9).OUTPUT||PA9(9).OUTPUT||PA8(9).OUTPUT||PA7(9).OUTPUT||PA6(9).OUTPUT||PA5(9).OUTPUT||
PA4(9).OUTPUT||PA3(9).OUTPUT||PA2(9).OUTPUT||PA1(9).OUTPUT)||RPAD(NVL(PA81(9).OUTPUT||PA82(9).OUTPUT||PA83(9).OUTPUT||PA84(9).OUTPUT,' '),4,' ')||'| '||RPAD(PA_STET(9).OUTPUT,6,' ')||'           ' );

fv_ta_obj(9)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(7).output,1,77),77,' ')||'  '||lpad(pa_stet(8).output,6,' ') ||' |'||(
pa80(8).output||pa79(8).output||pa78(8).output||pa77(8).output||pa76(8).output||pa75(8).output||pa74(8).output||pa73(8).output||pa72(8).output||pa71(8).output||pa70(8).output||pa69(8).output||pa68(8).output||pa67(8).output||pa66(8).output||pa65(8).output||pa64(8).output||pa63(8).output||pa62(8).output||
pa61(8).output||pa60(8).output||pa59(8).output||pa58(8).output||pa57(8).output||pa56(8).output||pa55(8).output||pa54(8).output||pa53(8).output||pa52(8).output||pa51(8).output||pa50(8).output||pa49(8).output||pa48(8).output||pa47(8).output||pa46(8).output||pa45(8).output||pa44(8).output||pa43(8).output||
pa42(8).output||pa41(8).output||pa40(8).output||pa39(8).output||pa38(8).output||pa37(8).output||pa36(8).output||pa35(8).output||pa34(8).output||pa33(8).output||pa32(8).output||pa31(8).output||pa30(8).output||pa29(8).output||pa28(8).output||pa27(8).output||pa26(8).output||pa25(8).output||pa24(8).output||
PA23(8).OUTPUT||PA22(8).OUTPUT||PA21(8).OUTPUT||PA20(8).OUTPUT||PA19(8).OUTPUT||PA18(8).OUTPUT||PA17(8).OUTPUT||PA16(8).OUTPUT||PA15(8).OUTPUT||PA14(8).OUTPUT||PA13(8).OUTPUT||PA12(8).OUTPUT||PA11(8).OUTPUT||PA10(8).OUTPUT||PA9(8).OUTPUT||PA8(8).OUTPUT||PA7(8).OUTPUT||PA6(8).OUTPUT||PA5(8).OUTPUT||
PA4(8).OUTPUT||PA3(8).OUTPUT||PA2(8).OUTPUT||PA1(8).OUTPUT)||RPAD(NVL(PA81(8).OUTPUT||PA82(8).OUTPUT||PA83(8).OUTPUT||PA84(8).OUTPUT,' '),4,' ')||'| '||RPAD(PA_STET(8).OUTPUT,6,' ')||'           ' );

fv_ta_obj(10)  :=ty_obj(rpad(substr(pv_tmp_gcinfo(8).output,1,77),77,' ')||'  '||lpad(pa_stet(7).output,6,' ') ||' |'||(
pa80(7).output||pa79(7).output||pa78(7).output||pa77(7).output||pa76(7).output||pa75(7).output||pa74(7).output||pa73(7).output||pa72(7).output||pa71(7).output||pa70(7).output||pa69(7).output||pa68(7).output||pa67(7).output||pa66(7).output||pa65(7).output||pa64(7).output||pa63(7).output||pa62(7).output||
pa61(7).output||pa60(7).output||pa59(7).output||pa58(7).output||pa57(7).output||pa56(7).output||pa55(7).output||pa54(7).output||pa53(7).output||pa52(7).output||pa51(7).output||pa50(7).output||pa49(7).output||pa48(7).output||pa47(7).output||pa46(7).output||pa45(7).output||pa44(7).output||pa43(7).output||
pa42(7).output||pa41(7).output||pa40(7).output||pa39(7).output||pa38(7).output||pa37(7).output||pa36(7).output||pa35(7).output||pa34(7).output||pa33(7).output||pa32(7).output||pa31(7).output||pa30(7).output||pa29(7).output||pa28(7).output||pa27(7).output||pa26(7).output||pa25(7).output||pa24(7).output||
pa23(7).output||pa22(7).output||pa21(7).output||pa20(7).output||pa19(7).output||pa18(7).output||pa17(7).output||pa16(7).output||pa15(7).output||pa14(7).output||pa13(7).output||pa12(7).output||pa11(7).output||pa10(7).output||pa9(7).output||pa8(7).output||pa7(7).output||pa6(7).output||pa5(7).output||
pa4(7).output||pa3(7).output||pa2(7).output||pa1(7).output)||rpad(nvl(pa81(7).output||pa82(7).output||pa83(7).output||pa84(7).output,' '),4,' ')||'| '||rpad(pa_stet(7).output,6,' ')||'           ' );

fv_ta_obj(11) :=ty_obj(rpad(substr(pv_tmp_gcinfo(9).output,1,77),77,' ')||'  '||lpad(pa_stet(6).output,6,' ') ||' |'||(
pa80(6).output||pa79(6).output||pa78(6).output||pa77(6).output||pa76(6).output||pa75(6).output||pa74(6).output||pa73(6).output||pa72(6).output||pa71(6).output||pa70(6).output||pa69(6).output||pa68(6).output||pa67(6).output||pa66(6).output||pa65(6).output||pa64(6).output||pa63(6).output||pa62(6).output||
pa61(6).output||pa60(6).output||pa59(6).output||pa58(6).output||pa57(6).output||pa56(6).output||pa55(6).output||pa54(6).output||pa53(6).output||pa52(6).output||pa51(6).output||pa50(6).output||pa49(6).output||pa48(6).output||pa47(6).output||pa46(6).output||pa45(6).output||pa44(6).output||pa43(6).output||
pa42(6).output||pa41(6).output||pa40(6).output||pa39(6).output||pa38(6).output||pa37(6).output||pa36(6).output||pa35(6).output||pa34(6).output||pa33(6).output||pa32(6).output||pa31(6).output||pa30(6).output||pa29(6).output||pa28(6).output||pa27(6).output||pa26(6).output||pa25(6).output||pa24(6).output||
pa23(6).output||pa22(6).output||pa21(6).output||pa20(6).output||pa19(6).output||pa18(6).output||pa17(6).output||pa16(6).output||pa15(6).output||pa14(6).output||pa13(6).output||pa12(6).output||pa11(6).output||pa10(6).output||pa9(6).output||pa8(6).output||pa7(6).output||pa6(6).output||pa5(6).output||
pa4(6).output||pa3(6).output||pa2(6).output||pa1(6).output)||rpad(nvl(pa81(6).output||pa82(6).output||pa83(6).output||pa84(6).output,' '),4,' ')||'| '||rpad(pa_stet(6).output,6,' ')||'           ' );

fv_ta_obj(12) :=ty_obj(rpad(substr(pv_tmp_gcinfo(10).output,1,77),77,' ')||'  '||lpad(pa_stet(5).output,6,' ') ||' |'||(
pa80(5).output||pa79(5).output||pa78(5).output||pa77(5).output||pa76(5).output||pa75(5).output||pa74(5).output||pa73(5).output||pa72(5).output||pa71(5).output||pa70(5).output||pa69(5).output||pa68(5).output||pa67(5).output||pa66(5).output||pa65(5).output||pa64(5).output||pa63(5).output||pa62(5).output||
pa61(5).output||pa60(5).output||pa59(5).output||pa58(5).output||pa57(5).output||pa56(5).output||pa55(5).output||pa54(5).output||pa53(5).output||pa52(5).output||pa51(5).output||pa50(5).output||pa49(5).output||pa48(5).output||pa47(5).output||pa46(5).output||pa45(5).output||pa44(5).output||pa43(5).output||
pa42(5).output||pa41(5).output||pa40(5).output||pa39(5).output||pa38(5).output||pa37(5).output||pa36(5).output||pa35(5).output||pa34(5).output||pa33(5).output||pa32(5).output||pa31(5).output||pa30(5).output||pa29(5).output||pa28(5).output||pa27(5).output||pa26(5).output||pa25(5).output||pa24(5).output||
pa23(5).output||pa22(5).output||pa21(5).output||pa20(5).output||pa19(5).output||pa18(5).output||pa17(5).output||pa16(5).output||pa15(5).output||pa14(5).output||pa13(5).output||pa12(5).output||pa11(5).output||pa10(5).output||pa9(5).output||pa8(5).output||pa7(5).output||pa6(5).output||pa5(5).output||
pa4(5).output||pa3(5).output||pa2(5).output||pa1(5).output)||rpad(nvl(pa81(5).output||pa82(5).output||pa83(5).output||pa84(5).output,' '),4,' ')||'| '||rpad(pa_stet(5).output,6,' ')||'           ' );

fv_ta_obj(13) :=ty_obj(rpad(substr(pv_tmp_gcinfo(11).output,1,77),77,' ')||'  '||lpad(pa_stet(4).output,6,' ') ||' |'||(
pa80(4).output||pa79(4).output||pa78(4).output||pa77(4).output||pa76(4).output||pa75(4).output||pa74(4).output||pa73(4).output||pa72(4).output||pa71(4).output||pa70(4).output||pa69(4).output||pa68(4).output||pa67(4).output||pa66(4).output||pa65(4).output||pa64(4).output||pa63(4).output||pa62(4).output||
pa61(4).output||pa60(4).output||pa59(4).output||pa58(4).output||pa57(4).output||pa56(4).output||pa55(4).output||pa54(4).output||pa53(4).output||pa52(4).output||pa51(4).output||pa50(4).output||pa49(4).output||pa48(4).output||pa47(4).output||pa46(4).output||pa45(4).output||pa44(4).output||pa43(4).output||
pa42(4).output||pa41(4).output||pa40(4).output||pa39(4).output||pa38(4).output||pa37(4).output||pa36(4).output||pa35(4).output||pa34(4).output||pa33(4).output||pa32(4).output||pa31(4).output||pa30(4).output||pa29(4).output||pa28(4).output||pa27(4).output||pa26(4).output||pa25(4).output||pa24(4).output||
PA23(4).OUTPUT||PA22(4).OUTPUT||PA21(4).OUTPUT||PA20(4).OUTPUT||PA19(4).OUTPUT||PA18(4).OUTPUT||PA17(4).OUTPUT||PA16(4).OUTPUT||PA15(4).OUTPUT||PA14(4).OUTPUT||PA13(4).OUTPUT||PA12(4).OUTPUT||PA11(4).OUTPUT||PA10(4).OUTPUT||PA9(4).OUTPUT||PA8(4).OUTPUT||PA7(4).OUTPUT||PA6(4).OUTPUT||PA5(4).OUTPUT||
pa4(4).output||pa3(4).output||pa2(4).output||pa1(4).output)||rpad(nvl(pa81(4).output||pa82(4).output||pa83(4).output||pa84(4).output,' '),4,' ')||'| '||rpad(pa_stet(4).output,6,' ')||'           ' );

fv_ta_obj(14) :=ty_obj(rpad(substr(pv_tmp_gcinfo(12).output,1,55),55,' ')||' ALL OTHER EVENTS : '||pv_oth_dig ||'   '||lpad(pa_stet(3).output,6,' ') ||' |'||(
pa80(3).output||pa79(3).output||pa78(3).output||pa77(3).output||pa76(3).output||pa75(3).output||pa74(3).output||pa73(3).output||pa72(3).output||pa71(3).output||pa70(3).output||pa69(3).output||pa68(3).output||pa67(3).output||pa66(3).output||pa65(3).output||pa64(3).output||pa63(3).output||pa62(3).output||
pa61(3).output||pa60(3).output||pa59(3).output||pa58(3).output||pa57(3).output||pa56(3).output||pa55(3).output||pa54(3).output||pa53(3).output||pa52(3).output||pa51(3).output||pa50(3).output||pa49(3).output||pa48(3).output||pa47(3).output||pa46(3).output||pa45(3).output||pa44(3).output||pa43(3).output||
pa42(3).output||pa41(3).output||pa40(3).output||pa39(3).output||pa38(3).output||pa37(3).output||pa36(3).output||pa35(3).output||pa34(3).output||pa33(3).output||pa32(3).output||pa31(3).output||pa30(3).output||pa29(3).output||pa28(3).output||pa27(3).output||pa26(3).output||pa25(3).output||pa24(3).output||
PA23(3).OUTPUT||PA22(3).OUTPUT||PA21(3).OUTPUT||PA20(3).OUTPUT||PA19(3).OUTPUT||PA18(3).OUTPUT||PA17(3).OUTPUT||PA16(3).OUTPUT||PA15(3).OUTPUT||PA14(3).OUTPUT||PA13(3).OUTPUT||PA12(3).OUTPUT||PA11(3).OUTPUT||PA10(3).OUTPUT||PA9(3).OUTPUT||PA8(3).OUTPUT||PA7(3).OUTPUT||PA6(3).OUTPUT||PA5(3).OUTPUT||
pa4(3).output||pa3(3).output||pa2(3).output||pa1(3).output)||rpad(nvl(pa81(3).output||pa82(3).output||pa83(3).output||pa84(3).output,' '),4,' ')||'| '||rpad(pa_stet(3).output,6,' ')||'           ');

fv_ta_obj(15) :=ty_obj(rpad(substr(pv_tmp_gcinfo(13).output,1,55),55,' ')||'          CLUSTER : '||pv_clu_dig ||'   '||lpad(pa_stet(2).output,6,' ') ||' |'||(
pa80(2).output||pa79(2).output||pa78(2).output||pa77(2).output||pa76(2).output||pa75(2).output||pa74(2).output||pa73(2).output||pa72(2).output||pa71(2).output||pa70(2).output||pa69(2).output||pa68(2).output||pa67(2).output||pa66(2).output||pa65(2).output||pa64(2).output||pa63(2).output||pa62(2).output||
PA61(2).OUTPUT||PA60(2).OUTPUT||PA59(2).OUTPUT||PA58(2).OUTPUT||PA57(2).OUTPUT||PA56(2).OUTPUT||PA55(2).OUTPUT||PA54(2).OUTPUT||PA53(2).OUTPUT||PA52(2).OUTPUT||PA51(2).OUTPUT||PA50(2).OUTPUT||PA49(2).OUTPUT||PA48(2).OUTPUT||PA47(2).OUTPUT||PA46(2).OUTPUT||PA45(2).OUTPUT||PA44(2).OUTPUT||PA43(2).OUTPUT||
pa42(2).output||pa41(2).output||pa40(2).output||pa39(2).output||pa38(2).output||pa37(2).output||pa36(2).output||pa35(2).output||pa34(2).output||pa33(2).output||pa32(2).output||pa31(2).output||pa30(2).output||pa29(2).output||pa28(2).output||pa27(2).output||pa26(2).output||pa25(2).output||pa24(2).output||
PA23(2).OUTPUT||PA22(2).OUTPUT||PA21(2).OUTPUT||PA20(2).OUTPUT||PA19(2).OUTPUT||PA18(2).OUTPUT||PA17(2).OUTPUT||PA16(2).OUTPUT||PA15(2).OUTPUT||PA14(2).OUTPUT||PA13(2).OUTPUT||PA12(2).OUTPUT||PA11(2).OUTPUT||PA10(2).OUTPUT||PA9(2).OUTPUT||PA8(2).OUTPUT||PA7(2).OUTPUT||PA6(2).OUTPUT||PA5(2).OUTPUT||
pa4(2).output||pa3(2).output||pa2(2).output||pa1(2).output)||rpad(nvl(pa81(2).output||pa82(2).output||pa83(2).output||pa84(2).output,' '),4,' ')||'| '||rpad(pa_stet(2).output,6,' ')||'           ' );

fv_ta_obj(16) :=ty_obj(rpad(substr(pv_tmp_gcinfo(14).output,1,55),55,' ')||'               IO : '||pv_io_dig||'   '||lpad(pa_stet(1).output,6,' ') ||' |'||(
pa80(1).output||pa79(1).output||pa78(1).output||pa77(1).output||pa76(1).output||pa75(1).output||pa74(1).output||pa73(1).output||pa72(1).output||pa71(1).output||pa70(1).output||pa69(1).output||pa68(1).output||pa67(1).output||pa66(1).output||pa65(1).output||pa64(1).output||pa63(1).output||pa62(1).output||
pa61(1).output||pa60(1).output||pa59(1).output||pa58(1).output||pa57(1).output||pa56(1).output||pa55(1).output||pa54(1).output||pa53(1).output||pa52(1).output||pa51(1).output||pa50(1).output||pa49(1).output||pa48(1).output||pa47(1).output||pa46(1).output||pa45(1).output||pa44(1).output||pa43(1).output||
pa42(1).output||pa41(1).output||pa40(1).output||pa39(1).output||pa38(1).output||pa37(1).output||pa36(1).output||pa35(1).output||pa34(1).output||pa33(1).output||pa32(1).output||pa31(1).output||pa30(1).output||pa29(1).output||pa28(1).output||pa27(1).output||pa26(1).output||pa25(1).output||pa24(1).output||
PA23(1).OUTPUT||PA22(1).OUTPUT||PA21(1).OUTPUT||PA20(1).OUTPUT||PA19(1).OUTPUT||PA18(1).OUTPUT||PA17(1).OUTPUT||PA16(1).OUTPUT||PA15(1).OUTPUT||PA14(1).OUTPUT||PA13(1).OUTPUT||PA12(1).OUTPUT||PA11(1).OUTPUT||PA10(1).OUTPUT||PA9(1).OUTPUT||PA8(1).OUTPUT||PA7(1).OUTPUT||PA6(1).OUTPUT||PA5(1).OUTPUT||
PA4(1).OUTPUT||PA3(1).OUTPUT||PA2(1).OUTPUT||PA1(1).OUTPUT)||RPAD(NVL(PA81(1).OUTPUT||PA82(1).OUTPUT||PA83(1).OUTPUT||PA84(1).OUTPUT,' '),4,' ')||'| '||RPAD(PA_STET(1).OUTPUT,6,' ')||'           ' );

FV_TA_OBJ(17) :=TY_OBJ(RPAD(' ',69,' ')||'CPU : '||PV_CPU_DIG ||'   '||LPAD(0,6,' ')||' +'||RPAD('-',84,'-')||'+ 0');
FV_TA_OBJ(18) :=TY_OBJ(RPAD(PV_SYSMETRIC_STRING1,88,' ')||'^'||' '||TO_CHAR(SYSDATE-(1/24/60/(60/(P_SAMPLE*80))),'hh24:mi:ss')||LPAD(' ',21,' ')||TO_CHAR(SYSDATE-(1/24/60/(60/(P_SAMPLE*40))),'hh24:mi:ss')||' '||'^'||LPAD(' ',29,' ')||TO_CHAR(SYSDATE,'hh24:mi:ss')||' '||'^');
FV_TA_OBJ(19) :=TY_OBJ(RPAD(PV_SYSMETRIC_STRING2,170,' '));
FV_TA_OBJ(20) :=TY_OBJ(RPAD(PV_SYSMETRIC_STRING3,170,' '));

return fv_ta_obj;
exception
when others then
RAISE_APPLICATION_ERROR(-20001,'GACTSESSRET : '||SQLERRM );
end;
-------------------
------##################
-- gsqlm : ---  building dataset from gv\$sql_monitor for all running queries.
--- print info for pv_top_sql
------##################
function gsqlm  return ta_obj
as
fv_Ta_obj     ta_obj  := ta_obj();
v_rcnt        int := 0 ;
fv_sql        varchar2(500) := q'[ select ty_gsqlm(inst_id,sql_id,substr(sql_text,1,100),elapsed_time,cpu_time,concurrency_wait_time, cluster_wait_Time,user_io_wait_time,physical_read_bytes,px_server#) from gv\$sql_monitor where status = 'EXECUTING' and elapsed_time > 0 ]';
----##
function  f_convert_datetime(fvs number ) return varchar2
as
v_result    varchar2(20) ;
begin
with
   hrs as (select secs, trunc(secs/60/60) as h from (select fvs secs from dual))
 , mins as (select secs, h, trunc((secs - h * 60 * 60) / 60) as m from hrs)
select lpad(h,2,'0') || ':' || lpad(m,2,'0') || ':' || lpad((secs - (h * 60 * 60) - (m * 60) ),2,'0') into v_result
  from  mins;
  v_result := replace(v_result,'::') ;
return v_result;
end;
---##
begin
execute immediate fv_sql bulk collect into pv_only_gsqlm;
fv_ta_obj.extend;fv_ta_obj(fv_ta_obj.count) := ty_obj( ' ');
fv_ta_obj.extend;fv_ta_obj(fv_ta_obj.count) := ty_obj( '+--SqlID--------+--SqlText---' || lpad('-',73,'-') || '+-LongstDur-+-InstCnt-+-Cnt-+--CPU%--+--CONC%--+--CLUS%--+-IO%-+-PhyReadMb+');
for i in (select (select round(max(elapsed_time)/1000000) from table(pv_only_gsqlm) gsq1 where gsq1.sql_id = gsm.sql_id) maxduration,
                 (select count(distinct inst_id) from table(pv_only_gash)  sq1 where sq1.sql_id = gsm.sql_id) acrossins, sql_id,
                 (select SUBSTR(SQL_TEXT,1,87) FROM TABLE(PV_ONLY_GASH) SQ2 WHERE SQ2.SQL_ID = GSM.SQL_ID AND ROWNUM = 1) SQL_TEXT,
                 (select lpad(nvl(round(sum(cpu_time)/ nvl(sum(elapsed_time),1) *100,1),0),6,' ') || ' | ' || lpad(nvl(round(sum(concurrency_Wait_Time)/nvl(sum(elapsed_time),1)*100,1),0),6,' ') || ' | ' || lpad(nvl(round(sum(cluster_Wait_Time)/nvl(sum(elapsed_time),1)*100,1),0),6,' ') || ' | ' || lpad(nvl(round(sum(user_io_wait_time)/nvl(sum(elapsed_time),1)*100,1),0),4,'  ') || ' | ' || lpad(nvl(round(sum(physical_read_bytes)/1048576),0),10,'  ') || ' | ' from table(pv_only_gsqlm) sql3 where sql3.sql_id = gsm.sql_id) DBA_time,
                 (select count( distinct inst_id || sid) from table(pv_only_gash) sq4 where sq4.sql_id = gsm.sql_id ) exccount from (select distinct output sql_id from table(pv_top_sql)) gsm)
          loop
 v_rcnt := 1;
 fv_ta_obj.extend;
fv_ta_obj(fv_ta_obj.count) := ty_obj('| ' || i.sql_id || ' | ' || rpad(nvl(i.sql_text,' '),83,' ') || ' | ' || lpad(nvl(f_convert_datetime(i.maxduration),' '),9,' ') || ' |    ' || rpad(i.acrossins,4,'  ') || '  |  ' || lpad(i.exccount,2,'  ') || ' | ' || i.DBA_time );
fv_ta_obj.extend;fv_ta_obj(fv_ta_obj.count) := ty_obj('+---------------+' || lpad('-',85,'-') || '+-----------+---------+-----+--------+---------+---------+-----+----------+');
        end loop;
           if v_rcnt = 0 then
            fv_ta_obj.extend;
			fv_ta_obj(fv_ta_obj.count) := ty_obj( '+---------------+' || lpad('-',85,'-') || '+-----------+---------+-----+--------+---------+---------+-----+----------+');
           end if;
return  fv_ta_obj;
exception
when others then
raise_application_Error(-20001,'GSQLM : ' || sqlerrm);
end;
-------------------/
------##################
-- gtop : pipe lined function, which calls all the sections
------##################
FUNCTION gtop(PV_ARR_SIZE     INT DEFAULT 50 ,
              PV_SAMPLE       INT DEFAULT 6,
              PV_COLORS       INT DEFAULT 1,
              PV_SYSMETRC_ID1 INT DEFAULT NULL,
              PV_SYSMETRC_ID2 INT DEFAULT NULL,
              PV_SYSMETRC_ID3 INT DEFAULT NULL
              ) RETURN ta_obj pipelined
is
v_tot_rec       int := 0 ;
BEGIN
p_sample  := pv_Sample;
---############################
--If Non-Colored Graph Required
---############################
IF PV_COLORS = 0 THEN     -- No color
PV_CPU_DIG     :=  '#';
pv_io_dig      :=  'O';
PV_CLU_DIG     :=  '+';
PV_OTH_DIG     :=  '*';
ELSIF PV_COLORS = 2 THEN
PV_CPU_DIG     :=  CHR(27)||'[32m'||'#'||CHR(27)||'[0m';  -- Colored Digit
PV_IO_DIG      :=  CHR(27)||'[34m'||'O'||CHR(27)||'[0m';
PV_CLU_DIG     :=  CHR(27)||'[33m'||'+'||CHR(27)||'[0m';
PV_OTH_DIG     :=  CHR(27)||'[31m'||'*'||CHR(27)||'[0m';
ELSIF PV_COLORS = 1 THEN                                  -- Background Colored
PV_CPU_DIG     :=  CHR(27)||'[42m'||' '||CHR(27)||'[0m';
PV_IO_DIG      :=  CHR(27)||'[44m'||' '||CHR(27)||'[0m';
PV_CLU_DIG     :=  CHR(27)||'[47m'||' '||CHR(27)||'[0m';
PV_OTH_DIG     :=  CHR(27)||'[41m'||' '||CHR(27)||'[0m';
END IF;
      --- Printing Banner..
        begin
        pipe row ( ty_obj('########################################')); v_tot_rec := v_tot_Rec + 1;
        PIPE ROW ( TY_OBJ('Taking first sample .......             ')); V_TOT_REC := V_TOT_REC + 1;
        PIPE ROW ( TY_OBJ('Author  : Ribas                         ')); V_TOT_REC := V_TOT_REC + 1;
        PIPE ROW ( TY_OBJ('Version : V2.1                          ')); V_TOT_REC := V_TOT_REC + 1;
        PIPE ROW ( TY_OBJ('########################################')); V_TOT_REC := V_TOT_REC + 1;
                pipe row ( ty_obj('')); V_TOT_REC := V_TOT_REC + 1;
                PIPE ROW ( TY_OBJ('')); V_TOT_REC := V_TOT_REC + 1;
                PIPE ROW ( TY_OBJ('Please use below sql to see help !!')); V_TOT_REC := V_TOT_REC + 1;
                PIPE ROW ( TY_OBJ('-- select * from table(jss.help()); ')); V_TOT_REC := V_TOT_REC + 1;
                PIPE ROW ( TY_OBJ('')); V_TOT_REC := V_TOT_REC + 1;
                PIPE ROW ( TY_OBJ('')); V_TOT_REC := V_TOT_REC + 1;
           IF V_TOT_REC <= PV_ARR_SIZE THEN
                     for i in 1..(pv_arr_size-v_tot_rec) loop
                     pipe row ( ty_obj(' ')); v_tot_rec := v_tot_Rec + 1;
                    end loop;
           end if;
        initactarr;                 -- calling initactarr to extend all the arrays
        pv_first_ginst := ginsteff; -- getting first sample for ginsteff
        dbms_lock.sleep(pv_sample); -- sleep based on passed parameter, default is 6 seconds
        v_tot_rec := 0;
        end;
loop
--#######################
-- Printing Instance Eff.
--#######################
------------------ -- Building output for Inst Eff.
pv_last_ginst :=  ginsteff;  -- Taking second sample for Inst Eff. data
pv_tmp_obj    :=  ginstbuilddata(pv_first_ginst,pv_last_ginst);  -- getting data formatted
for i in 1..pv_tmp_obj.count loop   pipe row( ty_obj( pv_tmp_obj(i).output )); v_tot_rec := v_tot_rec + 1; end loop;  pipe row ( ty_obj(' ')); v_tot_rec := v_tot_rec + 1; -- printing
pv_tmp_obj.delete;  -- deleting temp obj
------------------
--#########################
-- Printing TOP SQLs,Waits
--#########################
------------------
pv_only_gash  := gash(pv_st_sample,pv_et_sample); -- building dataset from global active session history
pv_tmp_obj    := gashbuilddata (pv_only_gash); -- getting dataset formatted
for i in 1..pv_tmp_obj.count loop   pipe row( ty_obj( pv_tmp_obj(i).output )); v_tot_rec := v_tot_rec + 1; end loop;  -- printing
pv_tmp_obj.delete;  -- deleting temp obj
------------------
--#########################
-- Building Cluster/GC* data
--#########################
pv_tmp_gcinfo :=  gcinfo ; -- building dataset for Cluster waits,
--#########################
-- Printing Active Sessions
--#########################
-----------------
gset3sysmetrics(PV_SYSMETRC_ID1,PV_SYSMETRC_ID2,PV_SYSMETRC_ID3); -- Customizable Section/Sysmetric Id
gactses ;
PV_TMP_OBJ := GACTSESSRET;
FOR I IN 1..PV_TMP_OBJ.COUNT LOOP   PIPE ROW( TY_OBJ( PV_TMP_OBJ(I).OUTPUT )); V_TOT_REC := V_TOT_REC + 1; END LOOP;
--pipe row ( ty_obj(' ')); v_tot_rec := v_tot_rec + 1;
pv_tmp_obj.delete;
--------------------
--#########################
-- Printing SQL Monitor
--#########################
------------------
pv_tmp_obj := gsqlm;    -- using pv_top_sql to fill detail from sql monitor
for i in 1..pv_tmp_obj.count loop   pipe row( ty_obj( pv_tmp_obj(i).output )); v_tot_rec := v_tot_rec + 1; end loop;
pv_tmp_obj.delete;
-------------------
--#######################
-- Fill remaining Array
--#######################
        if v_tot_rec < pv_arr_size then
            for i in 1..(pv_arr_size-v_tot_rec) loop
             pipe row ( ty_obj(' '));
            end loop;
        end if;
--##############################
-- Sleep, triming all the arrays
--
--##############################
pv_first_ginst := pv_last_ginst;   -- shuffling ginst collection
dbms_lock.sleep(pv_sample);
v_tot_rec := 0;
end loop ;
RETURN ;
--exception
--when others then
--raise_application_Error(-20001,'GTOP: '||sqlerrm );
end;
---
--#############################
-- Below Section Talks About GTOP Help
FUNCTION GTOPHELP RETURN TA_OBJ PIPELINED
as
begin
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  Arguments Name In GTOP Function    '));
pipe row ( ty_obj('  ---------------   '));
pipe row ( ty_obj('  PV_ARR_SIZE       : Pass SQL Array Size (Set Sqlarray Size <Value>) '));
pipe row ( ty_obj('  PV_SAMPLE         : Time Interval In Seconds For Sample, Default=6 Seconds, Screen Refresh Time '));
pipe row ( ty_obj('  PV_COLORS         : 0=No Colors, 1=BG Colors(Default), 2=Colored Digits '));
pipe row ( ty_obj('  PV_SYSMETRC_ID1   : Pass Metric_ID column from v\$sysmetric to monitor, Default=2144 (Single Blk Read Latency) '));
pipe row ( ty_obj('  PV_SYSMETRC_ID2   : Pass Metric_ID column from v\$sysmetric to monitor, Default=2088 (Physical Read Direct)  '));
pipe row ( ty_obj('  PV_SYSMETRC_ID3   : Pass Metric_ID column from v\$sysmetric to monitor, Default=2010 (Physical Write Direct) '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj(' ## With All Defaults Values -- Sample=6 Secs , Colors=Background Color, Default 3 Sysmetrics  '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
pipe row ( ty_obj('  SET LINESIZE 5000 pagesize 0 Arraysize 50 TAB OFF '));
pipe row ( ty_obj('  select * FROM TABLE(JSS.GTOP(50)); '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj(' ## With Changed Sample Size -- Interval=3 Sec, Remaining All Defaults '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
pipe row ( ty_obj('  SET LINESIZE 5000 pagesize 0 Arraysize 50 TAB OFF '));
pipe row ( ty_obj('  select * FROM TABLE(JSS.GTOP(50,3)); '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj(' ## With Changed Sample Size and No Colors -- Interval=3 Secs, Colors=No Color, Remaining All Defaults '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
pipe row ( ty_obj('  SET LINESIZE 5000 pagesize 0 Arraysize 50 TAB OFF '));
pipe row ( ty_obj('  select * FROM TABLE(JSS.GTOP(50,3,0)); '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj('  '));
pipe row ( ty_obj(' ## With Customized Sysmetrics- 2003=User Transactions Per Sec, 2018=Logins Per Sec, 2026=>User Calls Per Sec '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
pipe row ( ty_obj('  SET LINESIZE 5000 pagesize 0 Arraysize 50 TAB OFF '));
pipe row ( ty_obj('  select * FROM TABLE(JSS.GTOP(50,pv_sysmetrc_id1=>2003,pv_sysmetrc_id2=>2018,pv_sysmetrc_id3=>2026)); '));
pipe row ( ty_obj(' ~~~~~~~~~ '));
end;
--#############################
--########################
-- Package Begin Section
--########################
Begin
dbms_application_info.set_action('JSS.GTOP');
select VALUE  INTO PV_BLOCK_SIZE FROM V\$PARAMETER WHERE NAME = 'DBA_block_size' ;   -- this query will get executed once per session
select SUBSTR(VALUE,1,INSTR(VALUE,'.')-1) INTO PV_VERSION FROM V\$PARAMETER WHERE NAME = 'compatible' ;
END JSS;
/
quit;
EOF
else
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
alter session set current_schema=system;
SET LINESIZE 5000 pagesize 0 Arraysize 51 TAB OFF
prompt ##############################################################
prompt # ACCESSING THE DATABASE DASHBOARD
prompt ##############################################################
select * from table(jss.gtop(51));
/
quit;
EOF
fi
}
#
#########################################################################################################
# VERIFY ALL SQL IDS STATEMENTS
#########################################################################################################
#
function DBA_091() {
sqlplus -S / as sysdba <<EOF
set pages 50000 lines 32767 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # Session related Queries                                    #
prompt ##############################################################
prompt # Last/Latest Running SQL                                    #
prompt ##############################################################
col username for a20
col "Last SQL" for a130
select t.inst_id
  , s.username
  , s.sid
  , s.serial#
  , t.sql_id
  , t.sql_text "Last SQL"
FROM gv\$session s, gv\$sqlarea t
WHERE s.sql_address = t.address
AND s.sql_hash_value = t.hash_value;
quit;
EOF
}
#
#########################################################################################################
# VERIFY NLS CONFIGURATION
#########################################################################################################
#
function DBA_092() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # VERIFY NLS CONFIGURATION                                   #
prompt ##############################################################
COL PARAMETER FOR A30
COL DATABASE FOR A30
COL INSTANCE FOR A30
COL SESSION FOR A30
SELECT DB.PARAMETER
  , DB.VALUE "DATABASE"
  , I.VALUE "INSTANCE"
  , S.VALUE "SESSION"
FROM NLS_DATABASE_PARAMETERS DB, NLS_INSTANCE_PARAMETERS I, NLS_SESSION_PARAMETERS S
WHERE DB.PARAMETER=I.PARAMETER(+) AND DB.PARAMETER=S.PARAMETER(+)
ORDER BY 1;
quit;
EOF
}
#
#########################################################################################################
# 
#########################################################################################################
#
function DBA_093() {
sqlplus -S / as sysdba <<EOF
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'

quit;
EOF
}
#
#########################################################################################################
# VERIFY ALL SQL IDS STATEMENTS
#########################################################################################################
#
function DBA_094() {
local OPT=$1
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 700 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
clear col bre comp
set pages 700 lines 700 long 9999999 numwidth 20 echo off verify off feedback off colsep '|'
col elapsed_time_in_sec format 9999.99
col first_load_time format a19
col last_load_time format a19
col SQL_FULLTEXT format a150
col child_number format 999 heading "CHLD|NUM"
col executions format 99999999 heading "EXECS"
col END_OF_FETCH_COUNT heading "FULL|EXECS"
col disk_reads heading "DISK|READS"
col buffer_gets heading "BUFFER|GETS"
col DIRECT_WRITES heading "DIRECT|WRITES"
col APPLICATION_WAIT_TIME heading "APP|WAIT|TIME"
col CONCURRENCY_WAIT_TIME heading "CONC|WAIT|TIME"
col CLUSTER_WAIT_TIME heading "CLUS|WAIT|TIME"
col USER_IO_WAIT_TIME heading "IO|WAIT|TIME"
col PLSQL_EXEC_TIME heading "PLSQL|EXEC|TIME"
col JAVA_EXEC_TIME heading "JAVA|EXEC|TIME"
col rows_processed format 999999999999 heading "ROWS|PROCESSED"
col optimizer_cost format 99999990 heading "COST"
col cpu_sec format 9999990.00 heading "CPU_TIME|SEC"
col elap_sec format 9999990.00 heading "ELAPSED|SEC"
col module format a50
col action format a50
col SHARABLE_MEM heading "SHARE|MEM"
col PERSISTENT_MEM heading "PERST|MEM"
col RUNTIME_MEM heading "RUN|MEM"
col LOADED_VERSIONS format 9999 heading "LOADED|VERS"
col KEPT_VERSIONS format 999 heading "KEPT|VERS"
col OPEN_VERSIONS format 999 heading "OPEN|VERS"
col loads format 9999
col INVALIDATIONS format 99999 heading "INVL"
col PARSE_CALLS format 99999999 heading "PARSE|CALLS"
col PARSING_USER_ID format 999999 heading "PARSING|USER|ID"
col PARSING_SCHEMA_ID format 999999 heading "PARSING|SCHEMA|ID"
prompt
prompt ##############################################################
prompt # CHECK MODULE AND ACTION                                    #
prompt ##############################################################
select child_number
  , MODULE
  , ACTION
  , PROGRAM_ID
  , PROGRAM_LINE#
from v\$sql
where sql_id='${OPT}'
/
prompt
prompt ##############################################################
prompt # CHECK MEMORY                                               #
prompt ##############################################################
select child_number
  , SHARABLE_MEM
  , PERSISTENT_MEM
  , RUNTIME_MEM
  , LOADED_VERSIONS
  , KEPT_VERSIONS
  , OPEN_VERSIONS
  , LOADS
  , INVALIDATIONS
  , PARSE_CALLS
  , FIRST_LOAD_TIME
  , LAST_LOAD_TIME
  , PARSING_USER_ID
  , PARSING_SCHEMA_ID
from v\$sql
-- where sql_id='${OPT}'
/
prompt
prompt ##############################################################
prompt # CHECK EXECS                                                #
prompt ##############################################################
select CHILD_NUMBER
  , EXECUTIONS
  , END_OF_FETCH_COUNT
  , DISK_READS
  , BUFFER_GETS
  , sorts
  , DIRECT_WRITES
  , FETCHES
  , ROWS_PROCESSED
  , OPTIMIZER_COST
from v\$sql
-- where sql_id='${OPT}'
/
prompt
prompt ##############################################################
prompt # CHECK CPU TIME                                             #
prompt ##############################################################
select CHILD_NUMBER
  , round(cpu_time/1000000,2) CPU_SEC
  , round(elapsed_time/1000000,2) elap_sec
  , APPLICATION_WAIT_TIME
  , CONCURRENCY_WAIT_TIME
  , CLUSTER_WAIT_TIME
  , USER_IO_WAIT_TIME
  , PLSQL_EXEC_TIME
  , JAVA_EXEC_TIME
from v\$sql
-- where sql_id='${OPT}'
/
prompt
prompt ##############################################################
prompt # CHECK SQL FULL TEXT OF STATEMENT                           #
prompt ##############################################################
select SQL_FULLTEXT
from v\$sql
-- where sql_id='${OPT}'
/
prompt
prompt ##############################################################
prompt # CHECK OBJECT LOB OF THE STATEMENT                          #
prompt ##############################################################
select distinct object_name LOB_NAME
from sys.x\$kglob, dba_objects
where KGLNAOBJ like 'table%'
and object_id = to_number(regexp_substr(KGLNAOBJ, '[^_]+', 1, 4),'xxxx')
-- and kglobt03 = '${OPT}'
/
prompt
prompt ##############################################################
prompt # CHECK CPU COSTS OF THE STATEMENT                           #
prompt ##############################################################
select SQL_ID
  , PLAN_HASH_VALUE
  , sum(EXECUTIONS_DELTA) EXECUTIONS
  , sum(ROWS_PROCESSED_DELTA) CROWS
  , trunc(sum(CPU_TIME_DELTA)/1000000/60) CPU_MINS
  , trunc(sum(ELAPSED_TIME_DELTA)/1000000/60) ELA_MINS
from DBA_HIST_SQLSTAT
where SQL_ID in ('${OPT}')
group by SQL_ID , PLAN_HASH_VALUE
order by SQL_ID, CPU_MINS
/
prompt
prompt ##############################################################
prompt # CHECK XPLAN FROM AWR REPORT                                #
prompt ##############################################################
select * FROM table(DBMS_XPLAN.DISPLAY_AWR('${SQL_ID}'))
/
prompt
prompt ##############################################################
prompt # CHECK SQL BASELINE FOR DIFFERENT EXECUTION PLAN PER TIME   #
prompt ##############################################################
select
-- q.snap_id,
to_char(s.begin_interval_time,'dd/mm/yyyy hh24:mi:ss') begin_interval_time,
-- to_char(s.end_interval_time,'dd/mm/yyyy hh24:mi:ss') end_interval_time,
PLAN_HASH_VALUE,
-- ROWS_PROCESSED_DELTA,
round(ROWS_PROCESSED_DELTA/executions_delta,0) rows_processed,
executions_delta executions_per_report,
round(executions_delta/900,0) executions_per_sec,
-- buffer_gets_delta,
round(buffer_gets_DELTA/executions_delta,0) buffer_gets,
round(DISK_READS_DELTA/executions_delta,0) disk_read,
round(ELAPSED_TIME_DELTA/executions_delta/1000000,3) elapsed_time_in_sec
from dba_hist_sqlstat q, dba_hist_snapshot s
where q.snap_id = s.snap_id
and  sql_id='${OPT}'
and  executions_delta > 0
order by q.snap_id
/
prompt
prompt ##############################################################
prompt # CHECK SQL BASELINE FOR EXECUTION PLAN                      #
prompt ##############################################################
col execs for 999,999,999
col avg_etime for 999,999.999
col avg_lio for 999,999,999.9
col begin_interval_time for a20
col node for 99999
break on plan_hash_value on startup_time skip 1
select ss.snap_id
  , ss.instance_number node
  , to_char(begin_interval_time, 'dd/mm/yyyy HH24:mm:ss') as begin_interval_time
  , sql_id
  , plan_hash_value
  , nvl(executions_delta,0) execs
  , (elapsed_time_delta/decode(nvl(executions_delta,0),0,1,executions_delta))/1000000 avg_etime
  , (buffer_gets_delta/decode(nvl(buffer_gets_delta,0),0,1,executions_delta)) avg_lio
from DBA_HIST_SQLSTAT S, DBA_HIST_SNAPSHOT SS
where sql_id = '${OPT}'
and ss.snap_id = S.snap_id
and ss.instance_number = S.instance_number
and executions_delta > 0
order by 1, 2, 3;
undefine SQL_ID
quit;
EOF
}
#
#########################################################################################################
# VERIFY ALL PATCHES APPLIED
#########################################################################################################
#
function DBA_095() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt # SHOW INFORMATION ABOUT PATCHES                             #
prompt ##############################################################
COLUMN action_time FORMAT A20
COLUMN action FORMAT A10
-- COLUMN bundle_series FORMAT A10
COLUMN comments FORMAT A30
COLUMN description FORMAT A90
COLUMN namespace FORMAT A20
COLUMN status FORMAT A15
COLUMN version FORMAT A10
SELECT TO_CHAR(action_time, 'DD/MM/YYYY HH24:MI:SS') AS action_time
  , action
  , status
  , description
-- , version
  , patch_id
-- , bundle_series
FROM sys.dba_registry_sqlpatch
ORDER by action_time;
prompt
prompt ##############################################################
prompt # SHOW INFORMATION ABOUT PATCHES WITH DETAILS                #
prompt ##############################################################
col version for a25
col comments for a85
SELECT TO_CHAR(action_time, 'DD/MM/YYYY HH24:MI:SS') AS action_time
  , action
  , namespace
  , version
  , id
  , comments
  , bundle_series
FROM sys.registry\$history
ORDER by action_time;
quit;
EOF
}
#
#########################################################################################################
# VERIFY CPU USAGE BY MINUTE
#########################################################################################################
#
function DBA_096() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col sample_time for a20
col CONFIGURATION head "CONFIG" for 99.99
col ADMINISTRATIVE head "ADMIN" for 99.99
col OTHER for 99.99
SELECT TO_CHAR(SAMPLE_TIME, 'DD/MM/YYYY HH24:MI:SS') AS SAMPLE_TIME
  , ROUND(OTHER/60, 3) AS OTHER
  , ROUND(CLUST/60, 3) AS CLUST
  , ROUND(QUEUEING/60, 3) AS QUEUEING
  , ROUND(NETWORK/60, 3) AS NETWORK
  , ROUND(ADMINISTRATIVE/60, 3) AS ADMINISTRATIVE
  , ROUND(CONFIGURATION/60, 3) AS CONFIGURATION
  , ROUND(COMMIT/60, 3) AS COMMIT
  , ROUND(APPLICATION/60, 3) AS APPLICATION
  , ROUND(CONCURRENCY/60, 3) AS CONCURRENCY
  , ROUND(SIO/60, 3) AS SYSTEM_IO
  , ROUND(UIO/60, 3) AS USER_IO
  , ROUND(SCHEDULER/60, 3) AS SCHEDULER
  , ROUND(CPU/60, 3) AS CPU
  , ROUND(BCPU/60, 3) AS BACKGROUND_CPU
FROM (
  SELECT TRUNC(SAMPLE_TIME, 'MI') AS SAMPLE_TIME
    , DECODE(SESSION_STATE, 'ON CPU'
	, DECODE(SESSION_TYPE, 'BACKGROUND', 'BCPU', 'ON CPU')
	, WAIT_CLASS) AS WAIT_CLASS 
  FROM V\$ACTIVE_SESSION_HISTORY 
  WHERE SAMPLE_TIME > SYSDATE - INTERVAL '2' HOUR 
  AND SAMPLE_TIME <= TRUNC(SYSDATE, 'MI')) ASH PIVOT(COUNT(*) FOR WAIT_CLASS IN ('ON CPU' AS CPU
, 'BCPU' AS BCPU
, 'Scheduler' AS SCHEDULER
, 'User I/O' AS UIO
, 'System I/O' AS SIO
, 'Concurrency' AS CONCURRENCY
, 'Application' AS APPLICATION
, 'Commit' AS COMMIT
, 'Configuration' AS CONFIGURATION
, 'Administrative' AS ADMINISTRATIVE
, 'Network' AS NETWORK
, 'Queueing' AS QUEUEING
, 'Cluster' AS CLUST
, 'Other' AS OTHER))
order by 1;
quit;
EOF
}
#
#########################################################################################################
# VERIFY STANDBY CONFIGURATION
#########################################################################################################
#
function DBA_097() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
prompt ##############################################################
prompt #
prompt ##############################################################
column name for a30
column display_value for a30
column ID format 99
column "SRLs" format 99
column active format 99
column type format a4
column ID format 99
column "SRLs" format 99
column active format 99
column type format a4
column PROTECTION_MODE for a20
column RECOVERY_MODE for a20
column db_mode for a15
SELECT name, display_value 
FROM v\$parameter 
WHERE name IN ('db_name'
,'db_unique_name'
,'log_archive_config'
,'log_archive_dest_2'
,'log_archive_dest_state_2'
,'fal_client'
,'fal_server'
,'standby_file_management'
,'standby_archive_dest'
,'db_file_name_convert'
,'log_file_name_convert'
,'remote_login_passwordfile'
,'local_listener'
,'dg_broker_start'
,'dg_broker_config_file1'
,'dg_broker_config_file2'
,'log_archive_max_processes') 
order by name;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
column name for a10
column DATABASE_ROLE for a10
SELECT name
  , db_unique_name
  , protection_mode
  , DATABASE_ROLE
  , OPEN_MODE
  , switchover_status 
from v\$database;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
select thread#
  , max(sequence#) 
from v\$archived_log 
group by thread#;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
column severity for a15
column message for a70
column timestamp for a20
select severity
  , error_code
  , to_char(timestamp,'DD-MON-YYYY HH24:MI:SS') "timestamp"
  , message from 
v\$dataguard_status 
where dest_id=2;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
select ds.dest_id id
  , ad.status
  , ds.database_mode db_mode
  , ad.archiver type
  , ds.recovery_mode
  , ds.protection_mode
  , ds.standby_logfile_count "SRLs"
  , ds.standby_logfile_active active
  , ds.archived_seq#
from v\$archive_dest_status ds
  , v\$archive_dest ad
where ds.dest_id = ad.dest_id
and ad.status != 'INACTIVE'
order by
ds.dest_id;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
column FILE_TYPE format a20
col name format a60
select name
  , floor(space_limit/1024/1024) "Size MB"
  , ceil(space_used/1024/1024) "Used MB"
from v\$recovery_file_dest
order by name;
prompt
prompt ##############################################################
prompt # ON STANDBY
prompt ##############################################################
column name for a30
column display_value for a30
col value for a10
col PROTECTION_MODE for a15
col DATABASE_Role for a15
SELECT name
  , display_value 
FROM v\$parameter 
WHERE name IN ('db_name'
,'db_unique_name'
,'log_archive_config'
,'log_archive_dest_2'
,'log_archive_dest_state_2'
,'fal_client'
,'fal_server'
,'standby_file_management'
,'standby_archive_dest'
,'db_file_name_convert'
,'log_file_name_convert'
,'remote_login_passwordfile'
,'local_listener'
,'dg_broker_start'
,'dg_broker_config_file1'
,'dg_broker_config_file2'
,'log_archive_max_processes') 
order by name;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
col name for a10
col DATABASE_ROLE for a10
SELECT name
  , db_unique_name
  , protection_mode
  , DATABASE_ROLE
  , OPEN_MODE 
from v\$database;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
select thread#
  , max(sequence#) 
from v\$archived_log 
where applied='YES' 
group by thread#;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
select process
  , status
  , thread#
  , sequence# 
from v\$managed_standby;
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
SELECT ARCH.THREAD# "Thread"
  , ARCH.SEQUENCE# "Last Sequence Received"
  , APPL.SEQUENCE# "Last Sequence Applied"
  , (ARCH.SEQUENCE# - APPL.SEQUENCE#) "Difference"
FROM 
(SELECT THREAD#, SEQUENCE# FROM V\$ARCHIVED_LOG WHERE (THREAD#, FIRST_TIME) IN (SELECT THREAD#, MAX(FIRST_TIME) FROM V\$ARCHIVED_LOG GROUP BY THREAD#)) ARCH,
(SELECT THREAD#, SEQUENCE# FROM V\$LOG_HISTORY WHERE (THREAD#, FIRST_TIME) IN (SELECT THREAD#, MAX(FIRST_TIME) FROM V\$LOG_HISTORY GROUP BY THREAD#)) APPL
WHERE ARCH.THREAD# = APPL.THREAD# ORDER BY 1;
col name for a30 
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
select * from v\$dataguard_stats; 
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
select * from v\$archive_gap; 
prompt
prompt ##############################################################
prompt #
prompt ##############################################################
col name format a60 
select name
  , floor(space_limit/1024/1024) "Size MB"
  , ceil(space_used/1024/1024) "Used MB" 
from v\$recovery_file_dest 
order by name;
quit;
EOF
}
#
#########################################################################################################
# VERIFY GRANTS AND PERMISSIONS BY OWNER
#########################################################################################################
#
function DBA_098() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col PRIVILEGE for a40
col OBJ_OWNER for a20
col OBJ_NAME for a40
col USERNAME for a20
col GRANT_SOURCES for a40
SELECT PRIVILEGE
  , OBJ_OWNER
  , OBJ_NAME
  , USERNAME
  , LISTAGG(GRANT_TARGET, ',') WITHIN GROUP (ORDER BY GRANT_TARGET) AS GRANT_SOURCES
  , MAX(ADMIN_OR_GRANT_OPT) AS ADMIN_OR_GRANT_OPT
  , MAX(HIERARCHY_OPT) AS HIERARCHY_OPT
FROM (WITH ALL_ROLES_FOR_USER AS (SELECT DISTINCT CONNECT_BY_ROOT GRANTEE AS GRANTED_USER, GRANTED_ROLE FROM DBA_ROLE_PRIVS CONNECT BY GRANTEE = PRIOR GRANTED_ROLE)
    SELECT PRIVILEGE
      , OBJ_OWNER
      , OBJ_NAME
      , USERNAME
      , REPLACE(GRANT_TARGET, USERNAME, 'Direct to user') AS GRANT_TARGET
      , ADMIN_OR_GRANT_OPT
      , HIERARCHY_OPT
    FROM (SELECT PRIVILEGE, NULL AS OBJ_OWNER, NULL AS OBJ_NAME, GRANTEE AS USERNAME, GRANTEE AS GRANT_TARGET, ADMIN_OPTION AS ADMIN_OR_GRANT_OPT, NULL AS HIERARCHY_OPT FROM DBA_SYS_PRIVS WHERE GRANTEE IN (SELECT USERNAME FROM DBA_USERS)
        UNION ALL
        SELECT PRIVILEGE, NULL AS OBJ_OWNER, NULL AS OBJ_NAME, ALL_ROLES_FOR_USER.GRANTED_USER AS USERNAME, GRANTEE AS GRANT_TARGET, ADMIN_OPTION AS ADMIN_OR_GRANT_OPT, NULL AS HIERARCHY_OPT FROM DBA_SYS_PRIVS
        JOIN ALL_ROLES_FOR_USER ON ALL_ROLES_FOR_USER.GRANTED_ROLE = DBA_SYS_PRIVS.GRANTEE
        UNION ALL
        SELECT PRIVILEGE, OWNER AS OBJ_OWNER, TABLE_NAME AS OBJ_NAME, GRANTEE AS USERNAME, GRANTEE AS GRANT_TARGET, GRANTABLE, HIERARCHY FROM DBA_TAB_PRIVS WHERE GRANTEE IN (SELECT USERNAME FROM DBA_USERS)
        UNION ALL
        SELECT PRIVILEGE, OWNER AS OBJ_OWNER, TABLE_NAME AS OBJ_NAME, GRANTEE AS USERNAME, ALL_ROLES_FOR_USER.GRANTED_ROLE AS GRANT_TARGET, GRANTABLE, HIERARCHY FROM DBA_TAB_PRIVS
        JOIN ALL_ROLES_FOR_USER ON ALL_ROLES_FOR_USER.GRANTED_ROLE = DBA_TAB_PRIVS.GRANTEE
    ) ALL_USER_PRIVS
      -- WHERE USERNAME in ('')
	) DISTINCT_USER_PRIVS
GROUP BY PRIVILEGE, OBJ_OWNER, OBJ_NAME, USERNAME;
quit;
EOF
}
#
#########################################################################################################
# 
#########################################################################################################
#
function DBA_099() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'

quit;
EOF
}
#
#########################################################################################################
# VERIFY BACKUP RUNNING ON REAL TIME
#########################################################################################################
#
function DBA_100() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
COL MESSAGE FORMAT A100
COL FILENAME FORMAT A100
SELECT SID
  , SERIAL#
  , START_TIME
  , ((SOFAR/TOTALWORK)*100) as TOTAL_WORKED
  , '%' as PERC
  , TIME_REMAINING
  , MESSAGE 
FROM V\$SESSION_LONGOPS 
where TIME_REMAINING > 0 
ORDER BY TIME_REMAINING;
prompt
prompt ##############################################################
prompt
prompt ##############################################################
SELECT FILENAME
  , BYTES/1024/1024/1024
FROM GV\$BACKUP_ASYNC_IO 
WHERE STATUS='IN PROGRESS';
prompt
prompt ##############################################################
prompt
prompt ##############################################################
SELECT INPUT_TYPE
  , TO_CHAR(START_TIME, 'DD/MM/YYYY, HH24:MI:SS') as STARTED
  , TO_CHAR(END_TIME, 'DD/MM/YYYY, HH24:MI:SS') as FINISHED
  , STATUS 
FROM V\$RMAN_BACKUP_JOB_DETAILS 
ORDER BY START_TIME;
quit;
EOF
}
#
#########################################################################################################
# VERIFY DATABASE COMPONENTS FROM REGISTRY
#########################################################################################################
#
function DBA_101() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
col COMP_ID format a15
col COMP_NAME format a50
col SCHEMA format a15
col STATUS format a15
col VERSION format a15
col CON_ID format 99
select CON_ID, COMP_ID, comp_name, schema, status, version from CDB_REGISTRY order by 1,2;
quit;
EOF
}
#
#########################################################################################################
# Dataguard Health Check
#########################################################################################################
#
function DBA_102() {
sqlplus -S / as sysdba <<EOF
set feedback off timing off
alter session set nls_date_format='dd/mm/yyyy';
set pages 700 lines 1000 timing on long 9999999 numwidth 20 heading on echo on verify on feedback on colsep '|'
-- 
-- Author    : Ludovico Caldara
-- Version   : 0.1
-- Purpose   : Checks the health of a Data Guard configuration on ONE database
-- Run as    : SYSDBA , to execute on each DB in the config it does not check ALL the DBs in the configuration but only the current one
--             You can use a wrapper to check all the DBs in the configuration or all the standby instances on a server
-- Limitations: Does not work on RAC environments yet
--              Does not work on 11g databases (tested on 19c)

DECLARE
	v_dgconfig BINARY_INTEGER;
	v_num_errors BINARY_INTEGER;
	v_num_warnings BINARY_INTEGER;
	v_apply_lag INTERVAL DAY TO SECOND;
	v_transport_lag INTERVAL DAY TO SECOND;
	v_apply_th INTERVAL DAY TO SECOND;
	v_transport_th INTERVAL DAY TO SECOND;
	v_delay INTERVAL DAY TO SECOND;
	v_delaymins BINARY_INTEGER;
	v_flashback v$database.flashback_on%type;

	CURSOR c_dgconfig IS SELECT piv.*, obj.status FROM (SELECT object_id, attribute, value FROM x$drc WHERE object_id IN ( SELECT object_id FROM x$drc WHERE attribute = 'DATABASE')
	) drc PIVOT ( MAX ( value ) FOR attribute
	IN ('DATABASE' DATABASE ,
		'intended_state' intended_state ,
		'connect_string' connect_string ,
		'enabled' enabled ,
		'role' role ,
		'receive_from' receive_from ,
		'ship_to' ship_to ,
		'FSFOTargetValidity' FSFOTargetValidity)
	) piv JOIN x$drc obj ON ( obj.object_id = piv.object_id AND obj.attribute = 'DATABASE' )
	WHERE lower(piv.database)=lower(sys_context('USERENV','DB_UNIQUE_NAME'));
 
	CURSOR c_priconfig IS SELECT piv.*, obj.status FROM (SELECT object_id, attribute, value FROM x$drc WHERE object_id IN ( SELECT object_id FROM x$drc WHERE attribute = 'DATABASE')
	) drc PIVOT ( MAX ( value ) FOR attribute
	IN ('DATABASE' DATABASE ,
		'intended_state' intended_state ,
		'connect_string' connect_string ,
		'enabled' enabled ,
		'role' role ,
		'receive_from' receive_from ,
		'ship_to' ship_to ,
		'FSFOTargetValidity' FSFOTargetValidity)
	) piv JOIN x$drc obj ON ( obj.object_id = piv.object_id AND obj.attribute = 'DATABASE' )
	WHERE piv.role='PRIMARY';
 
	r_dgconfig c_dgconfig%ROWTYPE;
	r_priconfig c_priconfig%ROWTYPE;
 
	v_open_mode v$database.open_mode%TYPE;
 
	-- variables for the dbms_drs.do_control
	v_indoc VARCHAR2 ( 4000 );
	v_outdoc VARCHAR2 ( 4000 );
	v_rid NUMBER;
	v_context VARCHAR2(100);
	v_pieceno NUMBER ;
	/* xmltype does not work on mounted databases 
	v_y CLOB;
	v_z XMLTYPE;
	v_xml XMLTYPE;
	*/
	v_status VARCHAR2(100);
	v_error VARCHAR2(100);
	v_p_connect BINARY_INTEGER;
	v_s_connect BINARY_INTEGER;
	v_offline_datafiles BINARY_INTEGER;
BEGIN
	v_num_errors := 0;
	v_num_warnings := 0;
	v_p_connect := 0;
	v_s_connect := 0;
	dbms_output.put_line('Checking Data Guard Configuration for '||sys_context('USERENV','DB_UNIQUE_NAME'));
	dbms_output.put_line('--------------------------------------');
	-- get open_mode
	SELECT open_mode INTO v_open_mode FROM v$database;
	-- check if the configuration exists
	SELECT count(*) INTO v_dgconfig FROM x$drc;
	IF v_dgconfig = 0 THEN
		dbms_output.put_line('ERROR: Current database does not have a Data Guard config.');
		v_num_errors := v_num_errors + 1;
		GOTO stop_checks;
	else
		dbms_output.put_line('___OK: Current database has a Data Guard config.');
	END IF;
	-- fetch the current DB config in record
	OPEN c_dgconfig;
	BEGIN
		FETCH c_dgconfig INTO r_dgconfig;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN 
			dbms_output.put_line('ERROR: Current database does not have a Data Guard config.');
			v_num_errors := v_num_errors + 1;
			GOTO stop_checks;
	END;
	-- fetch the primary DB config in record
	OPEN c_priconfig;
	BEGIN
		FETCH c_priconfig INTO r_priconfig;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN 
			dbms_output.put_line('ERROR: There is no primary database in the config?');
			v_num_errors := v_num_errors + 1;
			GOTO stop_checks;
	END;
	-- enabled?
	IF r_dgconfig.enabled = 'YES' THEN
		dbms_output.put_line('___OK: Current database is enabled in Data Guard.');
	ELSE
		dbms_output.put_line('ERROR: Current database is not enabled in Data Guard.');
		v_num_errors := v_num_errors + 1;
	END IF;
	-- status SUCCESS?
	IF r_dgconfig.status = 'SUCCESS' THEN
		dbms_output.put_line('___OK: Data Guard status for the database is: '||r_dgconfig.status);
	ELSE
		dbms_output.put_line('ERROR: Data Guard status for the database is: '||r_dgconfig.status);
		v_num_errors := v_num_errors + 1;
	END IF;
	-- reachability of the primary
	BEGIN
		dbms_drs.CHECK_CONNECT (r_priconfig.database ,r_priconfig.database);
		dbms_output.put_line('___OK: Primary ('||r_priconfig.database||') is reachable.');
		v_p_connect := 1;
	EXCEPTION
		WHEN OTHERS THEN
		dbms_output.put_line('ERROR: Primary ('||r_priconfig.database||') unreachable. Error code ' || SQLCODE || ': ' || SQLERRM);
		v_num_errors := v_num_errors + 1;
	END;
	-- if we are not on the primary, check the current database connectivity as well through the broker
	IF r_priconfig.object_id <> r_dgconfig.object_id THEN
		BEGIN
			dbms_drs.CHECK_CONNECT (r_dgconfig.database ,r_dgconfig.database);
			dbms_output.put_line('___OK: current DB ('||r_dgconfig.database||') is reachable.');
			v_s_connect := 1;
		EXCEPTION
			WHEN OTHERS THEN
			dbms_output.put_line('ERROR: current DB ('||r_dgconfig.database||') unreachable. Error code ' || SQLCODE || ': ' || SQLERRM);
			v_num_errors := v_num_errors + 1;
		END;
	END IF;
	-- we check primary transport only if reachable
	IF v_p_connect = 1 THEN
		-- primary logxpt?
		v_indoc := '<DO_MONITOR version="19.1"><PROPERTY name="LogXptStatus" object_id="'||r_priconfig.object_id||'"/></DO_MONITOR>';
		v_pieceno  := 1;
		dbms_drs.do_control(v_indoc, v_outdoc, v_rid, v_pieceno, v_context);
	
		select regexp_substr(v_outdoc, '(<TD >)([[:alnum:]].*?)(</TD>)',1,3,'i',2) into v_status from dual;
 
		/* does not work on MOUNTED databases 
		v_y := TO_CLOB ( v_outdoc );
		v_z := XMLType ( v_y );
		select xt.status , xt.error into v_status, v_error from xmltable  ('/TABLE/TR' passing v_z columns status varchar2(100) PATH 'TD[3]', error varchar2(100) PATH 'TD[4]') xt ;
		*/
 
		IF v_status = 'VALID' THEN
			dbms_output.put_line('___OK: LogXptStatus of primary is VALID.');
		ELSE
			dbms_output.put_line('ERROR: LogXptStatus of primary is '||nvl(v_status,'NULL'));
			v_num_errors := v_num_errors + 1;
		END IF;
	END IF;
	-- flashback?
	SELECT flashback_on into v_flashback
	FROM v$database;
	IF v_flashback = 'YES' THEN
		dbms_output.put_line('___OK: Flashback Logging is enabled.');
	ELSE
		dbms_output.put_line('_WARN: Flashback Logging is disabled.');
		v_num_warnings := v_num_warnings + 1;
	END IF;
	-- role?
	IF r_dgconfig.ROLE = 'PRIMARY' THEN
		dbms_output.put_line('___OK: The database is PRIMARY, skipping standby checks.');
		GOTO stop_checks;
	ELSE
		dbms_output.put_line('___OK: The database is STANDBY, executing standby checks.');
	END IF;
	-- intended state?
	IF r_dgconfig.intended_state = 'PHYSICAL-APPLY-ON' THEN
		dbms_output.put_line('___OK: The database intended state is APPLY-ON.');
	ELSIF r_dgconfig.intended_state = 'PHYSICAL-APPLY-READY' THEN
		dbms_output.put_line('_WARN: The database intended state is APPLY-OFF.');
		v_num_warnings := v_num_warnings + 1;
	ELSE
		dbms_output.put_line('ERROR: The database intended state is '||r_dgconfig.intended_state);
		v_num_errors := v_num_errors + 1;
	END IF;
	-- real time apply?
	IF v_open_mode = 'READ ONLY WITH APPLY' THEN
		dbms_output.put_line('_WARN: Real Time Apply is used.');
		v_num_warnings := v_num_warnings + 1;
	ELSIF v_open_mode = 'MOUNTED' THEN
		dbms_output.put_line('___OK: The standby database is mounted.');
	ELSE
		dbms_output.put_line('ERROR: The database open_mode is '||v_open_mode);
		v_num_errors := v_num_errors + 1;
	END IF;
	-- offline datafiles?
	BEGIN
		select count(distinct con_id) into v_offline_datafiles from v$recover_file where online_status='OFFLINE' group by con_id;
		dbms_output.put_line('ERROR: There are '||v_offline_datafiles||' OFFLINE datafiles');
		v_num_errors := v_num_errors + 1;
	EXCEPTION WHEN NO_DATA_FOUND THEN
		dbms_output.put_line('___OK: There are no PDBs with OFFLINE datafiles');
	END;
 	-- we get the delay as well, so that we can compute the apply threshold in a more intelligent way than the broker...
	v_delaymins := dbms_drs.get_property_obj(r_dgconfig.object_id,'DelayMins');
	v_delay := numtodsinterval(v_delaymins,'minute');
 
	IF v_delaymins > 0 THEN
		dbms_output.put_line('_WARN: Standby delayed by '||v_delaymins||' minutes.');
		v_num_warnings := v_num_warnings + 1;
	END IF;
 
	-- apply lag?
	v_apply_th := numtodsinterval(dbms_drs.get_property_obj(r_dgconfig.object_id,'ApplyLagThreshold'),'second');
	BEGIN
		SELECT TO_DSINTERVAL(value) into v_apply_lag FROM v$dataguard_stats WHERE name='apply lag';
		IF v_apply_lag > ( v_apply_th + v_delay ) THEN
			dbms_output.put_line('ERROR: apply lag is '||v_apply_lag);
			v_num_errors := v_num_errors + 1;
		ELSE
			dbms_output.put_line('___OK: apply lag is '||v_apply_lag);
		END IF;
	EXCEPTION WHEN OTHERS THEN
		dbms_output.put_line('ERROR: cannot determine apply lag.');
		v_num_errors := v_num_errors + 1;
	END;
 
	-- transport lag?
	v_transport_lag := numtodsinterval(dbms_drs.get_property_obj(r_dgconfig.object_id,'TransportLagThreshold'),'second');
	BEGIN
		SELECT TO_DSINTERVAL(value) into v_transport_lag FROM v$dataguard_stats WHERE name='transport lag';
		IF v_transport_lag > v_transport_th THEN
			dbms_output.put_line('ERROR: transport lag is '||v_transport_lag);
			v_num_errors := v_num_errors + 1;
		ELSE
			dbms_output.put_line('___OK: transport lag is '||v_transport_lag);
		END IF;
	EXCEPTION WHEN OTHERS THEN
		dbms_output.put_line('_WARN: cannot determine transport lag.');
		v_num_warnings := v_num_warnings + 1;
	END;
	
	<<stop_checks>>
	
	dbms_output.put_line('--------------------------------------');
	IF v_num_errors > 0 THEN
		dbms_output.put_line('RESULT: ERROR: '||to_char(v_num_errors)||' errors - '||to_char(v_num_warnings)||' warnings');
	ELSIF v_num_warnings > 0 THEN
		dbms_output.put_line('RESULT: _WARN: '||to_char(v_num_errors)||' errors - '||to_char(v_num_warnings)||' warnings');
	ELSE
		dbms_output.put_line('RESULT: ___OK: '||to_char(v_num_errors)||' errors - '||to_char(v_num_warnings)||' warnings');
	END IF;
END;
/
quit;
EOF
}
#
#########################################################################################################
# Finish of the System
#########################################################################################################
